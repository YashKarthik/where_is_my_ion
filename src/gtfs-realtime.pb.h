// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: gtfs-realtime.proto
// Protobuf C++ Version: 5.29.3

#ifndef gtfs_2drealtime_2eproto_2epb_2eh
#define gtfs_2drealtime_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_gtfs_2drealtime_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_gtfs_2drealtime_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_gtfs_2drealtime_2eproto;
namespace transit_realtime {
class Alert;
struct AlertDefaultTypeInternal;
extern AlertDefaultTypeInternal _Alert_default_instance_;
class EntitySelector;
struct EntitySelectorDefaultTypeInternal;
extern EntitySelectorDefaultTypeInternal _EntitySelector_default_instance_;
class FeedEntity;
struct FeedEntityDefaultTypeInternal;
extern FeedEntityDefaultTypeInternal _FeedEntity_default_instance_;
class FeedHeader;
struct FeedHeaderDefaultTypeInternal;
extern FeedHeaderDefaultTypeInternal _FeedHeader_default_instance_;
class FeedMessage;
struct FeedMessageDefaultTypeInternal;
extern FeedMessageDefaultTypeInternal _FeedMessage_default_instance_;
class Position;
struct PositionDefaultTypeInternal;
extern PositionDefaultTypeInternal _Position_default_instance_;
class ReplacementStop;
struct ReplacementStopDefaultTypeInternal;
extern ReplacementStopDefaultTypeInternal _ReplacementStop_default_instance_;
class Shape;
struct ShapeDefaultTypeInternal;
extern ShapeDefaultTypeInternal _Shape_default_instance_;
class Stop;
struct StopDefaultTypeInternal;
extern StopDefaultTypeInternal _Stop_default_instance_;
class StopSelector;
struct StopSelectorDefaultTypeInternal;
extern StopSelectorDefaultTypeInternal _StopSelector_default_instance_;
class TimeRange;
struct TimeRangeDefaultTypeInternal;
extern TimeRangeDefaultTypeInternal _TimeRange_default_instance_;
class TranslatedImage;
struct TranslatedImageDefaultTypeInternal;
extern TranslatedImageDefaultTypeInternal _TranslatedImage_default_instance_;
class TranslatedImage_LocalizedImage;
struct TranslatedImage_LocalizedImageDefaultTypeInternal;
extern TranslatedImage_LocalizedImageDefaultTypeInternal _TranslatedImage_LocalizedImage_default_instance_;
class TranslatedString;
struct TranslatedStringDefaultTypeInternal;
extern TranslatedStringDefaultTypeInternal _TranslatedString_default_instance_;
class TranslatedString_Translation;
struct TranslatedString_TranslationDefaultTypeInternal;
extern TranslatedString_TranslationDefaultTypeInternal _TranslatedString_Translation_default_instance_;
class TripDescriptor;
struct TripDescriptorDefaultTypeInternal;
extern TripDescriptorDefaultTypeInternal _TripDescriptor_default_instance_;
class TripDescriptor_ModifiedTripSelector;
struct TripDescriptor_ModifiedTripSelectorDefaultTypeInternal;
extern TripDescriptor_ModifiedTripSelectorDefaultTypeInternal _TripDescriptor_ModifiedTripSelector_default_instance_;
class TripModifications;
struct TripModificationsDefaultTypeInternal;
extern TripModificationsDefaultTypeInternal _TripModifications_default_instance_;
class TripModifications_Modification;
struct TripModifications_ModificationDefaultTypeInternal;
extern TripModifications_ModificationDefaultTypeInternal _TripModifications_Modification_default_instance_;
class TripModifications_SelectedTrips;
struct TripModifications_SelectedTripsDefaultTypeInternal;
extern TripModifications_SelectedTripsDefaultTypeInternal _TripModifications_SelectedTrips_default_instance_;
class TripUpdate;
struct TripUpdateDefaultTypeInternal;
extern TripUpdateDefaultTypeInternal _TripUpdate_default_instance_;
class TripUpdate_StopTimeEvent;
struct TripUpdate_StopTimeEventDefaultTypeInternal;
extern TripUpdate_StopTimeEventDefaultTypeInternal _TripUpdate_StopTimeEvent_default_instance_;
class TripUpdate_StopTimeUpdate;
struct TripUpdate_StopTimeUpdateDefaultTypeInternal;
extern TripUpdate_StopTimeUpdateDefaultTypeInternal _TripUpdate_StopTimeUpdate_default_instance_;
class TripUpdate_StopTimeUpdate_StopTimeProperties;
struct TripUpdate_StopTimeUpdate_StopTimePropertiesDefaultTypeInternal;
extern TripUpdate_StopTimeUpdate_StopTimePropertiesDefaultTypeInternal _TripUpdate_StopTimeUpdate_StopTimeProperties_default_instance_;
class TripUpdate_TripProperties;
struct TripUpdate_TripPropertiesDefaultTypeInternal;
extern TripUpdate_TripPropertiesDefaultTypeInternal _TripUpdate_TripProperties_default_instance_;
class VehicleDescriptor;
struct VehicleDescriptorDefaultTypeInternal;
extern VehicleDescriptorDefaultTypeInternal _VehicleDescriptor_default_instance_;
class VehiclePosition;
struct VehiclePositionDefaultTypeInternal;
extern VehiclePositionDefaultTypeInternal _VehiclePosition_default_instance_;
class VehiclePosition_CarriageDetails;
struct VehiclePosition_CarriageDetailsDefaultTypeInternal;
extern VehiclePosition_CarriageDetailsDefaultTypeInternal _VehiclePosition_CarriageDetails_default_instance_;
}  // namespace transit_realtime
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace transit_realtime {
enum FeedHeader_Incrementality : int {
  FeedHeader_Incrementality_FULL_DATASET = 0,
  FeedHeader_Incrementality_DIFFERENTIAL = 1,
};

bool FeedHeader_Incrementality_IsValid(int value);
extern const uint32_t FeedHeader_Incrementality_internal_data_[];
constexpr FeedHeader_Incrementality FeedHeader_Incrementality_Incrementality_MIN = static_cast<FeedHeader_Incrementality>(0);
constexpr FeedHeader_Incrementality FeedHeader_Incrementality_Incrementality_MAX = static_cast<FeedHeader_Incrementality>(1);
constexpr int FeedHeader_Incrementality_Incrementality_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
FeedHeader_Incrementality_descriptor();
template <typename T>
const std::string& FeedHeader_Incrementality_Name(T value) {
  static_assert(std::is_same<T, FeedHeader_Incrementality>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Incrementality_Name().");
  return FeedHeader_Incrementality_Name(static_cast<FeedHeader_Incrementality>(value));
}
template <>
inline const std::string& FeedHeader_Incrementality_Name(FeedHeader_Incrementality value) {
  return ::google::protobuf::internal::NameOfDenseEnum<FeedHeader_Incrementality_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool FeedHeader_Incrementality_Parse(absl::string_view name, FeedHeader_Incrementality* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FeedHeader_Incrementality>(
      FeedHeader_Incrementality_descriptor(), name, value);
}
enum TripUpdate_StopTimeUpdate_ScheduleRelationship : int {
  TripUpdate_StopTimeUpdate_ScheduleRelationship_SCHEDULED = 0,
  TripUpdate_StopTimeUpdate_ScheduleRelationship_SKIPPED = 1,
  TripUpdate_StopTimeUpdate_ScheduleRelationship_NO_DATA = 2,
  TripUpdate_StopTimeUpdate_ScheduleRelationship_UNSCHEDULED = 3,
};

bool TripUpdate_StopTimeUpdate_ScheduleRelationship_IsValid(int value);
extern const uint32_t TripUpdate_StopTimeUpdate_ScheduleRelationship_internal_data_[];
constexpr TripUpdate_StopTimeUpdate_ScheduleRelationship TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_MIN = static_cast<TripUpdate_StopTimeUpdate_ScheduleRelationship>(0);
constexpr TripUpdate_StopTimeUpdate_ScheduleRelationship TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_MAX = static_cast<TripUpdate_StopTimeUpdate_ScheduleRelationship>(3);
constexpr int TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
TripUpdate_StopTimeUpdate_ScheduleRelationship_descriptor();
template <typename T>
const std::string& TripUpdate_StopTimeUpdate_ScheduleRelationship_Name(T value) {
  static_assert(std::is_same<T, TripUpdate_StopTimeUpdate_ScheduleRelationship>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ScheduleRelationship_Name().");
  return TripUpdate_StopTimeUpdate_ScheduleRelationship_Name(static_cast<TripUpdate_StopTimeUpdate_ScheduleRelationship>(value));
}
template <>
inline const std::string& TripUpdate_StopTimeUpdate_ScheduleRelationship_Name(TripUpdate_StopTimeUpdate_ScheduleRelationship value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TripUpdate_StopTimeUpdate_ScheduleRelationship_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool TripUpdate_StopTimeUpdate_ScheduleRelationship_Parse(absl::string_view name, TripUpdate_StopTimeUpdate_ScheduleRelationship* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TripUpdate_StopTimeUpdate_ScheduleRelationship>(
      TripUpdate_StopTimeUpdate_ScheduleRelationship_descriptor(), name, value);
}
enum VehiclePosition_VehicleStopStatus : int {
  VehiclePosition_VehicleStopStatus_INCOMING_AT = 0,
  VehiclePosition_VehicleStopStatus_STOPPED_AT = 1,
  VehiclePosition_VehicleStopStatus_IN_TRANSIT_TO = 2,
};

bool VehiclePosition_VehicleStopStatus_IsValid(int value);
extern const uint32_t VehiclePosition_VehicleStopStatus_internal_data_[];
constexpr VehiclePosition_VehicleStopStatus VehiclePosition_VehicleStopStatus_VehicleStopStatus_MIN = static_cast<VehiclePosition_VehicleStopStatus>(0);
constexpr VehiclePosition_VehicleStopStatus VehiclePosition_VehicleStopStatus_VehicleStopStatus_MAX = static_cast<VehiclePosition_VehicleStopStatus>(2);
constexpr int VehiclePosition_VehicleStopStatus_VehicleStopStatus_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
VehiclePosition_VehicleStopStatus_descriptor();
template <typename T>
const std::string& VehiclePosition_VehicleStopStatus_Name(T value) {
  static_assert(std::is_same<T, VehiclePosition_VehicleStopStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to VehicleStopStatus_Name().");
  return VehiclePosition_VehicleStopStatus_Name(static_cast<VehiclePosition_VehicleStopStatus>(value));
}
template <>
inline const std::string& VehiclePosition_VehicleStopStatus_Name(VehiclePosition_VehicleStopStatus value) {
  return ::google::protobuf::internal::NameOfDenseEnum<VehiclePosition_VehicleStopStatus_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool VehiclePosition_VehicleStopStatus_Parse(absl::string_view name, VehiclePosition_VehicleStopStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VehiclePosition_VehicleStopStatus>(
      VehiclePosition_VehicleStopStatus_descriptor(), name, value);
}
enum VehiclePosition_CongestionLevel : int {
  VehiclePosition_CongestionLevel_UNKNOWN_CONGESTION_LEVEL = 0,
  VehiclePosition_CongestionLevel_RUNNING_SMOOTHLY = 1,
  VehiclePosition_CongestionLevel_STOP_AND_GO = 2,
  VehiclePosition_CongestionLevel_CONGESTION = 3,
  VehiclePosition_CongestionLevel_SEVERE_CONGESTION = 4,
};

bool VehiclePosition_CongestionLevel_IsValid(int value);
extern const uint32_t VehiclePosition_CongestionLevel_internal_data_[];
constexpr VehiclePosition_CongestionLevel VehiclePosition_CongestionLevel_CongestionLevel_MIN = static_cast<VehiclePosition_CongestionLevel>(0);
constexpr VehiclePosition_CongestionLevel VehiclePosition_CongestionLevel_CongestionLevel_MAX = static_cast<VehiclePosition_CongestionLevel>(4);
constexpr int VehiclePosition_CongestionLevel_CongestionLevel_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
VehiclePosition_CongestionLevel_descriptor();
template <typename T>
const std::string& VehiclePosition_CongestionLevel_Name(T value) {
  static_assert(std::is_same<T, VehiclePosition_CongestionLevel>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CongestionLevel_Name().");
  return VehiclePosition_CongestionLevel_Name(static_cast<VehiclePosition_CongestionLevel>(value));
}
template <>
inline const std::string& VehiclePosition_CongestionLevel_Name(VehiclePosition_CongestionLevel value) {
  return ::google::protobuf::internal::NameOfDenseEnum<VehiclePosition_CongestionLevel_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool VehiclePosition_CongestionLevel_Parse(absl::string_view name, VehiclePosition_CongestionLevel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VehiclePosition_CongestionLevel>(
      VehiclePosition_CongestionLevel_descriptor(), name, value);
}
enum VehiclePosition_OccupancyStatus : int {
  VehiclePosition_OccupancyStatus_EMPTY = 0,
  VehiclePosition_OccupancyStatus_MANY_SEATS_AVAILABLE = 1,
  VehiclePosition_OccupancyStatus_FEW_SEATS_AVAILABLE = 2,
  VehiclePosition_OccupancyStatus_STANDING_ROOM_ONLY = 3,
  VehiclePosition_OccupancyStatus_CRUSHED_STANDING_ROOM_ONLY = 4,
  VehiclePosition_OccupancyStatus_FULL = 5,
  VehiclePosition_OccupancyStatus_NOT_ACCEPTING_PASSENGERS = 6,
  VehiclePosition_OccupancyStatus_NO_DATA_AVAILABLE = 7,
  VehiclePosition_OccupancyStatus_NOT_BOARDABLE = 8,
};

bool VehiclePosition_OccupancyStatus_IsValid(int value);
extern const uint32_t VehiclePosition_OccupancyStatus_internal_data_[];
constexpr VehiclePosition_OccupancyStatus VehiclePosition_OccupancyStatus_OccupancyStatus_MIN = static_cast<VehiclePosition_OccupancyStatus>(0);
constexpr VehiclePosition_OccupancyStatus VehiclePosition_OccupancyStatus_OccupancyStatus_MAX = static_cast<VehiclePosition_OccupancyStatus>(8);
constexpr int VehiclePosition_OccupancyStatus_OccupancyStatus_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor*
VehiclePosition_OccupancyStatus_descriptor();
template <typename T>
const std::string& VehiclePosition_OccupancyStatus_Name(T value) {
  static_assert(std::is_same<T, VehiclePosition_OccupancyStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to OccupancyStatus_Name().");
  return VehiclePosition_OccupancyStatus_Name(static_cast<VehiclePosition_OccupancyStatus>(value));
}
template <>
inline const std::string& VehiclePosition_OccupancyStatus_Name(VehiclePosition_OccupancyStatus value) {
  return ::google::protobuf::internal::NameOfDenseEnum<VehiclePosition_OccupancyStatus_descriptor,
                                                 0, 8>(
      static_cast<int>(value));
}
inline bool VehiclePosition_OccupancyStatus_Parse(absl::string_view name, VehiclePosition_OccupancyStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VehiclePosition_OccupancyStatus>(
      VehiclePosition_OccupancyStatus_descriptor(), name, value);
}
enum Alert_Cause : int {
  Alert_Cause_UNKNOWN_CAUSE = 1,
  Alert_Cause_OTHER_CAUSE = 2,
  Alert_Cause_TECHNICAL_PROBLEM = 3,
  Alert_Cause_STRIKE = 4,
  Alert_Cause_DEMONSTRATION = 5,
  Alert_Cause_ACCIDENT = 6,
  Alert_Cause_HOLIDAY = 7,
  Alert_Cause_WEATHER = 8,
  Alert_Cause_MAINTENANCE = 9,
  Alert_Cause_CONSTRUCTION = 10,
  Alert_Cause_POLICE_ACTIVITY = 11,
  Alert_Cause_MEDICAL_EMERGENCY = 12,
};

bool Alert_Cause_IsValid(int value);
extern const uint32_t Alert_Cause_internal_data_[];
constexpr Alert_Cause Alert_Cause_Cause_MIN = static_cast<Alert_Cause>(1);
constexpr Alert_Cause Alert_Cause_Cause_MAX = static_cast<Alert_Cause>(12);
constexpr int Alert_Cause_Cause_ARRAYSIZE = 12 + 1;
const ::google::protobuf::EnumDescriptor*
Alert_Cause_descriptor();
template <typename T>
const std::string& Alert_Cause_Name(T value) {
  static_assert(std::is_same<T, Alert_Cause>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Cause_Name().");
  return Alert_Cause_Name(static_cast<Alert_Cause>(value));
}
template <>
inline const std::string& Alert_Cause_Name(Alert_Cause value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Alert_Cause_descriptor,
                                                 1, 12>(
      static_cast<int>(value));
}
inline bool Alert_Cause_Parse(absl::string_view name, Alert_Cause* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Alert_Cause>(
      Alert_Cause_descriptor(), name, value);
}
enum Alert_Effect : int {
  Alert_Effect_NO_SERVICE = 1,
  Alert_Effect_REDUCED_SERVICE = 2,
  Alert_Effect_SIGNIFICANT_DELAYS = 3,
  Alert_Effect_DETOUR = 4,
  Alert_Effect_ADDITIONAL_SERVICE = 5,
  Alert_Effect_MODIFIED_SERVICE = 6,
  Alert_Effect_OTHER_EFFECT = 7,
  Alert_Effect_UNKNOWN_EFFECT = 8,
  Alert_Effect_STOP_MOVED = 9,
  Alert_Effect_NO_EFFECT = 10,
  Alert_Effect_ACCESSIBILITY_ISSUE = 11,
};

bool Alert_Effect_IsValid(int value);
extern const uint32_t Alert_Effect_internal_data_[];
constexpr Alert_Effect Alert_Effect_Effect_MIN = static_cast<Alert_Effect>(1);
constexpr Alert_Effect Alert_Effect_Effect_MAX = static_cast<Alert_Effect>(11);
constexpr int Alert_Effect_Effect_ARRAYSIZE = 11 + 1;
const ::google::protobuf::EnumDescriptor*
Alert_Effect_descriptor();
template <typename T>
const std::string& Alert_Effect_Name(T value) {
  static_assert(std::is_same<T, Alert_Effect>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Effect_Name().");
  return Alert_Effect_Name(static_cast<Alert_Effect>(value));
}
template <>
inline const std::string& Alert_Effect_Name(Alert_Effect value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Alert_Effect_descriptor,
                                                 1, 11>(
      static_cast<int>(value));
}
inline bool Alert_Effect_Parse(absl::string_view name, Alert_Effect* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Alert_Effect>(
      Alert_Effect_descriptor(), name, value);
}
enum Alert_SeverityLevel : int {
  Alert_SeverityLevel_UNKNOWN_SEVERITY = 1,
  Alert_SeverityLevel_INFO = 2,
  Alert_SeverityLevel_WARNING = 3,
  Alert_SeverityLevel_SEVERE = 4,
};

bool Alert_SeverityLevel_IsValid(int value);
extern const uint32_t Alert_SeverityLevel_internal_data_[];
constexpr Alert_SeverityLevel Alert_SeverityLevel_SeverityLevel_MIN = static_cast<Alert_SeverityLevel>(1);
constexpr Alert_SeverityLevel Alert_SeverityLevel_SeverityLevel_MAX = static_cast<Alert_SeverityLevel>(4);
constexpr int Alert_SeverityLevel_SeverityLevel_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
Alert_SeverityLevel_descriptor();
template <typename T>
const std::string& Alert_SeverityLevel_Name(T value) {
  static_assert(std::is_same<T, Alert_SeverityLevel>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SeverityLevel_Name().");
  return Alert_SeverityLevel_Name(static_cast<Alert_SeverityLevel>(value));
}
template <>
inline const std::string& Alert_SeverityLevel_Name(Alert_SeverityLevel value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Alert_SeverityLevel_descriptor,
                                                 1, 4>(
      static_cast<int>(value));
}
inline bool Alert_SeverityLevel_Parse(absl::string_view name, Alert_SeverityLevel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Alert_SeverityLevel>(
      Alert_SeverityLevel_descriptor(), name, value);
}
enum TripDescriptor_ScheduleRelationship : int {
  TripDescriptor_ScheduleRelationship_SCHEDULED = 0,
  TripDescriptor_ScheduleRelationship_ADDED = 1,
  TripDescriptor_ScheduleRelationship_UNSCHEDULED = 2,
  TripDescriptor_ScheduleRelationship_CANCELED = 3,
  TripDescriptor_ScheduleRelationship_REPLACEMENT [[deprecated]] = 5,
  TripDescriptor_ScheduleRelationship_DUPLICATED = 6,
  TripDescriptor_ScheduleRelationship_DELETED = 7,
};

bool TripDescriptor_ScheduleRelationship_IsValid(int value);
extern const uint32_t TripDescriptor_ScheduleRelationship_internal_data_[];
constexpr TripDescriptor_ScheduleRelationship TripDescriptor_ScheduleRelationship_ScheduleRelationship_MIN = static_cast<TripDescriptor_ScheduleRelationship>(0);
constexpr TripDescriptor_ScheduleRelationship TripDescriptor_ScheduleRelationship_ScheduleRelationship_MAX = static_cast<TripDescriptor_ScheduleRelationship>(7);
constexpr int TripDescriptor_ScheduleRelationship_ScheduleRelationship_ARRAYSIZE = 7 + 1;
const ::google::protobuf::EnumDescriptor*
TripDescriptor_ScheduleRelationship_descriptor();
template <typename T>
const std::string& TripDescriptor_ScheduleRelationship_Name(T value) {
  static_assert(std::is_same<T, TripDescriptor_ScheduleRelationship>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ScheduleRelationship_Name().");
  return TripDescriptor_ScheduleRelationship_Name(static_cast<TripDescriptor_ScheduleRelationship>(value));
}
template <>
inline const std::string& TripDescriptor_ScheduleRelationship_Name(TripDescriptor_ScheduleRelationship value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TripDescriptor_ScheduleRelationship_descriptor,
                                                 0, 7>(
      static_cast<int>(value));
}
inline bool TripDescriptor_ScheduleRelationship_Parse(absl::string_view name, TripDescriptor_ScheduleRelationship* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TripDescriptor_ScheduleRelationship>(
      TripDescriptor_ScheduleRelationship_descriptor(), name, value);
}
enum VehicleDescriptor_WheelchairAccessible : int {
  VehicleDescriptor_WheelchairAccessible_NO_VALUE = 0,
  VehicleDescriptor_WheelchairAccessible_UNKNOWN = 1,
  VehicleDescriptor_WheelchairAccessible_WHEELCHAIR_ACCESSIBLE = 2,
  VehicleDescriptor_WheelchairAccessible_WHEELCHAIR_INACCESSIBLE = 3,
};

bool VehicleDescriptor_WheelchairAccessible_IsValid(int value);
extern const uint32_t VehicleDescriptor_WheelchairAccessible_internal_data_[];
constexpr VehicleDescriptor_WheelchairAccessible VehicleDescriptor_WheelchairAccessible_WheelchairAccessible_MIN = static_cast<VehicleDescriptor_WheelchairAccessible>(0);
constexpr VehicleDescriptor_WheelchairAccessible VehicleDescriptor_WheelchairAccessible_WheelchairAccessible_MAX = static_cast<VehicleDescriptor_WheelchairAccessible>(3);
constexpr int VehicleDescriptor_WheelchairAccessible_WheelchairAccessible_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
VehicleDescriptor_WheelchairAccessible_descriptor();
template <typename T>
const std::string& VehicleDescriptor_WheelchairAccessible_Name(T value) {
  static_assert(std::is_same<T, VehicleDescriptor_WheelchairAccessible>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to WheelchairAccessible_Name().");
  return VehicleDescriptor_WheelchairAccessible_Name(static_cast<VehicleDescriptor_WheelchairAccessible>(value));
}
template <>
inline const std::string& VehicleDescriptor_WheelchairAccessible_Name(VehicleDescriptor_WheelchairAccessible value) {
  return ::google::protobuf::internal::NameOfDenseEnum<VehicleDescriptor_WheelchairAccessible_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool VehicleDescriptor_WheelchairAccessible_Parse(absl::string_view name, VehicleDescriptor_WheelchairAccessible* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VehicleDescriptor_WheelchairAccessible>(
      VehicleDescriptor_WheelchairAccessible_descriptor(), name, value);
}
enum Stop_WheelchairBoarding : int {
  Stop_WheelchairBoarding_UNKNOWN = 0,
  Stop_WheelchairBoarding_AVAILABLE = 1,
  Stop_WheelchairBoarding_NOT_AVAILABLE = 2,
};

bool Stop_WheelchairBoarding_IsValid(int value);
extern const uint32_t Stop_WheelchairBoarding_internal_data_[];
constexpr Stop_WheelchairBoarding Stop_WheelchairBoarding_WheelchairBoarding_MIN = static_cast<Stop_WheelchairBoarding>(0);
constexpr Stop_WheelchairBoarding Stop_WheelchairBoarding_WheelchairBoarding_MAX = static_cast<Stop_WheelchairBoarding>(2);
constexpr int Stop_WheelchairBoarding_WheelchairBoarding_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
Stop_WheelchairBoarding_descriptor();
template <typename T>
const std::string& Stop_WheelchairBoarding_Name(T value) {
  static_assert(std::is_same<T, Stop_WheelchairBoarding>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to WheelchairBoarding_Name().");
  return Stop_WheelchairBoarding_Name(static_cast<Stop_WheelchairBoarding>(value));
}
template <>
inline const std::string& Stop_WheelchairBoarding_Name(Stop_WheelchairBoarding value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Stop_WheelchairBoarding_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool Stop_WheelchairBoarding_Parse(absl::string_view name, Stop_WheelchairBoarding* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Stop_WheelchairBoarding>(
      Stop_WheelchairBoarding_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class VehiclePosition_CarriageDetails final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:transit_realtime.VehiclePosition.CarriageDetails) */ {
 public:
  inline VehiclePosition_CarriageDetails() : VehiclePosition_CarriageDetails(nullptr) {}
  ~VehiclePosition_CarriageDetails() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(VehiclePosition_CarriageDetails* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(VehiclePosition_CarriageDetails));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR VehiclePosition_CarriageDetails(
      ::google::protobuf::internal::ConstantInitialized);

  inline VehiclePosition_CarriageDetails(const VehiclePosition_CarriageDetails& from) : VehiclePosition_CarriageDetails(nullptr, from) {}
  inline VehiclePosition_CarriageDetails(VehiclePosition_CarriageDetails&& from) noexcept
      : VehiclePosition_CarriageDetails(nullptr, std::move(from)) {}
  inline VehiclePosition_CarriageDetails& operator=(const VehiclePosition_CarriageDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline VehiclePosition_CarriageDetails& operator=(VehiclePosition_CarriageDetails&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VehiclePosition_CarriageDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const VehiclePosition_CarriageDetails* internal_default_instance() {
    return reinterpret_cast<const VehiclePosition_CarriageDetails*>(
        &_VehiclePosition_CarriageDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(VehiclePosition_CarriageDetails& a, VehiclePosition_CarriageDetails& b) { a.Swap(&b); }
  inline void Swap(VehiclePosition_CarriageDetails* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VehiclePosition_CarriageDetails* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VehiclePosition_CarriageDetails* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<VehiclePosition_CarriageDetails>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VehiclePosition_CarriageDetails& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const VehiclePosition_CarriageDetails& from) { VehiclePosition_CarriageDetails::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(VehiclePosition_CarriageDetails* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "transit_realtime.VehiclePosition.CarriageDetails"; }

 protected:
  explicit VehiclePosition_CarriageDetails(::google::protobuf::Arena* arena);
  VehiclePosition_CarriageDetails(::google::protobuf::Arena* arena, const VehiclePosition_CarriageDetails& from);
  VehiclePosition_CarriageDetails(::google::protobuf::Arena* arena, VehiclePosition_CarriageDetails&& from) noexcept
      : VehiclePosition_CarriageDetails(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kLabelFieldNumber = 2,
    kCarriageSequenceFieldNumber = 5,
    kOccupancyStatusFieldNumber = 3,
    kOccupancyPercentageFieldNumber = 4,
  };
  // optional string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional string label = 2;
  bool has_label() const;
  void clear_label() ;
  const std::string& label() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_label(Arg_&& arg, Args_... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* value);

  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(
      const std::string& value);
  std::string* _internal_mutable_label();

  public:
  // optional uint32 carriage_sequence = 5;
  bool has_carriage_sequence() const;
  void clear_carriage_sequence() ;
  ::uint32_t carriage_sequence() const;
  void set_carriage_sequence(::uint32_t value);

  private:
  ::uint32_t _internal_carriage_sequence() const;
  void _internal_set_carriage_sequence(::uint32_t value);

  public:
  // optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 3 [default = NO_DATA_AVAILABLE];
  bool has_occupancy_status() const;
  void clear_occupancy_status() ;
  ::transit_realtime::VehiclePosition_OccupancyStatus occupancy_status() const;
  void set_occupancy_status(::transit_realtime::VehiclePosition_OccupancyStatus value);

  private:
  ::transit_realtime::VehiclePosition_OccupancyStatus _internal_occupancy_status() const;
  void _internal_set_occupancy_status(::transit_realtime::VehiclePosition_OccupancyStatus value);

  public:
  // optional int32 occupancy_percentage = 4 [default = -1];
  bool has_occupancy_percentage() const;
  void clear_occupancy_percentage() ;
  ::int32_t occupancy_percentage() const;
  void set_occupancy_percentage(::int32_t value);

  private:
  ::int32_t _internal_occupancy_percentage() const;
  void _internal_set_occupancy_percentage(::int32_t value);

  public:
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehiclePosition_CarriageDetails, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehiclePosition_CarriageDetails, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<VehiclePosition_CarriageDetails, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehiclePosition_CarriageDetails, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehiclePosition_CarriageDetails, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehiclePosition_CarriageDetails, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehiclePosition_CarriageDetails, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehiclePosition_CarriageDetails, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehiclePosition_CarriageDetails, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<VehiclePosition_CarriageDetails, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehiclePosition_CarriageDetails, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehiclePosition_CarriageDetails, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehiclePosition_CarriageDetails, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehiclePosition_CarriageDetails, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehiclePosition_CarriageDetails, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehiclePosition_CarriageDetails, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehiclePosition_CarriageDetails, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehiclePosition_CarriageDetails, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehiclePosition_CarriageDetails, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:transit_realtime.VehiclePosition.CarriageDetails)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      64, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const VehiclePosition_CarriageDetails& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr label_;
    ::uint32_t carriage_sequence_;
    int occupancy_status_;
    ::int32_t occupancy_percentage_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class VehicleDescriptor final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:transit_realtime.VehicleDescriptor) */ {
 public:
  inline VehicleDescriptor() : VehicleDescriptor(nullptr) {}
  ~VehicleDescriptor() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(VehicleDescriptor* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(VehicleDescriptor));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR VehicleDescriptor(
      ::google::protobuf::internal::ConstantInitialized);

  inline VehicleDescriptor(const VehicleDescriptor& from) : VehicleDescriptor(nullptr, from) {}
  inline VehicleDescriptor(VehicleDescriptor&& from) noexcept
      : VehicleDescriptor(nullptr, std::move(from)) {}
  inline VehicleDescriptor& operator=(const VehicleDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline VehicleDescriptor& operator=(VehicleDescriptor&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VehicleDescriptor& default_instance() {
    return *internal_default_instance();
  }
  static inline const VehicleDescriptor* internal_default_instance() {
    return reinterpret_cast<const VehicleDescriptor*>(
        &_VehicleDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(VehicleDescriptor& a, VehicleDescriptor& b) { a.Swap(&b); }
  inline void Swap(VehicleDescriptor* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VehicleDescriptor* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VehicleDescriptor* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<VehicleDescriptor>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VehicleDescriptor& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const VehicleDescriptor& from) { VehicleDescriptor::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(VehicleDescriptor* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "transit_realtime.VehicleDescriptor"; }

 protected:
  explicit VehicleDescriptor(::google::protobuf::Arena* arena);
  VehicleDescriptor(::google::protobuf::Arena* arena, const VehicleDescriptor& from);
  VehicleDescriptor(::google::protobuf::Arena* arena, VehicleDescriptor&& from) noexcept
      : VehicleDescriptor(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using WheelchairAccessible = VehicleDescriptor_WheelchairAccessible;
  static constexpr WheelchairAccessible NO_VALUE = VehicleDescriptor_WheelchairAccessible_NO_VALUE;
  static constexpr WheelchairAccessible UNKNOWN = VehicleDescriptor_WheelchairAccessible_UNKNOWN;
  static constexpr WheelchairAccessible WHEELCHAIR_ACCESSIBLE = VehicleDescriptor_WheelchairAccessible_WHEELCHAIR_ACCESSIBLE;
  static constexpr WheelchairAccessible WHEELCHAIR_INACCESSIBLE = VehicleDescriptor_WheelchairAccessible_WHEELCHAIR_INACCESSIBLE;
  static inline bool WheelchairAccessible_IsValid(int value) {
    return VehicleDescriptor_WheelchairAccessible_IsValid(value);
  }
  static constexpr WheelchairAccessible WheelchairAccessible_MIN = VehicleDescriptor_WheelchairAccessible_WheelchairAccessible_MIN;
  static constexpr WheelchairAccessible WheelchairAccessible_MAX = VehicleDescriptor_WheelchairAccessible_WheelchairAccessible_MAX;
  static constexpr int WheelchairAccessible_ARRAYSIZE = VehicleDescriptor_WheelchairAccessible_WheelchairAccessible_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* WheelchairAccessible_descriptor() {
    return VehicleDescriptor_WheelchairAccessible_descriptor();
  }
  template <typename T>
  static inline const std::string& WheelchairAccessible_Name(T value) {
    return VehicleDescriptor_WheelchairAccessible_Name(value);
  }
  static inline bool WheelchairAccessible_Parse(absl::string_view name, WheelchairAccessible* value) {
    return VehicleDescriptor_WheelchairAccessible_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kLabelFieldNumber = 2,
    kLicensePlateFieldNumber = 3,
    kWheelchairAccessibleFieldNumber = 4,
  };
  // optional string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional string label = 2;
  bool has_label() const;
  void clear_label() ;
  const std::string& label() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_label(Arg_&& arg, Args_... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* value);

  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(
      const std::string& value);
  std::string* _internal_mutable_label();

  public:
  // optional string license_plate = 3;
  bool has_license_plate() const;
  void clear_license_plate() ;
  const std::string& license_plate() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_license_plate(Arg_&& arg, Args_... args);
  std::string* mutable_license_plate();
  PROTOBUF_NODISCARD std::string* release_license_plate();
  void set_allocated_license_plate(std::string* value);

  private:
  const std::string& _internal_license_plate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_license_plate(
      const std::string& value);
  std::string* _internal_mutable_license_plate();

  public:
  // optional .transit_realtime.VehicleDescriptor.WheelchairAccessible wheelchair_accessible = 4 [default = NO_VALUE];
  bool has_wheelchair_accessible() const;
  void clear_wheelchair_accessible() ;
  ::transit_realtime::VehicleDescriptor_WheelchairAccessible wheelchair_accessible() const;
  void set_wheelchair_accessible(::transit_realtime::VehicleDescriptor_WheelchairAccessible value);

  private:
  ::transit_realtime::VehicleDescriptor_WheelchairAccessible _internal_wheelchair_accessible() const;
  void _internal_set_wheelchair_accessible(::transit_realtime::VehicleDescriptor_WheelchairAccessible value);

  public:
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehicleDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehicleDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<VehicleDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehicleDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehicleDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehicleDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehicleDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehicleDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehicleDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<VehicleDescriptor, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehicleDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehicleDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehicleDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehicleDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehicleDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehicleDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehicleDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehicleDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehicleDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:transit_realtime.VehicleDescriptor)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      63, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const VehicleDescriptor& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr label_;
    ::google::protobuf::internal::ArenaStringPtr license_plate_;
    int wheelchair_accessible_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class TripUpdate_TripProperties final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:transit_realtime.TripUpdate.TripProperties) */ {
 public:
  inline TripUpdate_TripProperties() : TripUpdate_TripProperties(nullptr) {}
  ~TripUpdate_TripProperties() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TripUpdate_TripProperties* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TripUpdate_TripProperties));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TripUpdate_TripProperties(
      ::google::protobuf::internal::ConstantInitialized);

  inline TripUpdate_TripProperties(const TripUpdate_TripProperties& from) : TripUpdate_TripProperties(nullptr, from) {}
  inline TripUpdate_TripProperties(TripUpdate_TripProperties&& from) noexcept
      : TripUpdate_TripProperties(nullptr, std::move(from)) {}
  inline TripUpdate_TripProperties& operator=(const TripUpdate_TripProperties& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripUpdate_TripProperties& operator=(TripUpdate_TripProperties&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TripUpdate_TripProperties& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripUpdate_TripProperties* internal_default_instance() {
    return reinterpret_cast<const TripUpdate_TripProperties*>(
        &_TripUpdate_TripProperties_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(TripUpdate_TripProperties& a, TripUpdate_TripProperties& b) { a.Swap(&b); }
  inline void Swap(TripUpdate_TripProperties* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripUpdate_TripProperties* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripUpdate_TripProperties* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TripUpdate_TripProperties>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TripUpdate_TripProperties& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TripUpdate_TripProperties& from) { TripUpdate_TripProperties::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TripUpdate_TripProperties* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "transit_realtime.TripUpdate.TripProperties"; }

 protected:
  explicit TripUpdate_TripProperties(::google::protobuf::Arena* arena);
  TripUpdate_TripProperties(::google::protobuf::Arena* arena, const TripUpdate_TripProperties& from);
  TripUpdate_TripProperties(::google::protobuf::Arena* arena, TripUpdate_TripProperties&& from) noexcept
      : TripUpdate_TripProperties(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTripIdFieldNumber = 1,
    kStartDateFieldNumber = 2,
    kStartTimeFieldNumber = 3,
    kShapeIdFieldNumber = 4,
  };
  // optional string trip_id = 1;
  bool has_trip_id() const;
  void clear_trip_id() ;
  const std::string& trip_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_trip_id(Arg_&& arg, Args_... args);
  std::string* mutable_trip_id();
  PROTOBUF_NODISCARD std::string* release_trip_id();
  void set_allocated_trip_id(std::string* value);

  private:
  const std::string& _internal_trip_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trip_id(
      const std::string& value);
  std::string* _internal_mutable_trip_id();

  public:
  // optional string start_date = 2;
  bool has_start_date() const;
  void clear_start_date() ;
  const std::string& start_date() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_start_date(Arg_&& arg, Args_... args);
  std::string* mutable_start_date();
  PROTOBUF_NODISCARD std::string* release_start_date();
  void set_allocated_start_date(std::string* value);

  private:
  const std::string& _internal_start_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_start_date(
      const std::string& value);
  std::string* _internal_mutable_start_date();

  public:
  // optional string start_time = 3;
  bool has_start_time() const;
  void clear_start_time() ;
  const std::string& start_time() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_start_time(Arg_&& arg, Args_... args);
  std::string* mutable_start_time();
  PROTOBUF_NODISCARD std::string* release_start_time();
  void set_allocated_start_time(std::string* value);

  private:
  const std::string& _internal_start_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_start_time(
      const std::string& value);
  std::string* _internal_mutable_start_time();

  public:
  // optional string shape_id = 4;
  bool has_shape_id() const;
  void clear_shape_id() ;
  const std::string& shape_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_shape_id(Arg_&& arg, Args_... args);
  std::string* mutable_shape_id();
  PROTOBUF_NODISCARD std::string* release_shape_id();
  void set_allocated_shape_id(std::string* value);

  private:
  const std::string& _internal_shape_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shape_id(
      const std::string& value);
  std::string* _internal_mutable_shape_id();

  public:
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_TripProperties, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_TripProperties, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_TripProperties, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_TripProperties, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_TripProperties, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_TripProperties, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_TripProperties, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_TripProperties, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_TripProperties, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_TripProperties, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_TripProperties, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_TripProperties, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_TripProperties, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_TripProperties, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_TripProperties, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_TripProperties, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_TripProperties, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_TripProperties, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_TripProperties, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:transit_realtime.TripUpdate.TripProperties)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      86, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TripUpdate_TripProperties& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr trip_id_;
    ::google::protobuf::internal::ArenaStringPtr start_date_;
    ::google::protobuf::internal::ArenaStringPtr start_time_;
    ::google::protobuf::internal::ArenaStringPtr shape_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class TripUpdate_StopTimeUpdate_StopTimeProperties final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties) */ {
 public:
  inline TripUpdate_StopTimeUpdate_StopTimeProperties() : TripUpdate_StopTimeUpdate_StopTimeProperties(nullptr) {}
  ~TripUpdate_StopTimeUpdate_StopTimeProperties() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TripUpdate_StopTimeUpdate_StopTimeProperties* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TripUpdate_StopTimeUpdate_StopTimeProperties));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TripUpdate_StopTimeUpdate_StopTimeProperties(
      ::google::protobuf::internal::ConstantInitialized);

  inline TripUpdate_StopTimeUpdate_StopTimeProperties(const TripUpdate_StopTimeUpdate_StopTimeProperties& from) : TripUpdate_StopTimeUpdate_StopTimeProperties(nullptr, from) {}
  inline TripUpdate_StopTimeUpdate_StopTimeProperties(TripUpdate_StopTimeUpdate_StopTimeProperties&& from) noexcept
      : TripUpdate_StopTimeUpdate_StopTimeProperties(nullptr, std::move(from)) {}
  inline TripUpdate_StopTimeUpdate_StopTimeProperties& operator=(const TripUpdate_StopTimeUpdate_StopTimeProperties& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripUpdate_StopTimeUpdate_StopTimeProperties& operator=(TripUpdate_StopTimeUpdate_StopTimeProperties&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TripUpdate_StopTimeUpdate_StopTimeProperties& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripUpdate_StopTimeUpdate_StopTimeProperties* internal_default_instance() {
    return reinterpret_cast<const TripUpdate_StopTimeUpdate_StopTimeProperties*>(
        &_TripUpdate_StopTimeUpdate_StopTimeProperties_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(TripUpdate_StopTimeUpdate_StopTimeProperties& a, TripUpdate_StopTimeUpdate_StopTimeProperties& b) { a.Swap(&b); }
  inline void Swap(TripUpdate_StopTimeUpdate_StopTimeProperties* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripUpdate_StopTimeUpdate_StopTimeProperties* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripUpdate_StopTimeUpdate_StopTimeProperties* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TripUpdate_StopTimeUpdate_StopTimeProperties>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TripUpdate_StopTimeUpdate_StopTimeProperties& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TripUpdate_StopTimeUpdate_StopTimeProperties& from) { TripUpdate_StopTimeUpdate_StopTimeProperties::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TripUpdate_StopTimeUpdate_StopTimeProperties* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties"; }

 protected:
  explicit TripUpdate_StopTimeUpdate_StopTimeProperties(::google::protobuf::Arena* arena);
  TripUpdate_StopTimeUpdate_StopTimeProperties(::google::protobuf::Arena* arena, const TripUpdate_StopTimeUpdate_StopTimeProperties& from);
  TripUpdate_StopTimeUpdate_StopTimeProperties(::google::protobuf::Arena* arena, TripUpdate_StopTimeUpdate_StopTimeProperties&& from) noexcept
      : TripUpdate_StopTimeUpdate_StopTimeProperties(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAssignedStopIdFieldNumber = 1,
  };
  // optional string assigned_stop_id = 1;
  bool has_assigned_stop_id() const;
  void clear_assigned_stop_id() ;
  const std::string& assigned_stop_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_assigned_stop_id(Arg_&& arg, Args_... args);
  std::string* mutable_assigned_stop_id();
  PROTOBUF_NODISCARD std::string* release_assigned_stop_id();
  void set_allocated_assigned_stop_id(std::string* value);

  private:
  const std::string& _internal_assigned_stop_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_assigned_stop_id(
      const std::string& value);
  std::string* _internal_mutable_assigned_stop_id();

  public:
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate_StopTimeProperties, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate_StopTimeProperties, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate_StopTimeProperties, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate_StopTimeProperties, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate_StopTimeProperties, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate_StopTimeProperties, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate_StopTimeProperties, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate_StopTimeProperties, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate_StopTimeProperties, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate_StopTimeProperties, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate_StopTimeProperties, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate_StopTimeProperties, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate_StopTimeProperties, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate_StopTimeProperties, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate_StopTimeProperties, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate_StopTimeProperties, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate_StopTimeProperties, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate_StopTimeProperties, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate_StopTimeProperties, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      86, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TripUpdate_StopTimeUpdate_StopTimeProperties& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr assigned_stop_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class TripUpdate_StopTimeEvent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:transit_realtime.TripUpdate.StopTimeEvent) */ {
 public:
  inline TripUpdate_StopTimeEvent() : TripUpdate_StopTimeEvent(nullptr) {}
  ~TripUpdate_StopTimeEvent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TripUpdate_StopTimeEvent* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TripUpdate_StopTimeEvent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TripUpdate_StopTimeEvent(
      ::google::protobuf::internal::ConstantInitialized);

  inline TripUpdate_StopTimeEvent(const TripUpdate_StopTimeEvent& from) : TripUpdate_StopTimeEvent(nullptr, from) {}
  inline TripUpdate_StopTimeEvent(TripUpdate_StopTimeEvent&& from) noexcept
      : TripUpdate_StopTimeEvent(nullptr, std::move(from)) {}
  inline TripUpdate_StopTimeEvent& operator=(const TripUpdate_StopTimeEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripUpdate_StopTimeEvent& operator=(TripUpdate_StopTimeEvent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TripUpdate_StopTimeEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripUpdate_StopTimeEvent* internal_default_instance() {
    return reinterpret_cast<const TripUpdate_StopTimeEvent*>(
        &_TripUpdate_StopTimeEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(TripUpdate_StopTimeEvent& a, TripUpdate_StopTimeEvent& b) { a.Swap(&b); }
  inline void Swap(TripUpdate_StopTimeEvent* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripUpdate_StopTimeEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripUpdate_StopTimeEvent* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TripUpdate_StopTimeEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TripUpdate_StopTimeEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TripUpdate_StopTimeEvent& from) { TripUpdate_StopTimeEvent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TripUpdate_StopTimeEvent* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "transit_realtime.TripUpdate.StopTimeEvent"; }

 protected:
  explicit TripUpdate_StopTimeEvent(::google::protobuf::Arena* arena);
  TripUpdate_StopTimeEvent(::google::protobuf::Arena* arena, const TripUpdate_StopTimeEvent& from);
  TripUpdate_StopTimeEvent(::google::protobuf::Arena* arena, TripUpdate_StopTimeEvent&& from) noexcept
      : TripUpdate_StopTimeEvent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTimeFieldNumber = 2,
    kDelayFieldNumber = 1,
    kUncertaintyFieldNumber = 3,
  };
  // optional int64 time = 2;
  bool has_time() const;
  void clear_time() ;
  ::int64_t time() const;
  void set_time(::int64_t value);

  private:
  ::int64_t _internal_time() const;
  void _internal_set_time(::int64_t value);

  public:
  // optional int32 delay = 1;
  bool has_delay() const;
  void clear_delay() ;
  ::int32_t delay() const;
  void set_delay(::int32_t value);

  private:
  ::int32_t _internal_delay() const;
  void _internal_set_delay(::int32_t value);

  public:
  // optional int32 uncertainty = 3;
  bool has_uncertainty() const;
  void clear_uncertainty() ;
  ::int32_t uncertainty() const;
  void set_uncertainty(::int32_t value);

  private:
  ::int32_t _internal_uncertainty() const;
  void _internal_set_uncertainty(::int32_t value);

  public:
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeEvent, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeEvent, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeEvent, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeEvent, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeEvent, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeEvent, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeEvent, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeEvent, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeEvent, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeEvent, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeEvent, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeEvent, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeEvent, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeEvent, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeEvent, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeEvent, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeEvent, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeEvent, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeEvent, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:transit_realtime.TripUpdate.StopTimeEvent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TripUpdate_StopTimeEvent& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t time_;
    ::int32_t delay_;
    ::int32_t uncertainty_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class TripModifications_SelectedTrips final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:transit_realtime.TripModifications.SelectedTrips) */ {
 public:
  inline TripModifications_SelectedTrips() : TripModifications_SelectedTrips(nullptr) {}
  ~TripModifications_SelectedTrips() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TripModifications_SelectedTrips* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TripModifications_SelectedTrips));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TripModifications_SelectedTrips(
      ::google::protobuf::internal::ConstantInitialized);

  inline TripModifications_SelectedTrips(const TripModifications_SelectedTrips& from) : TripModifications_SelectedTrips(nullptr, from) {}
  inline TripModifications_SelectedTrips(TripModifications_SelectedTrips&& from) noexcept
      : TripModifications_SelectedTrips(nullptr, std::move(from)) {}
  inline TripModifications_SelectedTrips& operator=(const TripModifications_SelectedTrips& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripModifications_SelectedTrips& operator=(TripModifications_SelectedTrips&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TripModifications_SelectedTrips& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripModifications_SelectedTrips* internal_default_instance() {
    return reinterpret_cast<const TripModifications_SelectedTrips*>(
        &_TripModifications_SelectedTrips_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(TripModifications_SelectedTrips& a, TripModifications_SelectedTrips& b) { a.Swap(&b); }
  inline void Swap(TripModifications_SelectedTrips* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripModifications_SelectedTrips* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripModifications_SelectedTrips* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TripModifications_SelectedTrips>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TripModifications_SelectedTrips& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TripModifications_SelectedTrips& from) { TripModifications_SelectedTrips::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TripModifications_SelectedTrips* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "transit_realtime.TripModifications.SelectedTrips"; }

 protected:
  explicit TripModifications_SelectedTrips(::google::protobuf::Arena* arena);
  TripModifications_SelectedTrips(::google::protobuf::Arena* arena, const TripModifications_SelectedTrips& from);
  TripModifications_SelectedTrips(::google::protobuf::Arena* arena, TripModifications_SelectedTrips&& from) noexcept
      : TripModifications_SelectedTrips(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTripIdsFieldNumber = 1,
    kShapeIdFieldNumber = 2,
  };
  // repeated string trip_ids = 1;
  int trip_ids_size() const;
  private:
  int _internal_trip_ids_size() const;

  public:
  void clear_trip_ids() ;
  const std::string& trip_ids(int index) const;
  std::string* mutable_trip_ids(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_trip_ids(int index, Arg_&& value, Args_... args);
  std::string* add_trip_ids();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_trip_ids(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& trip_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_trip_ids();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_trip_ids() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_trip_ids();

  public:
  // optional string shape_id = 2;
  bool has_shape_id() const;
  void clear_shape_id() ;
  const std::string& shape_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_shape_id(Arg_&& arg, Args_... args);
  std::string* mutable_shape_id();
  PROTOBUF_NODISCARD std::string* release_shape_id();
  void set_allocated_shape_id(std::string* value);

  private:
  const std::string& _internal_shape_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shape_id(
      const std::string& value);
  std::string* _internal_mutable_shape_id();

  public:
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications_SelectedTrips, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications_SelectedTrips, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications_SelectedTrips, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications_SelectedTrips, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications_SelectedTrips, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications_SelectedTrips, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications_SelectedTrips, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications_SelectedTrips, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications_SelectedTrips, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<TripModifications_SelectedTrips, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications_SelectedTrips, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications_SelectedTrips, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications_SelectedTrips, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications_SelectedTrips, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications_SelectedTrips, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications_SelectedTrips, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications_SelectedTrips, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications_SelectedTrips, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications_SelectedTrips, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:transit_realtime.TripModifications.SelectedTrips)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      73, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TripModifications_SelectedTrips& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> trip_ids_;
    ::google::protobuf::internal::ArenaStringPtr shape_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class TripDescriptor_ModifiedTripSelector final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:transit_realtime.TripDescriptor.ModifiedTripSelector) */ {
 public:
  inline TripDescriptor_ModifiedTripSelector() : TripDescriptor_ModifiedTripSelector(nullptr) {}
  ~TripDescriptor_ModifiedTripSelector() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TripDescriptor_ModifiedTripSelector* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TripDescriptor_ModifiedTripSelector));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TripDescriptor_ModifiedTripSelector(
      ::google::protobuf::internal::ConstantInitialized);

  inline TripDescriptor_ModifiedTripSelector(const TripDescriptor_ModifiedTripSelector& from) : TripDescriptor_ModifiedTripSelector(nullptr, from) {}
  inline TripDescriptor_ModifiedTripSelector(TripDescriptor_ModifiedTripSelector&& from) noexcept
      : TripDescriptor_ModifiedTripSelector(nullptr, std::move(from)) {}
  inline TripDescriptor_ModifiedTripSelector& operator=(const TripDescriptor_ModifiedTripSelector& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripDescriptor_ModifiedTripSelector& operator=(TripDescriptor_ModifiedTripSelector&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TripDescriptor_ModifiedTripSelector& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripDescriptor_ModifiedTripSelector* internal_default_instance() {
    return reinterpret_cast<const TripDescriptor_ModifiedTripSelector*>(
        &_TripDescriptor_ModifiedTripSelector_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(TripDescriptor_ModifiedTripSelector& a, TripDescriptor_ModifiedTripSelector& b) { a.Swap(&b); }
  inline void Swap(TripDescriptor_ModifiedTripSelector* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripDescriptor_ModifiedTripSelector* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripDescriptor_ModifiedTripSelector* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TripDescriptor_ModifiedTripSelector>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TripDescriptor_ModifiedTripSelector& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TripDescriptor_ModifiedTripSelector& from) { TripDescriptor_ModifiedTripSelector::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TripDescriptor_ModifiedTripSelector* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "transit_realtime.TripDescriptor.ModifiedTripSelector"; }

 protected:
  explicit TripDescriptor_ModifiedTripSelector(::google::protobuf::Arena* arena);
  TripDescriptor_ModifiedTripSelector(::google::protobuf::Arena* arena, const TripDescriptor_ModifiedTripSelector& from);
  TripDescriptor_ModifiedTripSelector(::google::protobuf::Arena* arena, TripDescriptor_ModifiedTripSelector&& from) noexcept
      : TripDescriptor_ModifiedTripSelector(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kModificationsIdFieldNumber = 1,
    kAffectedTripIdFieldNumber = 2,
    kStartTimeFieldNumber = 3,
    kStartDateFieldNumber = 4,
  };
  // optional string modifications_id = 1;
  bool has_modifications_id() const;
  void clear_modifications_id() ;
  const std::string& modifications_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_modifications_id(Arg_&& arg, Args_... args);
  std::string* mutable_modifications_id();
  PROTOBUF_NODISCARD std::string* release_modifications_id();
  void set_allocated_modifications_id(std::string* value);

  private:
  const std::string& _internal_modifications_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modifications_id(
      const std::string& value);
  std::string* _internal_mutable_modifications_id();

  public:
  // optional string affected_trip_id = 2;
  bool has_affected_trip_id() const;
  void clear_affected_trip_id() ;
  const std::string& affected_trip_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_affected_trip_id(Arg_&& arg, Args_... args);
  std::string* mutable_affected_trip_id();
  PROTOBUF_NODISCARD std::string* release_affected_trip_id();
  void set_allocated_affected_trip_id(std::string* value);

  private:
  const std::string& _internal_affected_trip_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_affected_trip_id(
      const std::string& value);
  std::string* _internal_mutable_affected_trip_id();

  public:
  // optional string start_time = 3;
  bool has_start_time() const;
  void clear_start_time() ;
  const std::string& start_time() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_start_time(Arg_&& arg, Args_... args);
  std::string* mutable_start_time();
  PROTOBUF_NODISCARD std::string* release_start_time();
  void set_allocated_start_time(std::string* value);

  private:
  const std::string& _internal_start_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_start_time(
      const std::string& value);
  std::string* _internal_mutable_start_time();

  public:
  // optional string start_date = 4;
  bool has_start_date() const;
  void clear_start_date() ;
  const std::string& start_date() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_start_date(Arg_&& arg, Args_... args);
  std::string* mutable_start_date();
  PROTOBUF_NODISCARD std::string* release_start_date();
  void set_allocated_start_date(std::string* value);

  private:
  const std::string& _internal_start_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_start_date(
      const std::string& value);
  std::string* _internal_mutable_start_date();

  public:
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripDescriptor_ModifiedTripSelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripDescriptor_ModifiedTripSelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<TripDescriptor_ModifiedTripSelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripDescriptor_ModifiedTripSelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripDescriptor_ModifiedTripSelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripDescriptor_ModifiedTripSelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripDescriptor_ModifiedTripSelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripDescriptor_ModifiedTripSelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripDescriptor_ModifiedTripSelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<TripDescriptor_ModifiedTripSelector, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripDescriptor_ModifiedTripSelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripDescriptor_ModifiedTripSelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripDescriptor_ModifiedTripSelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripDescriptor_ModifiedTripSelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripDescriptor_ModifiedTripSelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripDescriptor_ModifiedTripSelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripDescriptor_ModifiedTripSelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripDescriptor_ModifiedTripSelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripDescriptor_ModifiedTripSelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:transit_realtime.TripDescriptor.ModifiedTripSelector)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      113, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TripDescriptor_ModifiedTripSelector& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr modifications_id_;
    ::google::protobuf::internal::ArenaStringPtr affected_trip_id_;
    ::google::protobuf::internal::ArenaStringPtr start_time_;
    ::google::protobuf::internal::ArenaStringPtr start_date_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class TranslatedString_Translation final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:transit_realtime.TranslatedString.Translation) */ {
 public:
  inline TranslatedString_Translation() : TranslatedString_Translation(nullptr) {}
  ~TranslatedString_Translation() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TranslatedString_Translation* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TranslatedString_Translation));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TranslatedString_Translation(
      ::google::protobuf::internal::ConstantInitialized);

  inline TranslatedString_Translation(const TranslatedString_Translation& from) : TranslatedString_Translation(nullptr, from) {}
  inline TranslatedString_Translation(TranslatedString_Translation&& from) noexcept
      : TranslatedString_Translation(nullptr, std::move(from)) {}
  inline TranslatedString_Translation& operator=(const TranslatedString_Translation& from) {
    CopyFrom(from);
    return *this;
  }
  inline TranslatedString_Translation& operator=(TranslatedString_Translation&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TranslatedString_Translation& default_instance() {
    return *internal_default_instance();
  }
  static inline const TranslatedString_Translation* internal_default_instance() {
    return reinterpret_cast<const TranslatedString_Translation*>(
        &_TranslatedString_Translation_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(TranslatedString_Translation& a, TranslatedString_Translation& b) { a.Swap(&b); }
  inline void Swap(TranslatedString_Translation* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TranslatedString_Translation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TranslatedString_Translation* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TranslatedString_Translation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TranslatedString_Translation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TranslatedString_Translation& from) { TranslatedString_Translation::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TranslatedString_Translation* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "transit_realtime.TranslatedString.Translation"; }

 protected:
  explicit TranslatedString_Translation(::google::protobuf::Arena* arena);
  TranslatedString_Translation(::google::protobuf::Arena* arena, const TranslatedString_Translation& from);
  TranslatedString_Translation(::google::protobuf::Arena* arena, TranslatedString_Translation&& from) noexcept
      : TranslatedString_Translation(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTextFieldNumber = 1,
    kLanguageFieldNumber = 2,
  };
  // required string text = 1;
  bool has_text() const;
  void clear_text() ;
  const std::string& text() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_text(Arg_&& arg, Args_... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* value);

  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(
      const std::string& value);
  std::string* _internal_mutable_text();

  public:
  // optional string language = 2;
  bool has_language() const;
  void clear_language() ;
  const std::string& language() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_language(Arg_&& arg, Args_... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* value);

  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(
      const std::string& value);
  std::string* _internal_mutable_language();

  public:
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedString_Translation, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedString_Translation, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedString_Translation, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedString_Translation, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedString_Translation, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedString_Translation, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedString_Translation, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedString_Translation, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedString_Translation, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<TranslatedString_Translation, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedString_Translation, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedString_Translation, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedString_Translation, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedString_Translation, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedString_Translation, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedString_Translation, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedString_Translation, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedString_Translation, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedString_Translation, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:transit_realtime.TranslatedString.Translation)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      66, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TranslatedString_Translation& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr text_;
    ::google::protobuf::internal::ArenaStringPtr language_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class TranslatedImage_LocalizedImage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:transit_realtime.TranslatedImage.LocalizedImage) */ {
 public:
  inline TranslatedImage_LocalizedImage() : TranslatedImage_LocalizedImage(nullptr) {}
  ~TranslatedImage_LocalizedImage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TranslatedImage_LocalizedImage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TranslatedImage_LocalizedImage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TranslatedImage_LocalizedImage(
      ::google::protobuf::internal::ConstantInitialized);

  inline TranslatedImage_LocalizedImage(const TranslatedImage_LocalizedImage& from) : TranslatedImage_LocalizedImage(nullptr, from) {}
  inline TranslatedImage_LocalizedImage(TranslatedImage_LocalizedImage&& from) noexcept
      : TranslatedImage_LocalizedImage(nullptr, std::move(from)) {}
  inline TranslatedImage_LocalizedImage& operator=(const TranslatedImage_LocalizedImage& from) {
    CopyFrom(from);
    return *this;
  }
  inline TranslatedImage_LocalizedImage& operator=(TranslatedImage_LocalizedImage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TranslatedImage_LocalizedImage& default_instance() {
    return *internal_default_instance();
  }
  static inline const TranslatedImage_LocalizedImage* internal_default_instance() {
    return reinterpret_cast<const TranslatedImage_LocalizedImage*>(
        &_TranslatedImage_LocalizedImage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(TranslatedImage_LocalizedImage& a, TranslatedImage_LocalizedImage& b) { a.Swap(&b); }
  inline void Swap(TranslatedImage_LocalizedImage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TranslatedImage_LocalizedImage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TranslatedImage_LocalizedImage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TranslatedImage_LocalizedImage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TranslatedImage_LocalizedImage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TranslatedImage_LocalizedImage& from) { TranslatedImage_LocalizedImage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TranslatedImage_LocalizedImage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "transit_realtime.TranslatedImage.LocalizedImage"; }

 protected:
  explicit TranslatedImage_LocalizedImage(::google::protobuf::Arena* arena);
  TranslatedImage_LocalizedImage(::google::protobuf::Arena* arena, const TranslatedImage_LocalizedImage& from);
  TranslatedImage_LocalizedImage(::google::protobuf::Arena* arena, TranslatedImage_LocalizedImage&& from) noexcept
      : TranslatedImage_LocalizedImage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUrlFieldNumber = 1,
    kMediaTypeFieldNumber = 2,
    kLanguageFieldNumber = 3,
  };
  // required string url = 1;
  bool has_url() const;
  void clear_url() ;
  const std::string& url() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_url(Arg_&& arg, Args_... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* value);

  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(
      const std::string& value);
  std::string* _internal_mutable_url();

  public:
  // required string media_type = 2;
  bool has_media_type() const;
  void clear_media_type() ;
  const std::string& media_type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_media_type(Arg_&& arg, Args_... args);
  std::string* mutable_media_type();
  PROTOBUF_NODISCARD std::string* release_media_type();
  void set_allocated_media_type(std::string* value);

  private:
  const std::string& _internal_media_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_media_type(
      const std::string& value);
  std::string* _internal_mutable_media_type();

  public:
  // optional string language = 3;
  bool has_language() const;
  void clear_language() ;
  const std::string& language() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_language(Arg_&& arg, Args_... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* value);

  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(
      const std::string& value);
  std::string* _internal_mutable_language();

  public:
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedImage_LocalizedImage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedImage_LocalizedImage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedImage_LocalizedImage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedImage_LocalizedImage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedImage_LocalizedImage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedImage_LocalizedImage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedImage_LocalizedImage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedImage_LocalizedImage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedImage_LocalizedImage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<TranslatedImage_LocalizedImage, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedImage_LocalizedImage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedImage_LocalizedImage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedImage_LocalizedImage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedImage_LocalizedImage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedImage_LocalizedImage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedImage_LocalizedImage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedImage_LocalizedImage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedImage_LocalizedImage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedImage_LocalizedImage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:transit_realtime.TranslatedImage.LocalizedImage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      77, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TranslatedImage_LocalizedImage& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr url_;
    ::google::protobuf::internal::ArenaStringPtr media_type_;
    ::google::protobuf::internal::ArenaStringPtr language_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class TimeRange final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:transit_realtime.TimeRange) */ {
 public:
  inline TimeRange() : TimeRange(nullptr) {}
  ~TimeRange() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TimeRange* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TimeRange));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TimeRange(
      ::google::protobuf::internal::ConstantInitialized);

  inline TimeRange(const TimeRange& from) : TimeRange(nullptr, from) {}
  inline TimeRange(TimeRange&& from) noexcept
      : TimeRange(nullptr, std::move(from)) {}
  inline TimeRange& operator=(const TimeRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimeRange& operator=(TimeRange&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimeRange& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimeRange* internal_default_instance() {
    return reinterpret_cast<const TimeRange*>(
        &_TimeRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(TimeRange& a, TimeRange& b) { a.Swap(&b); }
  inline void Swap(TimeRange* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimeRange* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimeRange* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TimeRange>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TimeRange& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TimeRange& from) { TimeRange::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TimeRange* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "transit_realtime.TimeRange"; }

 protected:
  explicit TimeRange(::google::protobuf::Arena* arena);
  TimeRange(::google::protobuf::Arena* arena, const TimeRange& from);
  TimeRange(::google::protobuf::Arena* arena, TimeRange&& from) noexcept
      : TimeRange(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
  };
  // optional uint64 start = 1;
  bool has_start() const;
  void clear_start() ;
  ::uint64_t start() const;
  void set_start(::uint64_t value);

  private:
  ::uint64_t _internal_start() const;
  void _internal_set_start(::uint64_t value);

  public:
  // optional uint64 end = 2;
  bool has_end() const;
  void clear_end() ;
  ::uint64_t end() const;
  void set_end(::uint64_t value);

  private:
  ::uint64_t _internal_end() const;
  void _internal_set_end(::uint64_t value);

  public:
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TimeRange, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TimeRange, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<TimeRange, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TimeRange, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TimeRange, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TimeRange, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TimeRange, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TimeRange, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TimeRange, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<TimeRange, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TimeRange, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TimeRange, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TimeRange, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TimeRange, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TimeRange, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TimeRange, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TimeRange, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TimeRange, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TimeRange, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:transit_realtime.TimeRange)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TimeRange& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t start_;
    ::uint64_t end_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class StopSelector final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:transit_realtime.StopSelector) */ {
 public:
  inline StopSelector() : StopSelector(nullptr) {}
  ~StopSelector() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(StopSelector* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(StopSelector));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StopSelector(
      ::google::protobuf::internal::ConstantInitialized);

  inline StopSelector(const StopSelector& from) : StopSelector(nullptr, from) {}
  inline StopSelector(StopSelector&& from) noexcept
      : StopSelector(nullptr, std::move(from)) {}
  inline StopSelector& operator=(const StopSelector& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopSelector& operator=(StopSelector&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopSelector& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopSelector* internal_default_instance() {
    return reinterpret_cast<const StopSelector*>(
        &_StopSelector_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 26;
  friend void swap(StopSelector& a, StopSelector& b) { a.Swap(&b); }
  inline void Swap(StopSelector* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopSelector* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopSelector* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<StopSelector>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StopSelector& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StopSelector& from) { StopSelector::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(StopSelector* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "transit_realtime.StopSelector"; }

 protected:
  explicit StopSelector(::google::protobuf::Arena* arena);
  StopSelector(::google::protobuf::Arena* arena, const StopSelector& from);
  StopSelector(::google::protobuf::Arena* arena, StopSelector&& from) noexcept
      : StopSelector(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStopIdFieldNumber = 2,
    kStopSequenceFieldNumber = 1,
  };
  // optional string stop_id = 2;
  bool has_stop_id() const;
  void clear_stop_id() ;
  const std::string& stop_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_stop_id(Arg_&& arg, Args_... args);
  std::string* mutable_stop_id();
  PROTOBUF_NODISCARD std::string* release_stop_id();
  void set_allocated_stop_id(std::string* value);

  private:
  const std::string& _internal_stop_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stop_id(
      const std::string& value);
  std::string* _internal_mutable_stop_id();

  public:
  // optional uint32 stop_sequence = 1;
  bool has_stop_sequence() const;
  void clear_stop_sequence() ;
  ::uint32_t stop_sequence() const;
  void set_stop_sequence(::uint32_t value);

  private:
  ::uint32_t _internal_stop_sequence() const;
  void _internal_set_stop_sequence(::uint32_t value);

  public:
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<StopSelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<StopSelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<StopSelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<StopSelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<StopSelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<StopSelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<StopSelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<StopSelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<StopSelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<StopSelector, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<StopSelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<StopSelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<StopSelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<StopSelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<StopSelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<StopSelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<StopSelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<StopSelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<StopSelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:transit_realtime.StopSelector)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      45, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const StopSelector& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr stop_id_;
    ::uint32_t stop_sequence_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class Shape final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:transit_realtime.Shape) */ {
 public:
  inline Shape() : Shape(nullptr) {}
  ~Shape() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Shape* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Shape));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Shape(
      ::google::protobuf::internal::ConstantInitialized);

  inline Shape(const Shape& from) : Shape(nullptr, from) {}
  inline Shape(Shape&& from) noexcept
      : Shape(nullptr, std::move(from)) {}
  inline Shape& operator=(const Shape& from) {
    CopyFrom(from);
    return *this;
  }
  inline Shape& operator=(Shape&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Shape& default_instance() {
    return *internal_default_instance();
  }
  static inline const Shape* internal_default_instance() {
    return reinterpret_cast<const Shape*>(
        &_Shape_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(Shape& a, Shape& b) { a.Swap(&b); }
  inline void Swap(Shape* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Shape* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Shape* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Shape>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Shape& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Shape& from) { Shape::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Shape* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "transit_realtime.Shape"; }

 protected:
  explicit Shape(::google::protobuf::Arena* arena);
  Shape(::google::protobuf::Arena* arena, const Shape& from);
  Shape(::google::protobuf::Arena* arena, Shape&& from) noexcept
      : Shape(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kShapeIdFieldNumber = 1,
    kEncodedPolylineFieldNumber = 2,
  };
  // optional string shape_id = 1;
  bool has_shape_id() const;
  void clear_shape_id() ;
  const std::string& shape_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_shape_id(Arg_&& arg, Args_... args);
  std::string* mutable_shape_id();
  PROTOBUF_NODISCARD std::string* release_shape_id();
  void set_allocated_shape_id(std::string* value);

  private:
  const std::string& _internal_shape_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shape_id(
      const std::string& value);
  std::string* _internal_mutable_shape_id();

  public:
  // optional string encoded_polyline = 2;
  bool has_encoded_polyline() const;
  void clear_encoded_polyline() ;
  const std::string& encoded_polyline() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_encoded_polyline(Arg_&& arg, Args_... args);
  std::string* mutable_encoded_polyline();
  PROTOBUF_NODISCARD std::string* release_encoded_polyline();
  void set_allocated_encoded_polyline(std::string* value);

  private:
  const std::string& _internal_encoded_polyline() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encoded_polyline(
      const std::string& value);
  std::string* _internal_mutable_encoded_polyline();

  public:
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Shape, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Shape, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<Shape, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Shape, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Shape, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Shape, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Shape, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Shape, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Shape, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<Shape, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Shape, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Shape, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Shape, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Shape, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Shape, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Shape, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Shape, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Shape, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Shape, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:transit_realtime.Shape)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      55, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Shape& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr shape_id_;
    ::google::protobuf::internal::ArenaStringPtr encoded_polyline_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class ReplacementStop final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:transit_realtime.ReplacementStop) */ {
 public:
  inline ReplacementStop() : ReplacementStop(nullptr) {}
  ~ReplacementStop() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ReplacementStop* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ReplacementStop));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReplacementStop(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReplacementStop(const ReplacementStop& from) : ReplacementStop(nullptr, from) {}
  inline ReplacementStop(ReplacementStop&& from) noexcept
      : ReplacementStop(nullptr, std::move(from)) {}
  inline ReplacementStop& operator=(const ReplacementStop& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReplacementStop& operator=(ReplacementStop&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReplacementStop& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReplacementStop* internal_default_instance() {
    return reinterpret_cast<const ReplacementStop*>(
        &_ReplacementStop_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 27;
  friend void swap(ReplacementStop& a, ReplacementStop& b) { a.Swap(&b); }
  inline void Swap(ReplacementStop* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReplacementStop* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReplacementStop* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ReplacementStop>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReplacementStop& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReplacementStop& from) { ReplacementStop::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ReplacementStop* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "transit_realtime.ReplacementStop"; }

 protected:
  explicit ReplacementStop(::google::protobuf::Arena* arena);
  ReplacementStop(::google::protobuf::Arena* arena, const ReplacementStop& from);
  ReplacementStop(::google::protobuf::Arena* arena, ReplacementStop&& from) noexcept
      : ReplacementStop(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStopIdFieldNumber = 2,
    kTravelTimeToStopFieldNumber = 1,
  };
  // optional string stop_id = 2;
  bool has_stop_id() const;
  void clear_stop_id() ;
  const std::string& stop_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_stop_id(Arg_&& arg, Args_... args);
  std::string* mutable_stop_id();
  PROTOBUF_NODISCARD std::string* release_stop_id();
  void set_allocated_stop_id(std::string* value);

  private:
  const std::string& _internal_stop_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stop_id(
      const std::string& value);
  std::string* _internal_mutable_stop_id();

  public:
  // optional int32 travel_time_to_stop = 1;
  bool has_travel_time_to_stop() const;
  void clear_travel_time_to_stop() ;
  ::int32_t travel_time_to_stop() const;
  void set_travel_time_to_stop(::int32_t value);

  private:
  ::int32_t _internal_travel_time_to_stop() const;
  void _internal_set_travel_time_to_stop(::int32_t value);

  public:
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<ReplacementStop, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<ReplacementStop, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<ReplacementStop, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<ReplacementStop, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<ReplacementStop, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<ReplacementStop, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<ReplacementStop, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<ReplacementStop, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<ReplacementStop, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<ReplacementStop, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<ReplacementStop, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<ReplacementStop, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<ReplacementStop, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<ReplacementStop, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<ReplacementStop, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<ReplacementStop, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<ReplacementStop, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<ReplacementStop, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<ReplacementStop, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:transit_realtime.ReplacementStop)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      48, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReplacementStop& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr stop_id_;
    ::int32_t travel_time_to_stop_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class Position final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:transit_realtime.Position) */ {
 public:
  inline Position() : Position(nullptr) {}
  ~Position() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Position* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Position));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Position(
      ::google::protobuf::internal::ConstantInitialized);

  inline Position(const Position& from) : Position(nullptr, from) {}
  inline Position(Position&& from) noexcept
      : Position(nullptr, std::move(from)) {}
  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }
  inline Position& operator=(Position&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Position& default_instance() {
    return *internal_default_instance();
  }
  static inline const Position* internal_default_instance() {
    return reinterpret_cast<const Position*>(
        &_Position_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(Position& a, Position& b) { a.Swap(&b); }
  inline void Swap(Position* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Position* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Position* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Position>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Position& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Position& from) { Position::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Position* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "transit_realtime.Position"; }

 protected:
  explicit Position(::google::protobuf::Arena* arena);
  Position(::google::protobuf::Arena* arena, const Position& from);
  Position(::google::protobuf::Arena* arena, Position&& from) noexcept
      : Position(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLatitudeFieldNumber = 1,
    kLongitudeFieldNumber = 2,
    kOdometerFieldNumber = 4,
    kBearingFieldNumber = 3,
    kSpeedFieldNumber = 5,
  };
  // required float latitude = 1;
  bool has_latitude() const;
  void clear_latitude() ;
  float latitude() const;
  void set_latitude(float value);

  private:
  float _internal_latitude() const;
  void _internal_set_latitude(float value);

  public:
  // required float longitude = 2;
  bool has_longitude() const;
  void clear_longitude() ;
  float longitude() const;
  void set_longitude(float value);

  private:
  float _internal_longitude() const;
  void _internal_set_longitude(float value);

  public:
  // optional double odometer = 4;
  bool has_odometer() const;
  void clear_odometer() ;
  double odometer() const;
  void set_odometer(double value);

  private:
  double _internal_odometer() const;
  void _internal_set_odometer(double value);

  public:
  // optional float bearing = 3;
  bool has_bearing() const;
  void clear_bearing() ;
  float bearing() const;
  void set_bearing(float value);

  private:
  float _internal_bearing() const;
  void _internal_set_bearing(float value);

  public:
  // optional float speed = 5;
  bool has_speed() const;
  void clear_speed() ;
  float speed() const;
  void set_speed(float value);

  private:
  float _internal_speed() const;
  void _internal_set_speed(float value);

  public:
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Position, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Position, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<Position, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Position, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Position, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Position, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Position, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Position, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Position, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<Position, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Position, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Position, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Position, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Position, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Position, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Position, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Position, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Position, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Position, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:transit_realtime.Position)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Position& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    float latitude_;
    float longitude_;
    double odometer_;
    float bearing_;
    float speed_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class FeedHeader final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:transit_realtime.FeedHeader) */ {
 public:
  inline FeedHeader() : FeedHeader(nullptr) {}
  ~FeedHeader() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FeedHeader* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FeedHeader));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FeedHeader(
      ::google::protobuf::internal::ConstantInitialized);

  inline FeedHeader(const FeedHeader& from) : FeedHeader(nullptr, from) {}
  inline FeedHeader(FeedHeader&& from) noexcept
      : FeedHeader(nullptr, std::move(from)) {}
  inline FeedHeader& operator=(const FeedHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeedHeader& operator=(FeedHeader&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FeedHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeedHeader* internal_default_instance() {
    return reinterpret_cast<const FeedHeader*>(
        &_FeedHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(FeedHeader& a, FeedHeader& b) { a.Swap(&b); }
  inline void Swap(FeedHeader* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeedHeader* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeedHeader* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FeedHeader>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FeedHeader& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FeedHeader& from) { FeedHeader::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FeedHeader* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "transit_realtime.FeedHeader"; }

 protected:
  explicit FeedHeader(::google::protobuf::Arena* arena);
  FeedHeader(::google::protobuf::Arena* arena, const FeedHeader& from);
  FeedHeader(::google::protobuf::Arena* arena, FeedHeader&& from) noexcept
      : FeedHeader(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Incrementality = FeedHeader_Incrementality;
  static constexpr Incrementality FULL_DATASET = FeedHeader_Incrementality_FULL_DATASET;
  static constexpr Incrementality DIFFERENTIAL = FeedHeader_Incrementality_DIFFERENTIAL;
  static inline bool Incrementality_IsValid(int value) {
    return FeedHeader_Incrementality_IsValid(value);
  }
  static constexpr Incrementality Incrementality_MIN = FeedHeader_Incrementality_Incrementality_MIN;
  static constexpr Incrementality Incrementality_MAX = FeedHeader_Incrementality_Incrementality_MAX;
  static constexpr int Incrementality_ARRAYSIZE = FeedHeader_Incrementality_Incrementality_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Incrementality_descriptor() {
    return FeedHeader_Incrementality_descriptor();
  }
  template <typename T>
  static inline const std::string& Incrementality_Name(T value) {
    return FeedHeader_Incrementality_Name(value);
  }
  static inline bool Incrementality_Parse(absl::string_view name, Incrementality* value) {
    return FeedHeader_Incrementality_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kGtfsRealtimeVersionFieldNumber = 1,
    kFeedVersionFieldNumber = 4,
    kTimestampFieldNumber = 3,
    kIncrementalityFieldNumber = 2,
  };
  // required string gtfs_realtime_version = 1;
  bool has_gtfs_realtime_version() const;
  void clear_gtfs_realtime_version() ;
  const std::string& gtfs_realtime_version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_gtfs_realtime_version(Arg_&& arg, Args_... args);
  std::string* mutable_gtfs_realtime_version();
  PROTOBUF_NODISCARD std::string* release_gtfs_realtime_version();
  void set_allocated_gtfs_realtime_version(std::string* value);

  private:
  const std::string& _internal_gtfs_realtime_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gtfs_realtime_version(
      const std::string& value);
  std::string* _internal_mutable_gtfs_realtime_version();

  public:
  // optional string feed_version = 4;
  bool has_feed_version() const;
  void clear_feed_version() ;
  const std::string& feed_version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_feed_version(Arg_&& arg, Args_... args);
  std::string* mutable_feed_version();
  PROTOBUF_NODISCARD std::string* release_feed_version();
  void set_allocated_feed_version(std::string* value);

  private:
  const std::string& _internal_feed_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_feed_version(
      const std::string& value);
  std::string* _internal_mutable_feed_version();

  public:
  // optional uint64 timestamp = 3;
  bool has_timestamp() const;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // optional .transit_realtime.FeedHeader.Incrementality incrementality = 2 [default = FULL_DATASET];
  bool has_incrementality() const;
  void clear_incrementality() ;
  ::transit_realtime::FeedHeader_Incrementality incrementality() const;
  void set_incrementality(::transit_realtime::FeedHeader_Incrementality value);

  private:
  ::transit_realtime::FeedHeader_Incrementality _internal_incrementality() const;
  void _internal_set_incrementality(::transit_realtime::FeedHeader_Incrementality value);

  public:
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedHeader, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedHeader, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedHeader, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedHeader, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedHeader, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedHeader, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedHeader, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedHeader, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedHeader, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<FeedHeader, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedHeader, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedHeader, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedHeader, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedHeader, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedHeader, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedHeader, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedHeader, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedHeader, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedHeader, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:transit_realtime.FeedHeader)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      69, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FeedHeader& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr gtfs_realtime_version_;
    ::google::protobuf::internal::ArenaStringPtr feed_version_;
    ::uint64_t timestamp_;
    int incrementality_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class TripUpdate_StopTimeUpdate final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:transit_realtime.TripUpdate.StopTimeUpdate) */ {
 public:
  inline TripUpdate_StopTimeUpdate() : TripUpdate_StopTimeUpdate(nullptr) {}
  ~TripUpdate_StopTimeUpdate() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TripUpdate_StopTimeUpdate* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TripUpdate_StopTimeUpdate));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TripUpdate_StopTimeUpdate(
      ::google::protobuf::internal::ConstantInitialized);

  inline TripUpdate_StopTimeUpdate(const TripUpdate_StopTimeUpdate& from) : TripUpdate_StopTimeUpdate(nullptr, from) {}
  inline TripUpdate_StopTimeUpdate(TripUpdate_StopTimeUpdate&& from) noexcept
      : TripUpdate_StopTimeUpdate(nullptr, std::move(from)) {}
  inline TripUpdate_StopTimeUpdate& operator=(const TripUpdate_StopTimeUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripUpdate_StopTimeUpdate& operator=(TripUpdate_StopTimeUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TripUpdate_StopTimeUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripUpdate_StopTimeUpdate* internal_default_instance() {
    return reinterpret_cast<const TripUpdate_StopTimeUpdate*>(
        &_TripUpdate_StopTimeUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(TripUpdate_StopTimeUpdate& a, TripUpdate_StopTimeUpdate& b) { a.Swap(&b); }
  inline void Swap(TripUpdate_StopTimeUpdate* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripUpdate_StopTimeUpdate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripUpdate_StopTimeUpdate* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TripUpdate_StopTimeUpdate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TripUpdate_StopTimeUpdate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TripUpdate_StopTimeUpdate& from) { TripUpdate_StopTimeUpdate::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TripUpdate_StopTimeUpdate* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "transit_realtime.TripUpdate.StopTimeUpdate"; }

 protected:
  explicit TripUpdate_StopTimeUpdate(::google::protobuf::Arena* arena);
  TripUpdate_StopTimeUpdate(::google::protobuf::Arena* arena, const TripUpdate_StopTimeUpdate& from);
  TripUpdate_StopTimeUpdate(::google::protobuf::Arena* arena, TripUpdate_StopTimeUpdate&& from) noexcept
      : TripUpdate_StopTimeUpdate(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using StopTimeProperties = TripUpdate_StopTimeUpdate_StopTimeProperties;
  using ScheduleRelationship = TripUpdate_StopTimeUpdate_ScheduleRelationship;
  static constexpr ScheduleRelationship SCHEDULED = TripUpdate_StopTimeUpdate_ScheduleRelationship_SCHEDULED;
  static constexpr ScheduleRelationship SKIPPED = TripUpdate_StopTimeUpdate_ScheduleRelationship_SKIPPED;
  static constexpr ScheduleRelationship NO_DATA = TripUpdate_StopTimeUpdate_ScheduleRelationship_NO_DATA;
  static constexpr ScheduleRelationship UNSCHEDULED = TripUpdate_StopTimeUpdate_ScheduleRelationship_UNSCHEDULED;
  static inline bool ScheduleRelationship_IsValid(int value) {
    return TripUpdate_StopTimeUpdate_ScheduleRelationship_IsValid(value);
  }
  static constexpr ScheduleRelationship ScheduleRelationship_MIN = TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_MIN;
  static constexpr ScheduleRelationship ScheduleRelationship_MAX = TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_MAX;
  static constexpr int ScheduleRelationship_ARRAYSIZE = TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ScheduleRelationship_descriptor() {
    return TripUpdate_StopTimeUpdate_ScheduleRelationship_descriptor();
  }
  template <typename T>
  static inline const std::string& ScheduleRelationship_Name(T value) {
    return TripUpdate_StopTimeUpdate_ScheduleRelationship_Name(value);
  }
  static inline bool ScheduleRelationship_Parse(absl::string_view name, ScheduleRelationship* value) {
    return TripUpdate_StopTimeUpdate_ScheduleRelationship_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kStopIdFieldNumber = 4,
    kArrivalFieldNumber = 2,
    kDepartureFieldNumber = 3,
    kStopTimePropertiesFieldNumber = 6,
    kStopSequenceFieldNumber = 1,
    kScheduleRelationshipFieldNumber = 5,
    kDepartureOccupancyStatusFieldNumber = 7,
  };
  // optional string stop_id = 4;
  bool has_stop_id() const;
  void clear_stop_id() ;
  const std::string& stop_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_stop_id(Arg_&& arg, Args_... args);
  std::string* mutable_stop_id();
  PROTOBUF_NODISCARD std::string* release_stop_id();
  void set_allocated_stop_id(std::string* value);

  private:
  const std::string& _internal_stop_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stop_id(
      const std::string& value);
  std::string* _internal_mutable_stop_id();

  public:
  // optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2;
  bool has_arrival() const;
  void clear_arrival() ;
  const ::transit_realtime::TripUpdate_StopTimeEvent& arrival() const;
  PROTOBUF_NODISCARD ::transit_realtime::TripUpdate_StopTimeEvent* release_arrival();
  ::transit_realtime::TripUpdate_StopTimeEvent* mutable_arrival();
  void set_allocated_arrival(::transit_realtime::TripUpdate_StopTimeEvent* value);
  void unsafe_arena_set_allocated_arrival(::transit_realtime::TripUpdate_StopTimeEvent* value);
  ::transit_realtime::TripUpdate_StopTimeEvent* unsafe_arena_release_arrival();

  private:
  const ::transit_realtime::TripUpdate_StopTimeEvent& _internal_arrival() const;
  ::transit_realtime::TripUpdate_StopTimeEvent* _internal_mutable_arrival();

  public:
  // optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3;
  bool has_departure() const;
  void clear_departure() ;
  const ::transit_realtime::TripUpdate_StopTimeEvent& departure() const;
  PROTOBUF_NODISCARD ::transit_realtime::TripUpdate_StopTimeEvent* release_departure();
  ::transit_realtime::TripUpdate_StopTimeEvent* mutable_departure();
  void set_allocated_departure(::transit_realtime::TripUpdate_StopTimeEvent* value);
  void unsafe_arena_set_allocated_departure(::transit_realtime::TripUpdate_StopTimeEvent* value);
  ::transit_realtime::TripUpdate_StopTimeEvent* unsafe_arena_release_departure();

  private:
  const ::transit_realtime::TripUpdate_StopTimeEvent& _internal_departure() const;
  ::transit_realtime::TripUpdate_StopTimeEvent* _internal_mutable_departure();

  public:
  // optional .transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties stop_time_properties = 6;
  bool has_stop_time_properties() const;
  void clear_stop_time_properties() ;
  const ::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties& stop_time_properties() const;
  PROTOBUF_NODISCARD ::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties* release_stop_time_properties();
  ::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties* mutable_stop_time_properties();
  void set_allocated_stop_time_properties(::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties* value);
  void unsafe_arena_set_allocated_stop_time_properties(::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties* value);
  ::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties* unsafe_arena_release_stop_time_properties();

  private:
  const ::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties& _internal_stop_time_properties() const;
  ::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties* _internal_mutable_stop_time_properties();

  public:
  // optional uint32 stop_sequence = 1;
  bool has_stop_sequence() const;
  void clear_stop_sequence() ;
  ::uint32_t stop_sequence() const;
  void set_stop_sequence(::uint32_t value);

  private:
  ::uint32_t _internal_stop_sequence() const;
  void _internal_set_stop_sequence(::uint32_t value);

  public:
  // optional .transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship = 5 [default = SCHEDULED];
  bool has_schedule_relationship() const;
  void clear_schedule_relationship() ;
  ::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship schedule_relationship() const;
  void set_schedule_relationship(::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship value);

  private:
  ::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship _internal_schedule_relationship() const;
  void _internal_set_schedule_relationship(::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship value);

  public:
  // optional .transit_realtime.VehiclePosition.OccupancyStatus departure_occupancy_status = 7;
  bool has_departure_occupancy_status() const;
  void clear_departure_occupancy_status() ;
  ::transit_realtime::VehiclePosition_OccupancyStatus departure_occupancy_status() const;
  void set_departure_occupancy_status(::transit_realtime::VehiclePosition_OccupancyStatus value);

  private:
  ::transit_realtime::VehiclePosition_OccupancyStatus _internal_departure_occupancy_status() const;
  void _internal_set_departure_occupancy_status(::transit_realtime::VehiclePosition_OccupancyStatus value);

  public:
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate_StopTimeUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:transit_realtime.TripUpdate.StopTimeUpdate)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 5,
      58, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TripUpdate_StopTimeUpdate& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr stop_id_;
    ::transit_realtime::TripUpdate_StopTimeEvent* arrival_;
    ::transit_realtime::TripUpdate_StopTimeEvent* departure_;
    ::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties* stop_time_properties_;
    ::uint32_t stop_sequence_;
    int schedule_relationship_;
    int departure_occupancy_status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class TripModifications_Modification final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:transit_realtime.TripModifications.Modification) */ {
 public:
  inline TripModifications_Modification() : TripModifications_Modification(nullptr) {}
  ~TripModifications_Modification() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TripModifications_Modification* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TripModifications_Modification));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TripModifications_Modification(
      ::google::protobuf::internal::ConstantInitialized);

  inline TripModifications_Modification(const TripModifications_Modification& from) : TripModifications_Modification(nullptr, from) {}
  inline TripModifications_Modification(TripModifications_Modification&& from) noexcept
      : TripModifications_Modification(nullptr, std::move(from)) {}
  inline TripModifications_Modification& operator=(const TripModifications_Modification& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripModifications_Modification& operator=(TripModifications_Modification&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TripModifications_Modification& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripModifications_Modification* internal_default_instance() {
    return reinterpret_cast<const TripModifications_Modification*>(
        &_TripModifications_Modification_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(TripModifications_Modification& a, TripModifications_Modification& b) { a.Swap(&b); }
  inline void Swap(TripModifications_Modification* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripModifications_Modification* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripModifications_Modification* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TripModifications_Modification>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TripModifications_Modification& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TripModifications_Modification& from) { TripModifications_Modification::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TripModifications_Modification* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "transit_realtime.TripModifications.Modification"; }

 protected:
  explicit TripModifications_Modification(::google::protobuf::Arena* arena);
  TripModifications_Modification(::google::protobuf::Arena* arena, const TripModifications_Modification& from);
  TripModifications_Modification(::google::protobuf::Arena* arena, TripModifications_Modification&& from) noexcept
      : TripModifications_Modification(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kReplacementStopsFieldNumber = 4,
    kServiceAlertIdFieldNumber = 5,
    kStartStopSelectorFieldNumber = 1,
    kEndStopSelectorFieldNumber = 2,
    kLastModifiedTimeFieldNumber = 6,
    kPropagatedModificationDelayFieldNumber = 3,
  };
  // repeated .transit_realtime.ReplacementStop replacement_stops = 4;
  int replacement_stops_size() const;
  private:
  int _internal_replacement_stops_size() const;

  public:
  void clear_replacement_stops() ;
  ::transit_realtime::ReplacementStop* mutable_replacement_stops(int index);
  ::google::protobuf::RepeatedPtrField<::transit_realtime::ReplacementStop>* mutable_replacement_stops();

  private:
  const ::google::protobuf::RepeatedPtrField<::transit_realtime::ReplacementStop>& _internal_replacement_stops() const;
  ::google::protobuf::RepeatedPtrField<::transit_realtime::ReplacementStop>* _internal_mutable_replacement_stops();
  public:
  const ::transit_realtime::ReplacementStop& replacement_stops(int index) const;
  ::transit_realtime::ReplacementStop* add_replacement_stops();
  const ::google::protobuf::RepeatedPtrField<::transit_realtime::ReplacementStop>& replacement_stops() const;
  // optional string service_alert_id = 5;
  bool has_service_alert_id() const;
  void clear_service_alert_id() ;
  const std::string& service_alert_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_service_alert_id(Arg_&& arg, Args_... args);
  std::string* mutable_service_alert_id();
  PROTOBUF_NODISCARD std::string* release_service_alert_id();
  void set_allocated_service_alert_id(std::string* value);

  private:
  const std::string& _internal_service_alert_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_alert_id(
      const std::string& value);
  std::string* _internal_mutable_service_alert_id();

  public:
  // optional .transit_realtime.StopSelector start_stop_selector = 1;
  bool has_start_stop_selector() const;
  void clear_start_stop_selector() ;
  const ::transit_realtime::StopSelector& start_stop_selector() const;
  PROTOBUF_NODISCARD ::transit_realtime::StopSelector* release_start_stop_selector();
  ::transit_realtime::StopSelector* mutable_start_stop_selector();
  void set_allocated_start_stop_selector(::transit_realtime::StopSelector* value);
  void unsafe_arena_set_allocated_start_stop_selector(::transit_realtime::StopSelector* value);
  ::transit_realtime::StopSelector* unsafe_arena_release_start_stop_selector();

  private:
  const ::transit_realtime::StopSelector& _internal_start_stop_selector() const;
  ::transit_realtime::StopSelector* _internal_mutable_start_stop_selector();

  public:
  // optional .transit_realtime.StopSelector end_stop_selector = 2;
  bool has_end_stop_selector() const;
  void clear_end_stop_selector() ;
  const ::transit_realtime::StopSelector& end_stop_selector() const;
  PROTOBUF_NODISCARD ::transit_realtime::StopSelector* release_end_stop_selector();
  ::transit_realtime::StopSelector* mutable_end_stop_selector();
  void set_allocated_end_stop_selector(::transit_realtime::StopSelector* value);
  void unsafe_arena_set_allocated_end_stop_selector(::transit_realtime::StopSelector* value);
  ::transit_realtime::StopSelector* unsafe_arena_release_end_stop_selector();

  private:
  const ::transit_realtime::StopSelector& _internal_end_stop_selector() const;
  ::transit_realtime::StopSelector* _internal_mutable_end_stop_selector();

  public:
  // optional uint64 last_modified_time = 6;
  bool has_last_modified_time() const;
  void clear_last_modified_time() ;
  ::uint64_t last_modified_time() const;
  void set_last_modified_time(::uint64_t value);

  private:
  ::uint64_t _internal_last_modified_time() const;
  void _internal_set_last_modified_time(::uint64_t value);

  public:
  // optional int32 propagated_modification_delay = 3 [default = 0];
  bool has_propagated_modification_delay() const;
  void clear_propagated_modification_delay() ;
  ::int32_t propagated_modification_delay() const;
  void set_propagated_modification_delay(::int32_t value);

  private:
  ::int32_t _internal_propagated_modification_delay() const;
  void _internal_set_propagated_modification_delay(::int32_t value);

  public:
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications_Modification, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications_Modification, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications_Modification, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications_Modification, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications_Modification, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications_Modification, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications_Modification, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications_Modification, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications_Modification, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<TripModifications_Modification, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications_Modification, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications_Modification, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications_Modification, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications_Modification, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications_Modification, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications_Modification, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications_Modification, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications_Modification, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications_Modification, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:transit_realtime.TripModifications.Modification)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 3,
      72, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TripModifications_Modification& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::transit_realtime::ReplacementStop > replacement_stops_;
    ::google::protobuf::internal::ArenaStringPtr service_alert_id_;
    ::transit_realtime::StopSelector* start_stop_selector_;
    ::transit_realtime::StopSelector* end_stop_selector_;
    ::uint64_t last_modified_time_;
    ::int32_t propagated_modification_delay_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class TripDescriptor final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:transit_realtime.TripDescriptor) */ {
 public:
  inline TripDescriptor() : TripDescriptor(nullptr) {}
  ~TripDescriptor() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TripDescriptor* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TripDescriptor));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TripDescriptor(
      ::google::protobuf::internal::ConstantInitialized);

  inline TripDescriptor(const TripDescriptor& from) : TripDescriptor(nullptr, from) {}
  inline TripDescriptor(TripDescriptor&& from) noexcept
      : TripDescriptor(nullptr, std::move(from)) {}
  inline TripDescriptor& operator=(const TripDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripDescriptor& operator=(TripDescriptor&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TripDescriptor& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripDescriptor* internal_default_instance() {
    return reinterpret_cast<const TripDescriptor*>(
        &_TripDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(TripDescriptor& a, TripDescriptor& b) { a.Swap(&b); }
  inline void Swap(TripDescriptor* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripDescriptor* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripDescriptor* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TripDescriptor>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TripDescriptor& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TripDescriptor& from) { TripDescriptor::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TripDescriptor* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "transit_realtime.TripDescriptor"; }

 protected:
  explicit TripDescriptor(::google::protobuf::Arena* arena);
  TripDescriptor(::google::protobuf::Arena* arena, const TripDescriptor& from);
  TripDescriptor(::google::protobuf::Arena* arena, TripDescriptor&& from) noexcept
      : TripDescriptor(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using ModifiedTripSelector = TripDescriptor_ModifiedTripSelector;
  using ScheduleRelationship = TripDescriptor_ScheduleRelationship;
  static constexpr ScheduleRelationship SCHEDULED = TripDescriptor_ScheduleRelationship_SCHEDULED;
  static constexpr ScheduleRelationship ADDED = TripDescriptor_ScheduleRelationship_ADDED;
  static constexpr ScheduleRelationship UNSCHEDULED = TripDescriptor_ScheduleRelationship_UNSCHEDULED;
  static constexpr ScheduleRelationship CANCELED = TripDescriptor_ScheduleRelationship_CANCELED;
  [[deprecated]] static constexpr ScheduleRelationship REPLACEMENT = TripDescriptor_ScheduleRelationship_REPLACEMENT;
  static constexpr ScheduleRelationship DUPLICATED = TripDescriptor_ScheduleRelationship_DUPLICATED;
  static constexpr ScheduleRelationship DELETED = TripDescriptor_ScheduleRelationship_DELETED;
  static inline bool ScheduleRelationship_IsValid(int value) {
    return TripDescriptor_ScheduleRelationship_IsValid(value);
  }
  static constexpr ScheduleRelationship ScheduleRelationship_MIN = TripDescriptor_ScheduleRelationship_ScheduleRelationship_MIN;
  static constexpr ScheduleRelationship ScheduleRelationship_MAX = TripDescriptor_ScheduleRelationship_ScheduleRelationship_MAX;
  static constexpr int ScheduleRelationship_ARRAYSIZE = TripDescriptor_ScheduleRelationship_ScheduleRelationship_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ScheduleRelationship_descriptor() {
    return TripDescriptor_ScheduleRelationship_descriptor();
  }
  template <typename T>
  static inline const std::string& ScheduleRelationship_Name(T value) {
    return TripDescriptor_ScheduleRelationship_Name(value);
  }
  static inline bool ScheduleRelationship_Parse(absl::string_view name, ScheduleRelationship* value) {
    return TripDescriptor_ScheduleRelationship_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kTripIdFieldNumber = 1,
    kStartTimeFieldNumber = 2,
    kStartDateFieldNumber = 3,
    kRouteIdFieldNumber = 5,
    kModifiedTripFieldNumber = 7,
    kScheduleRelationshipFieldNumber = 4,
    kDirectionIdFieldNumber = 6,
  };
  // optional string trip_id = 1;
  bool has_trip_id() const;
  void clear_trip_id() ;
  const std::string& trip_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_trip_id(Arg_&& arg, Args_... args);
  std::string* mutable_trip_id();
  PROTOBUF_NODISCARD std::string* release_trip_id();
  void set_allocated_trip_id(std::string* value);

  private:
  const std::string& _internal_trip_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trip_id(
      const std::string& value);
  std::string* _internal_mutable_trip_id();

  public:
  // optional string start_time = 2;
  bool has_start_time() const;
  void clear_start_time() ;
  const std::string& start_time() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_start_time(Arg_&& arg, Args_... args);
  std::string* mutable_start_time();
  PROTOBUF_NODISCARD std::string* release_start_time();
  void set_allocated_start_time(std::string* value);

  private:
  const std::string& _internal_start_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_start_time(
      const std::string& value);
  std::string* _internal_mutable_start_time();

  public:
  // optional string start_date = 3;
  bool has_start_date() const;
  void clear_start_date() ;
  const std::string& start_date() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_start_date(Arg_&& arg, Args_... args);
  std::string* mutable_start_date();
  PROTOBUF_NODISCARD std::string* release_start_date();
  void set_allocated_start_date(std::string* value);

  private:
  const std::string& _internal_start_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_start_date(
      const std::string& value);
  std::string* _internal_mutable_start_date();

  public:
  // optional string route_id = 5;
  bool has_route_id() const;
  void clear_route_id() ;
  const std::string& route_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_route_id(Arg_&& arg, Args_... args);
  std::string* mutable_route_id();
  PROTOBUF_NODISCARD std::string* release_route_id();
  void set_allocated_route_id(std::string* value);

  private:
  const std::string& _internal_route_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_route_id(
      const std::string& value);
  std::string* _internal_mutable_route_id();

  public:
  // optional .transit_realtime.TripDescriptor.ModifiedTripSelector modified_trip = 7;
  bool has_modified_trip() const;
  void clear_modified_trip() ;
  const ::transit_realtime::TripDescriptor_ModifiedTripSelector& modified_trip() const;
  PROTOBUF_NODISCARD ::transit_realtime::TripDescriptor_ModifiedTripSelector* release_modified_trip();
  ::transit_realtime::TripDescriptor_ModifiedTripSelector* mutable_modified_trip();
  void set_allocated_modified_trip(::transit_realtime::TripDescriptor_ModifiedTripSelector* value);
  void unsafe_arena_set_allocated_modified_trip(::transit_realtime::TripDescriptor_ModifiedTripSelector* value);
  ::transit_realtime::TripDescriptor_ModifiedTripSelector* unsafe_arena_release_modified_trip();

  private:
  const ::transit_realtime::TripDescriptor_ModifiedTripSelector& _internal_modified_trip() const;
  ::transit_realtime::TripDescriptor_ModifiedTripSelector* _internal_mutable_modified_trip();

  public:
  // optional .transit_realtime.TripDescriptor.ScheduleRelationship schedule_relationship = 4;
  bool has_schedule_relationship() const;
  void clear_schedule_relationship() ;
  ::transit_realtime::TripDescriptor_ScheduleRelationship schedule_relationship() const;
  void set_schedule_relationship(::transit_realtime::TripDescriptor_ScheduleRelationship value);

  private:
  ::transit_realtime::TripDescriptor_ScheduleRelationship _internal_schedule_relationship() const;
  void _internal_set_schedule_relationship(::transit_realtime::TripDescriptor_ScheduleRelationship value);

  public:
  // optional uint32 direction_id = 6;
  bool has_direction_id() const;
  void clear_direction_id() ;
  ::uint32_t direction_id() const;
  void set_direction_id(::uint32_t value);

  private:
  ::uint32_t _internal_direction_id() const;
  void _internal_set_direction_id(::uint32_t value);

  public:
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<TripDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<TripDescriptor, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripDescriptor, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:transit_realtime.TripDescriptor)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 2,
      75, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TripDescriptor& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr trip_id_;
    ::google::protobuf::internal::ArenaStringPtr start_time_;
    ::google::protobuf::internal::ArenaStringPtr start_date_;
    ::google::protobuf::internal::ArenaStringPtr route_id_;
    ::transit_realtime::TripDescriptor_ModifiedTripSelector* modified_trip_;
    int schedule_relationship_;
    ::uint32_t direction_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class TranslatedString final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:transit_realtime.TranslatedString) */ {
 public:
  inline TranslatedString() : TranslatedString(nullptr) {}
  ~TranslatedString() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TranslatedString* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TranslatedString));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TranslatedString(
      ::google::protobuf::internal::ConstantInitialized);

  inline TranslatedString(const TranslatedString& from) : TranslatedString(nullptr, from) {}
  inline TranslatedString(TranslatedString&& from) noexcept
      : TranslatedString(nullptr, std::move(from)) {}
  inline TranslatedString& operator=(const TranslatedString& from) {
    CopyFrom(from);
    return *this;
  }
  inline TranslatedString& operator=(TranslatedString&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TranslatedString& default_instance() {
    return *internal_default_instance();
  }
  static inline const TranslatedString* internal_default_instance() {
    return reinterpret_cast<const TranslatedString*>(
        &_TranslatedString_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(TranslatedString& a, TranslatedString& b) { a.Swap(&b); }
  inline void Swap(TranslatedString* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TranslatedString* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TranslatedString* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TranslatedString>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TranslatedString& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TranslatedString& from) { TranslatedString::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TranslatedString* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "transit_realtime.TranslatedString"; }

 protected:
  explicit TranslatedString(::google::protobuf::Arena* arena);
  TranslatedString(::google::protobuf::Arena* arena, const TranslatedString& from);
  TranslatedString(::google::protobuf::Arena* arena, TranslatedString&& from) noexcept
      : TranslatedString(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Translation = TranslatedString_Translation;

  // accessors -------------------------------------------------------
  enum : int {
    kTranslationFieldNumber = 1,
  };
  // repeated .transit_realtime.TranslatedString.Translation translation = 1;
  int translation_size() const;
  private:
  int _internal_translation_size() const;

  public:
  void clear_translation() ;
  ::transit_realtime::TranslatedString_Translation* mutable_translation(int index);
  ::google::protobuf::RepeatedPtrField<::transit_realtime::TranslatedString_Translation>* mutable_translation();

  private:
  const ::google::protobuf::RepeatedPtrField<::transit_realtime::TranslatedString_Translation>& _internal_translation() const;
  ::google::protobuf::RepeatedPtrField<::transit_realtime::TranslatedString_Translation>* _internal_mutable_translation();
  public:
  const ::transit_realtime::TranslatedString_Translation& translation(int index) const;
  ::transit_realtime::TranslatedString_Translation* add_translation();
  const ::google::protobuf::RepeatedPtrField<::transit_realtime::TranslatedString_Translation>& translation() const;
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedString, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedString, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedString, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedString, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedString, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedString, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedString, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedString, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedString, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<TranslatedString, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedString, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedString, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedString, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedString, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedString, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedString, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedString, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedString, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedString, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:transit_realtime.TranslatedString)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TranslatedString& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::RepeatedPtrField< ::transit_realtime::TranslatedString_Translation > translation_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class TranslatedImage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:transit_realtime.TranslatedImage) */ {
 public:
  inline TranslatedImage() : TranslatedImage(nullptr) {}
  ~TranslatedImage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TranslatedImage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TranslatedImage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TranslatedImage(
      ::google::protobuf::internal::ConstantInitialized);

  inline TranslatedImage(const TranslatedImage& from) : TranslatedImage(nullptr, from) {}
  inline TranslatedImage(TranslatedImage&& from) noexcept
      : TranslatedImage(nullptr, std::move(from)) {}
  inline TranslatedImage& operator=(const TranslatedImage& from) {
    CopyFrom(from);
    return *this;
  }
  inline TranslatedImage& operator=(TranslatedImage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TranslatedImage& default_instance() {
    return *internal_default_instance();
  }
  static inline const TranslatedImage* internal_default_instance() {
    return reinterpret_cast<const TranslatedImage*>(
        &_TranslatedImage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(TranslatedImage& a, TranslatedImage& b) { a.Swap(&b); }
  inline void Swap(TranslatedImage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TranslatedImage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TranslatedImage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TranslatedImage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TranslatedImage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TranslatedImage& from) { TranslatedImage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TranslatedImage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "transit_realtime.TranslatedImage"; }

 protected:
  explicit TranslatedImage(::google::protobuf::Arena* arena);
  TranslatedImage(::google::protobuf::Arena* arena, const TranslatedImage& from);
  TranslatedImage(::google::protobuf::Arena* arena, TranslatedImage&& from) noexcept
      : TranslatedImage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using LocalizedImage = TranslatedImage_LocalizedImage;

  // accessors -------------------------------------------------------
  enum : int {
    kLocalizedImageFieldNumber = 1,
  };
  // repeated .transit_realtime.TranslatedImage.LocalizedImage localized_image = 1;
  int localized_image_size() const;
  private:
  int _internal_localized_image_size() const;

  public:
  void clear_localized_image() ;
  ::transit_realtime::TranslatedImage_LocalizedImage* mutable_localized_image(int index);
  ::google::protobuf::RepeatedPtrField<::transit_realtime::TranslatedImage_LocalizedImage>* mutable_localized_image();

  private:
  const ::google::protobuf::RepeatedPtrField<::transit_realtime::TranslatedImage_LocalizedImage>& _internal_localized_image() const;
  ::google::protobuf::RepeatedPtrField<::transit_realtime::TranslatedImage_LocalizedImage>* _internal_mutable_localized_image();
  public:
  const ::transit_realtime::TranslatedImage_LocalizedImage& localized_image(int index) const;
  ::transit_realtime::TranslatedImage_LocalizedImage* add_localized_image();
  const ::google::protobuf::RepeatedPtrField<::transit_realtime::TranslatedImage_LocalizedImage>& localized_image() const;
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedImage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedImage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedImage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedImage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedImage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedImage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedImage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedImage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedImage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<TranslatedImage, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedImage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedImage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedImage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedImage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedImage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedImage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedImage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedImage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TranslatedImage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:transit_realtime.TranslatedImage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TranslatedImage& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::RepeatedPtrField< ::transit_realtime::TranslatedImage_LocalizedImage > localized_image_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class VehiclePosition final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:transit_realtime.VehiclePosition) */ {
 public:
  inline VehiclePosition() : VehiclePosition(nullptr) {}
  ~VehiclePosition() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(VehiclePosition* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(VehiclePosition));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR VehiclePosition(
      ::google::protobuf::internal::ConstantInitialized);

  inline VehiclePosition(const VehiclePosition& from) : VehiclePosition(nullptr, from) {}
  inline VehiclePosition(VehiclePosition&& from) noexcept
      : VehiclePosition(nullptr, std::move(from)) {}
  inline VehiclePosition& operator=(const VehiclePosition& from) {
    CopyFrom(from);
    return *this;
  }
  inline VehiclePosition& operator=(VehiclePosition&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VehiclePosition& default_instance() {
    return *internal_default_instance();
  }
  static inline const VehiclePosition* internal_default_instance() {
    return reinterpret_cast<const VehiclePosition*>(
        &_VehiclePosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(VehiclePosition& a, VehiclePosition& b) { a.Swap(&b); }
  inline void Swap(VehiclePosition* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VehiclePosition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VehiclePosition* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<VehiclePosition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VehiclePosition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const VehiclePosition& from) { VehiclePosition::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(VehiclePosition* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "transit_realtime.VehiclePosition"; }

 protected:
  explicit VehiclePosition(::google::protobuf::Arena* arena);
  VehiclePosition(::google::protobuf::Arena* arena, const VehiclePosition& from);
  VehiclePosition(::google::protobuf::Arena* arena, VehiclePosition&& from) noexcept
      : VehiclePosition(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using CarriageDetails = VehiclePosition_CarriageDetails;
  using VehicleStopStatus = VehiclePosition_VehicleStopStatus;
  static constexpr VehicleStopStatus INCOMING_AT = VehiclePosition_VehicleStopStatus_INCOMING_AT;
  static constexpr VehicleStopStatus STOPPED_AT = VehiclePosition_VehicleStopStatus_STOPPED_AT;
  static constexpr VehicleStopStatus IN_TRANSIT_TO = VehiclePosition_VehicleStopStatus_IN_TRANSIT_TO;
  static inline bool VehicleStopStatus_IsValid(int value) {
    return VehiclePosition_VehicleStopStatus_IsValid(value);
  }
  static constexpr VehicleStopStatus VehicleStopStatus_MIN = VehiclePosition_VehicleStopStatus_VehicleStopStatus_MIN;
  static constexpr VehicleStopStatus VehicleStopStatus_MAX = VehiclePosition_VehicleStopStatus_VehicleStopStatus_MAX;
  static constexpr int VehicleStopStatus_ARRAYSIZE = VehiclePosition_VehicleStopStatus_VehicleStopStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* VehicleStopStatus_descriptor() {
    return VehiclePosition_VehicleStopStatus_descriptor();
  }
  template <typename T>
  static inline const std::string& VehicleStopStatus_Name(T value) {
    return VehiclePosition_VehicleStopStatus_Name(value);
  }
  static inline bool VehicleStopStatus_Parse(absl::string_view name, VehicleStopStatus* value) {
    return VehiclePosition_VehicleStopStatus_Parse(name, value);
  }
  using CongestionLevel = VehiclePosition_CongestionLevel;
  static constexpr CongestionLevel UNKNOWN_CONGESTION_LEVEL = VehiclePosition_CongestionLevel_UNKNOWN_CONGESTION_LEVEL;
  static constexpr CongestionLevel RUNNING_SMOOTHLY = VehiclePosition_CongestionLevel_RUNNING_SMOOTHLY;
  static constexpr CongestionLevel STOP_AND_GO = VehiclePosition_CongestionLevel_STOP_AND_GO;
  static constexpr CongestionLevel CONGESTION = VehiclePosition_CongestionLevel_CONGESTION;
  static constexpr CongestionLevel SEVERE_CONGESTION = VehiclePosition_CongestionLevel_SEVERE_CONGESTION;
  static inline bool CongestionLevel_IsValid(int value) {
    return VehiclePosition_CongestionLevel_IsValid(value);
  }
  static constexpr CongestionLevel CongestionLevel_MIN = VehiclePosition_CongestionLevel_CongestionLevel_MIN;
  static constexpr CongestionLevel CongestionLevel_MAX = VehiclePosition_CongestionLevel_CongestionLevel_MAX;
  static constexpr int CongestionLevel_ARRAYSIZE = VehiclePosition_CongestionLevel_CongestionLevel_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* CongestionLevel_descriptor() {
    return VehiclePosition_CongestionLevel_descriptor();
  }
  template <typename T>
  static inline const std::string& CongestionLevel_Name(T value) {
    return VehiclePosition_CongestionLevel_Name(value);
  }
  static inline bool CongestionLevel_Parse(absl::string_view name, CongestionLevel* value) {
    return VehiclePosition_CongestionLevel_Parse(name, value);
  }
  using OccupancyStatus = VehiclePosition_OccupancyStatus;
  static constexpr OccupancyStatus EMPTY = VehiclePosition_OccupancyStatus_EMPTY;
  static constexpr OccupancyStatus MANY_SEATS_AVAILABLE = VehiclePosition_OccupancyStatus_MANY_SEATS_AVAILABLE;
  static constexpr OccupancyStatus FEW_SEATS_AVAILABLE = VehiclePosition_OccupancyStatus_FEW_SEATS_AVAILABLE;
  static constexpr OccupancyStatus STANDING_ROOM_ONLY = VehiclePosition_OccupancyStatus_STANDING_ROOM_ONLY;
  static constexpr OccupancyStatus CRUSHED_STANDING_ROOM_ONLY = VehiclePosition_OccupancyStatus_CRUSHED_STANDING_ROOM_ONLY;
  static constexpr OccupancyStatus FULL = VehiclePosition_OccupancyStatus_FULL;
  static constexpr OccupancyStatus NOT_ACCEPTING_PASSENGERS = VehiclePosition_OccupancyStatus_NOT_ACCEPTING_PASSENGERS;
  static constexpr OccupancyStatus NO_DATA_AVAILABLE = VehiclePosition_OccupancyStatus_NO_DATA_AVAILABLE;
  static constexpr OccupancyStatus NOT_BOARDABLE = VehiclePosition_OccupancyStatus_NOT_BOARDABLE;
  static inline bool OccupancyStatus_IsValid(int value) {
    return VehiclePosition_OccupancyStatus_IsValid(value);
  }
  static constexpr OccupancyStatus OccupancyStatus_MIN = VehiclePosition_OccupancyStatus_OccupancyStatus_MIN;
  static constexpr OccupancyStatus OccupancyStatus_MAX = VehiclePosition_OccupancyStatus_OccupancyStatus_MAX;
  static constexpr int OccupancyStatus_ARRAYSIZE = VehiclePosition_OccupancyStatus_OccupancyStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* OccupancyStatus_descriptor() {
    return VehiclePosition_OccupancyStatus_descriptor();
  }
  template <typename T>
  static inline const std::string& OccupancyStatus_Name(T value) {
    return VehiclePosition_OccupancyStatus_Name(value);
  }
  static inline bool OccupancyStatus_Parse(absl::string_view name, OccupancyStatus* value) {
    return VehiclePosition_OccupancyStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kMultiCarriageDetailsFieldNumber = 11,
    kStopIdFieldNumber = 7,
    kTripFieldNumber = 1,
    kPositionFieldNumber = 2,
    kVehicleFieldNumber = 8,
    kCurrentStopSequenceFieldNumber = 3,
    kCongestionLevelFieldNumber = 6,
    kTimestampFieldNumber = 5,
    kOccupancyStatusFieldNumber = 9,
    kOccupancyPercentageFieldNumber = 10,
    kCurrentStatusFieldNumber = 4,
  };
  // repeated .transit_realtime.VehiclePosition.CarriageDetails multi_carriage_details = 11;
  int multi_carriage_details_size() const;
  private:
  int _internal_multi_carriage_details_size() const;

  public:
  void clear_multi_carriage_details() ;
  ::transit_realtime::VehiclePosition_CarriageDetails* mutable_multi_carriage_details(int index);
  ::google::protobuf::RepeatedPtrField<::transit_realtime::VehiclePosition_CarriageDetails>* mutable_multi_carriage_details();

  private:
  const ::google::protobuf::RepeatedPtrField<::transit_realtime::VehiclePosition_CarriageDetails>& _internal_multi_carriage_details() const;
  ::google::protobuf::RepeatedPtrField<::transit_realtime::VehiclePosition_CarriageDetails>* _internal_mutable_multi_carriage_details();
  public:
  const ::transit_realtime::VehiclePosition_CarriageDetails& multi_carriage_details(int index) const;
  ::transit_realtime::VehiclePosition_CarriageDetails* add_multi_carriage_details();
  const ::google::protobuf::RepeatedPtrField<::transit_realtime::VehiclePosition_CarriageDetails>& multi_carriage_details() const;
  // optional string stop_id = 7;
  bool has_stop_id() const;
  void clear_stop_id() ;
  const std::string& stop_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_stop_id(Arg_&& arg, Args_... args);
  std::string* mutable_stop_id();
  PROTOBUF_NODISCARD std::string* release_stop_id();
  void set_allocated_stop_id(std::string* value);

  private:
  const std::string& _internal_stop_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stop_id(
      const std::string& value);
  std::string* _internal_mutable_stop_id();

  public:
  // optional .transit_realtime.TripDescriptor trip = 1;
  bool has_trip() const;
  void clear_trip() ;
  const ::transit_realtime::TripDescriptor& trip() const;
  PROTOBUF_NODISCARD ::transit_realtime::TripDescriptor* release_trip();
  ::transit_realtime::TripDescriptor* mutable_trip();
  void set_allocated_trip(::transit_realtime::TripDescriptor* value);
  void unsafe_arena_set_allocated_trip(::transit_realtime::TripDescriptor* value);
  ::transit_realtime::TripDescriptor* unsafe_arena_release_trip();

  private:
  const ::transit_realtime::TripDescriptor& _internal_trip() const;
  ::transit_realtime::TripDescriptor* _internal_mutable_trip();

  public:
  // optional .transit_realtime.Position position = 2;
  bool has_position() const;
  void clear_position() ;
  const ::transit_realtime::Position& position() const;
  PROTOBUF_NODISCARD ::transit_realtime::Position* release_position();
  ::transit_realtime::Position* mutable_position();
  void set_allocated_position(::transit_realtime::Position* value);
  void unsafe_arena_set_allocated_position(::transit_realtime::Position* value);
  ::transit_realtime::Position* unsafe_arena_release_position();

  private:
  const ::transit_realtime::Position& _internal_position() const;
  ::transit_realtime::Position* _internal_mutable_position();

  public:
  // optional .transit_realtime.VehicleDescriptor vehicle = 8;
  bool has_vehicle() const;
  void clear_vehicle() ;
  const ::transit_realtime::VehicleDescriptor& vehicle() const;
  PROTOBUF_NODISCARD ::transit_realtime::VehicleDescriptor* release_vehicle();
  ::transit_realtime::VehicleDescriptor* mutable_vehicle();
  void set_allocated_vehicle(::transit_realtime::VehicleDescriptor* value);
  void unsafe_arena_set_allocated_vehicle(::transit_realtime::VehicleDescriptor* value);
  ::transit_realtime::VehicleDescriptor* unsafe_arena_release_vehicle();

  private:
  const ::transit_realtime::VehicleDescriptor& _internal_vehicle() const;
  ::transit_realtime::VehicleDescriptor* _internal_mutable_vehicle();

  public:
  // optional uint32 current_stop_sequence = 3;
  bool has_current_stop_sequence() const;
  void clear_current_stop_sequence() ;
  ::uint32_t current_stop_sequence() const;
  void set_current_stop_sequence(::uint32_t value);

  private:
  ::uint32_t _internal_current_stop_sequence() const;
  void _internal_set_current_stop_sequence(::uint32_t value);

  public:
  // optional .transit_realtime.VehiclePosition.CongestionLevel congestion_level = 6;
  bool has_congestion_level() const;
  void clear_congestion_level() ;
  ::transit_realtime::VehiclePosition_CongestionLevel congestion_level() const;
  void set_congestion_level(::transit_realtime::VehiclePosition_CongestionLevel value);

  private:
  ::transit_realtime::VehiclePosition_CongestionLevel _internal_congestion_level() const;
  void _internal_set_congestion_level(::transit_realtime::VehiclePosition_CongestionLevel value);

  public:
  // optional uint64 timestamp = 5;
  bool has_timestamp() const;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 9;
  bool has_occupancy_status() const;
  void clear_occupancy_status() ;
  ::transit_realtime::VehiclePosition_OccupancyStatus occupancy_status() const;
  void set_occupancy_status(::transit_realtime::VehiclePosition_OccupancyStatus value);

  private:
  ::transit_realtime::VehiclePosition_OccupancyStatus _internal_occupancy_status() const;
  void _internal_set_occupancy_status(::transit_realtime::VehiclePosition_OccupancyStatus value);

  public:
  // optional uint32 occupancy_percentage = 10;
  bool has_occupancy_percentage() const;
  void clear_occupancy_percentage() ;
  ::uint32_t occupancy_percentage() const;
  void set_occupancy_percentage(::uint32_t value);

  private:
  ::uint32_t _internal_occupancy_percentage() const;
  void _internal_set_occupancy_percentage(::uint32_t value);

  public:
  // optional .transit_realtime.VehiclePosition.VehicleStopStatus current_status = 4 [default = IN_TRANSIT_TO];
  bool has_current_status() const;
  void clear_current_status() ;
  ::transit_realtime::VehiclePosition_VehicleStopStatus current_status() const;
  void set_current_status(::transit_realtime::VehiclePosition_VehicleStopStatus value);

  private:
  ::transit_realtime::VehiclePosition_VehicleStopStatus _internal_current_status() const;
  void _internal_set_current_status(::transit_realtime::VehiclePosition_VehicleStopStatus value);

  public:
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehiclePosition, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehiclePosition, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<VehiclePosition, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehiclePosition, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehiclePosition, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehiclePosition, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehiclePosition, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehiclePosition, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehiclePosition, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<VehiclePosition, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehiclePosition, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehiclePosition, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehiclePosition, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehiclePosition, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehiclePosition, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehiclePosition, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehiclePosition, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehiclePosition, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<VehiclePosition, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:transit_realtime.VehiclePosition)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 11, 7,
      56, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const VehiclePosition& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::transit_realtime::VehiclePosition_CarriageDetails > multi_carriage_details_;
    ::google::protobuf::internal::ArenaStringPtr stop_id_;
    ::transit_realtime::TripDescriptor* trip_;
    ::transit_realtime::Position* position_;
    ::transit_realtime::VehicleDescriptor* vehicle_;
    ::uint32_t current_stop_sequence_;
    int congestion_level_;
    ::uint64_t timestamp_;
    int occupancy_status_;
    ::uint32_t occupancy_percentage_;
    int current_status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class TripUpdate final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:transit_realtime.TripUpdate) */ {
 public:
  inline TripUpdate() : TripUpdate(nullptr) {}
  ~TripUpdate() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TripUpdate* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TripUpdate));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TripUpdate(
      ::google::protobuf::internal::ConstantInitialized);

  inline TripUpdate(const TripUpdate& from) : TripUpdate(nullptr, from) {}
  inline TripUpdate(TripUpdate&& from) noexcept
      : TripUpdate(nullptr, std::move(from)) {}
  inline TripUpdate& operator=(const TripUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripUpdate& operator=(TripUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TripUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripUpdate* internal_default_instance() {
    return reinterpret_cast<const TripUpdate*>(
        &_TripUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(TripUpdate& a, TripUpdate& b) { a.Swap(&b); }
  inline void Swap(TripUpdate* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripUpdate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripUpdate* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TripUpdate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TripUpdate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TripUpdate& from) { TripUpdate::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TripUpdate* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "transit_realtime.TripUpdate"; }

 protected:
  explicit TripUpdate(::google::protobuf::Arena* arena);
  TripUpdate(::google::protobuf::Arena* arena, const TripUpdate& from);
  TripUpdate(::google::protobuf::Arena* arena, TripUpdate&& from) noexcept
      : TripUpdate(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using StopTimeEvent = TripUpdate_StopTimeEvent;
  using StopTimeUpdate = TripUpdate_StopTimeUpdate;
  using TripProperties = TripUpdate_TripProperties;

  // accessors -------------------------------------------------------
  enum : int {
    kStopTimeUpdateFieldNumber = 2,
    kTripFieldNumber = 1,
    kVehicleFieldNumber = 3,
    kTripPropertiesFieldNumber = 6,
    kTimestampFieldNumber = 4,
    kDelayFieldNumber = 5,
  };
  // repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;
  int stop_time_update_size() const;
  private:
  int _internal_stop_time_update_size() const;

  public:
  void clear_stop_time_update() ;
  ::transit_realtime::TripUpdate_StopTimeUpdate* mutable_stop_time_update(int index);
  ::google::protobuf::RepeatedPtrField<::transit_realtime::TripUpdate_StopTimeUpdate>* mutable_stop_time_update();

  private:
  const ::google::protobuf::RepeatedPtrField<::transit_realtime::TripUpdate_StopTimeUpdate>& _internal_stop_time_update() const;
  ::google::protobuf::RepeatedPtrField<::transit_realtime::TripUpdate_StopTimeUpdate>* _internal_mutable_stop_time_update();
  public:
  const ::transit_realtime::TripUpdate_StopTimeUpdate& stop_time_update(int index) const;
  ::transit_realtime::TripUpdate_StopTimeUpdate* add_stop_time_update();
  const ::google::protobuf::RepeatedPtrField<::transit_realtime::TripUpdate_StopTimeUpdate>& stop_time_update() const;
  // required .transit_realtime.TripDescriptor trip = 1;
  bool has_trip() const;
  void clear_trip() ;
  const ::transit_realtime::TripDescriptor& trip() const;
  PROTOBUF_NODISCARD ::transit_realtime::TripDescriptor* release_trip();
  ::transit_realtime::TripDescriptor* mutable_trip();
  void set_allocated_trip(::transit_realtime::TripDescriptor* value);
  void unsafe_arena_set_allocated_trip(::transit_realtime::TripDescriptor* value);
  ::transit_realtime::TripDescriptor* unsafe_arena_release_trip();

  private:
  const ::transit_realtime::TripDescriptor& _internal_trip() const;
  ::transit_realtime::TripDescriptor* _internal_mutable_trip();

  public:
  // optional .transit_realtime.VehicleDescriptor vehicle = 3;
  bool has_vehicle() const;
  void clear_vehicle() ;
  const ::transit_realtime::VehicleDescriptor& vehicle() const;
  PROTOBUF_NODISCARD ::transit_realtime::VehicleDescriptor* release_vehicle();
  ::transit_realtime::VehicleDescriptor* mutable_vehicle();
  void set_allocated_vehicle(::transit_realtime::VehicleDescriptor* value);
  void unsafe_arena_set_allocated_vehicle(::transit_realtime::VehicleDescriptor* value);
  ::transit_realtime::VehicleDescriptor* unsafe_arena_release_vehicle();

  private:
  const ::transit_realtime::VehicleDescriptor& _internal_vehicle() const;
  ::transit_realtime::VehicleDescriptor* _internal_mutable_vehicle();

  public:
  // optional .transit_realtime.TripUpdate.TripProperties trip_properties = 6;
  bool has_trip_properties() const;
  void clear_trip_properties() ;
  const ::transit_realtime::TripUpdate_TripProperties& trip_properties() const;
  PROTOBUF_NODISCARD ::transit_realtime::TripUpdate_TripProperties* release_trip_properties();
  ::transit_realtime::TripUpdate_TripProperties* mutable_trip_properties();
  void set_allocated_trip_properties(::transit_realtime::TripUpdate_TripProperties* value);
  void unsafe_arena_set_allocated_trip_properties(::transit_realtime::TripUpdate_TripProperties* value);
  ::transit_realtime::TripUpdate_TripProperties* unsafe_arena_release_trip_properties();

  private:
  const ::transit_realtime::TripUpdate_TripProperties& _internal_trip_properties() const;
  ::transit_realtime::TripUpdate_TripProperties* _internal_mutable_trip_properties();

  public:
  // optional uint64 timestamp = 4;
  bool has_timestamp() const;
  void clear_timestamp() ;
  ::uint64_t timestamp() const;
  void set_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(::uint64_t value);

  public:
  // optional int32 delay = 5;
  bool has_delay() const;
  void clear_delay() ;
  ::int32_t delay() const;
  void set_delay(::int32_t value);

  private:
  ::int32_t _internal_delay() const;
  void _internal_set_delay(::int32_t value);

  public:
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripUpdate, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:transit_realtime.TripUpdate)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 4,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TripUpdate& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::transit_realtime::TripUpdate_StopTimeUpdate > stop_time_update_;
    ::transit_realtime::TripDescriptor* trip_;
    ::transit_realtime::VehicleDescriptor* vehicle_;
    ::transit_realtime::TripUpdate_TripProperties* trip_properties_;
    ::uint64_t timestamp_;
    ::int32_t delay_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class TripModifications final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:transit_realtime.TripModifications) */ {
 public:
  inline TripModifications() : TripModifications(nullptr) {}
  ~TripModifications() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TripModifications* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TripModifications));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TripModifications(
      ::google::protobuf::internal::ConstantInitialized);

  inline TripModifications(const TripModifications& from) : TripModifications(nullptr, from) {}
  inline TripModifications(TripModifications&& from) noexcept
      : TripModifications(nullptr, std::move(from)) {}
  inline TripModifications& operator=(const TripModifications& from) {
    CopyFrom(from);
    return *this;
  }
  inline TripModifications& operator=(TripModifications&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TripModifications& default_instance() {
    return *internal_default_instance();
  }
  static inline const TripModifications* internal_default_instance() {
    return reinterpret_cast<const TripModifications*>(
        &_TripModifications_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(TripModifications& a, TripModifications& b) { a.Swap(&b); }
  inline void Swap(TripModifications* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TripModifications* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TripModifications* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TripModifications>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TripModifications& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TripModifications& from) { TripModifications::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TripModifications* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "transit_realtime.TripModifications"; }

 protected:
  explicit TripModifications(::google::protobuf::Arena* arena);
  TripModifications(::google::protobuf::Arena* arena, const TripModifications& from);
  TripModifications(::google::protobuf::Arena* arena, TripModifications&& from) noexcept
      : TripModifications(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Modification = TripModifications_Modification;
  using SelectedTrips = TripModifications_SelectedTrips;

  // accessors -------------------------------------------------------
  enum : int {
    kSelectedTripsFieldNumber = 1,
    kStartTimesFieldNumber = 2,
    kServiceDatesFieldNumber = 3,
    kModificationsFieldNumber = 4,
  };
  // repeated .transit_realtime.TripModifications.SelectedTrips selected_trips = 1;
  int selected_trips_size() const;
  private:
  int _internal_selected_trips_size() const;

  public:
  void clear_selected_trips() ;
  ::transit_realtime::TripModifications_SelectedTrips* mutable_selected_trips(int index);
  ::google::protobuf::RepeatedPtrField<::transit_realtime::TripModifications_SelectedTrips>* mutable_selected_trips();

  private:
  const ::google::protobuf::RepeatedPtrField<::transit_realtime::TripModifications_SelectedTrips>& _internal_selected_trips() const;
  ::google::protobuf::RepeatedPtrField<::transit_realtime::TripModifications_SelectedTrips>* _internal_mutable_selected_trips();
  public:
  const ::transit_realtime::TripModifications_SelectedTrips& selected_trips(int index) const;
  ::transit_realtime::TripModifications_SelectedTrips* add_selected_trips();
  const ::google::protobuf::RepeatedPtrField<::transit_realtime::TripModifications_SelectedTrips>& selected_trips() const;
  // repeated string start_times = 2;
  int start_times_size() const;
  private:
  int _internal_start_times_size() const;

  public:
  void clear_start_times() ;
  const std::string& start_times(int index) const;
  std::string* mutable_start_times(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_start_times(int index, Arg_&& value, Args_... args);
  std::string* add_start_times();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_start_times(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& start_times() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_start_times();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_start_times() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_start_times();

  public:
  // repeated string service_dates = 3;
  int service_dates_size() const;
  private:
  int _internal_service_dates_size() const;

  public:
  void clear_service_dates() ;
  const std::string& service_dates(int index) const;
  std::string* mutable_service_dates(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_service_dates(int index, Arg_&& value, Args_... args);
  std::string* add_service_dates();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_service_dates(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& service_dates() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_service_dates();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_service_dates() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_service_dates();

  public:
  // repeated .transit_realtime.TripModifications.Modification modifications = 4;
  int modifications_size() const;
  private:
  int _internal_modifications_size() const;

  public:
  void clear_modifications() ;
  ::transit_realtime::TripModifications_Modification* mutable_modifications(int index);
  ::google::protobuf::RepeatedPtrField<::transit_realtime::TripModifications_Modification>* mutable_modifications();

  private:
  const ::google::protobuf::RepeatedPtrField<::transit_realtime::TripModifications_Modification>& _internal_modifications() const;
  ::google::protobuf::RepeatedPtrField<::transit_realtime::TripModifications_Modification>* _internal_mutable_modifications();
  public:
  const ::transit_realtime::TripModifications_Modification& modifications(int index) const;
  ::transit_realtime::TripModifications_Modification* add_modifications();
  const ::google::protobuf::RepeatedPtrField<::transit_realtime::TripModifications_Modification>& modifications() const;
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<TripModifications, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<TripModifications, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:transit_realtime.TripModifications)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      67, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TripModifications& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::RepeatedPtrField< ::transit_realtime::TripModifications_SelectedTrips > selected_trips_;
    ::google::protobuf::RepeatedPtrField<std::string> start_times_;
    ::google::protobuf::RepeatedPtrField<std::string> service_dates_;
    ::google::protobuf::RepeatedPtrField< ::transit_realtime::TripModifications_Modification > modifications_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class Stop final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:transit_realtime.Stop) */ {
 public:
  inline Stop() : Stop(nullptr) {}
  ~Stop() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Stop* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Stop));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Stop(
      ::google::protobuf::internal::ConstantInitialized);

  inline Stop(const Stop& from) : Stop(nullptr, from) {}
  inline Stop(Stop&& from) noexcept
      : Stop(nullptr, std::move(from)) {}
  inline Stop& operator=(const Stop& from) {
    CopyFrom(from);
    return *this;
  }
  inline Stop& operator=(Stop&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Stop& default_instance() {
    return *internal_default_instance();
  }
  static inline const Stop* internal_default_instance() {
    return reinterpret_cast<const Stop*>(
        &_Stop_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(Stop& a, Stop& b) { a.Swap(&b); }
  inline void Swap(Stop* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Stop* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Stop* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Stop>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Stop& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Stop& from) { Stop::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Stop* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "transit_realtime.Stop"; }

 protected:
  explicit Stop(::google::protobuf::Arena* arena);
  Stop(::google::protobuf::Arena* arena, const Stop& from);
  Stop(::google::protobuf::Arena* arena, Stop&& from) noexcept
      : Stop(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using WheelchairBoarding = Stop_WheelchairBoarding;
  static constexpr WheelchairBoarding UNKNOWN = Stop_WheelchairBoarding_UNKNOWN;
  static constexpr WheelchairBoarding AVAILABLE = Stop_WheelchairBoarding_AVAILABLE;
  static constexpr WheelchairBoarding NOT_AVAILABLE = Stop_WheelchairBoarding_NOT_AVAILABLE;
  static inline bool WheelchairBoarding_IsValid(int value) {
    return Stop_WheelchairBoarding_IsValid(value);
  }
  static constexpr WheelchairBoarding WheelchairBoarding_MIN = Stop_WheelchairBoarding_WheelchairBoarding_MIN;
  static constexpr WheelchairBoarding WheelchairBoarding_MAX = Stop_WheelchairBoarding_WheelchairBoarding_MAX;
  static constexpr int WheelchairBoarding_ARRAYSIZE = Stop_WheelchairBoarding_WheelchairBoarding_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* WheelchairBoarding_descriptor() {
    return Stop_WheelchairBoarding_descriptor();
  }
  template <typename T>
  static inline const std::string& WheelchairBoarding_Name(T value) {
    return Stop_WheelchairBoarding_Name(value);
  }
  static inline bool WheelchairBoarding_Parse(absl::string_view name, WheelchairBoarding* value) {
    return Stop_WheelchairBoarding_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kStopIdFieldNumber = 1,
    kZoneIdFieldNumber = 8,
    kParentStationFieldNumber = 11,
    kStopTimezoneFieldNumber = 12,
    kLevelIdFieldNumber = 14,
    kStopCodeFieldNumber = 2,
    kStopNameFieldNumber = 3,
    kTtsStopNameFieldNumber = 4,
    kStopDescFieldNumber = 5,
    kStopUrlFieldNumber = 9,
    kPlatformCodeFieldNumber = 15,
    kStopLatFieldNumber = 6,
    kStopLonFieldNumber = 7,
    kWheelchairBoardingFieldNumber = 13,
  };
  // optional string stop_id = 1;
  bool has_stop_id() const;
  void clear_stop_id() ;
  const std::string& stop_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_stop_id(Arg_&& arg, Args_... args);
  std::string* mutable_stop_id();
  PROTOBUF_NODISCARD std::string* release_stop_id();
  void set_allocated_stop_id(std::string* value);

  private:
  const std::string& _internal_stop_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stop_id(
      const std::string& value);
  std::string* _internal_mutable_stop_id();

  public:
  // optional string zone_id = 8;
  bool has_zone_id() const;
  void clear_zone_id() ;
  const std::string& zone_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_zone_id(Arg_&& arg, Args_... args);
  std::string* mutable_zone_id();
  PROTOBUF_NODISCARD std::string* release_zone_id();
  void set_allocated_zone_id(std::string* value);

  private:
  const std::string& _internal_zone_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_zone_id(
      const std::string& value);
  std::string* _internal_mutable_zone_id();

  public:
  // optional string parent_station = 11;
  bool has_parent_station() const;
  void clear_parent_station() ;
  const std::string& parent_station() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_parent_station(Arg_&& arg, Args_... args);
  std::string* mutable_parent_station();
  PROTOBUF_NODISCARD std::string* release_parent_station();
  void set_allocated_parent_station(std::string* value);

  private:
  const std::string& _internal_parent_station() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_station(
      const std::string& value);
  std::string* _internal_mutable_parent_station();

  public:
  // optional string stop_timezone = 12;
  bool has_stop_timezone() const;
  void clear_stop_timezone() ;
  const std::string& stop_timezone() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_stop_timezone(Arg_&& arg, Args_... args);
  std::string* mutable_stop_timezone();
  PROTOBUF_NODISCARD std::string* release_stop_timezone();
  void set_allocated_stop_timezone(std::string* value);

  private:
  const std::string& _internal_stop_timezone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stop_timezone(
      const std::string& value);
  std::string* _internal_mutable_stop_timezone();

  public:
  // optional string level_id = 14;
  bool has_level_id() const;
  void clear_level_id() ;
  const std::string& level_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_level_id(Arg_&& arg, Args_... args);
  std::string* mutable_level_id();
  PROTOBUF_NODISCARD std::string* release_level_id();
  void set_allocated_level_id(std::string* value);

  private:
  const std::string& _internal_level_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_level_id(
      const std::string& value);
  std::string* _internal_mutable_level_id();

  public:
  // optional .transit_realtime.TranslatedString stop_code = 2;
  bool has_stop_code() const;
  void clear_stop_code() ;
  const ::transit_realtime::TranslatedString& stop_code() const;
  PROTOBUF_NODISCARD ::transit_realtime::TranslatedString* release_stop_code();
  ::transit_realtime::TranslatedString* mutable_stop_code();
  void set_allocated_stop_code(::transit_realtime::TranslatedString* value);
  void unsafe_arena_set_allocated_stop_code(::transit_realtime::TranslatedString* value);
  ::transit_realtime::TranslatedString* unsafe_arena_release_stop_code();

  private:
  const ::transit_realtime::TranslatedString& _internal_stop_code() const;
  ::transit_realtime::TranslatedString* _internal_mutable_stop_code();

  public:
  // optional .transit_realtime.TranslatedString stop_name = 3;
  bool has_stop_name() const;
  void clear_stop_name() ;
  const ::transit_realtime::TranslatedString& stop_name() const;
  PROTOBUF_NODISCARD ::transit_realtime::TranslatedString* release_stop_name();
  ::transit_realtime::TranslatedString* mutable_stop_name();
  void set_allocated_stop_name(::transit_realtime::TranslatedString* value);
  void unsafe_arena_set_allocated_stop_name(::transit_realtime::TranslatedString* value);
  ::transit_realtime::TranslatedString* unsafe_arena_release_stop_name();

  private:
  const ::transit_realtime::TranslatedString& _internal_stop_name() const;
  ::transit_realtime::TranslatedString* _internal_mutable_stop_name();

  public:
  // optional .transit_realtime.TranslatedString tts_stop_name = 4;
  bool has_tts_stop_name() const;
  void clear_tts_stop_name() ;
  const ::transit_realtime::TranslatedString& tts_stop_name() const;
  PROTOBUF_NODISCARD ::transit_realtime::TranslatedString* release_tts_stop_name();
  ::transit_realtime::TranslatedString* mutable_tts_stop_name();
  void set_allocated_tts_stop_name(::transit_realtime::TranslatedString* value);
  void unsafe_arena_set_allocated_tts_stop_name(::transit_realtime::TranslatedString* value);
  ::transit_realtime::TranslatedString* unsafe_arena_release_tts_stop_name();

  private:
  const ::transit_realtime::TranslatedString& _internal_tts_stop_name() const;
  ::transit_realtime::TranslatedString* _internal_mutable_tts_stop_name();

  public:
  // optional .transit_realtime.TranslatedString stop_desc = 5;
  bool has_stop_desc() const;
  void clear_stop_desc() ;
  const ::transit_realtime::TranslatedString& stop_desc() const;
  PROTOBUF_NODISCARD ::transit_realtime::TranslatedString* release_stop_desc();
  ::transit_realtime::TranslatedString* mutable_stop_desc();
  void set_allocated_stop_desc(::transit_realtime::TranslatedString* value);
  void unsafe_arena_set_allocated_stop_desc(::transit_realtime::TranslatedString* value);
  ::transit_realtime::TranslatedString* unsafe_arena_release_stop_desc();

  private:
  const ::transit_realtime::TranslatedString& _internal_stop_desc() const;
  ::transit_realtime::TranslatedString* _internal_mutable_stop_desc();

  public:
  // optional .transit_realtime.TranslatedString stop_url = 9;
  bool has_stop_url() const;
  void clear_stop_url() ;
  const ::transit_realtime::TranslatedString& stop_url() const;
  PROTOBUF_NODISCARD ::transit_realtime::TranslatedString* release_stop_url();
  ::transit_realtime::TranslatedString* mutable_stop_url();
  void set_allocated_stop_url(::transit_realtime::TranslatedString* value);
  void unsafe_arena_set_allocated_stop_url(::transit_realtime::TranslatedString* value);
  ::transit_realtime::TranslatedString* unsafe_arena_release_stop_url();

  private:
  const ::transit_realtime::TranslatedString& _internal_stop_url() const;
  ::transit_realtime::TranslatedString* _internal_mutable_stop_url();

  public:
  // optional .transit_realtime.TranslatedString platform_code = 15;
  bool has_platform_code() const;
  void clear_platform_code() ;
  const ::transit_realtime::TranslatedString& platform_code() const;
  PROTOBUF_NODISCARD ::transit_realtime::TranslatedString* release_platform_code();
  ::transit_realtime::TranslatedString* mutable_platform_code();
  void set_allocated_platform_code(::transit_realtime::TranslatedString* value);
  void unsafe_arena_set_allocated_platform_code(::transit_realtime::TranslatedString* value);
  ::transit_realtime::TranslatedString* unsafe_arena_release_platform_code();

  private:
  const ::transit_realtime::TranslatedString& _internal_platform_code() const;
  ::transit_realtime::TranslatedString* _internal_mutable_platform_code();

  public:
  // optional float stop_lat = 6;
  bool has_stop_lat() const;
  void clear_stop_lat() ;
  float stop_lat() const;
  void set_stop_lat(float value);

  private:
  float _internal_stop_lat() const;
  void _internal_set_stop_lat(float value);

  public:
  // optional float stop_lon = 7;
  bool has_stop_lon() const;
  void clear_stop_lon() ;
  float stop_lon() const;
  void set_stop_lon(float value);

  private:
  float _internal_stop_lon() const;
  void _internal_set_stop_lon(float value);

  public:
  // optional .transit_realtime.Stop.WheelchairBoarding wheelchair_boarding = 13 [default = UNKNOWN];
  bool has_wheelchair_boarding() const;
  void clear_wheelchair_boarding() ;
  ::transit_realtime::Stop_WheelchairBoarding wheelchair_boarding() const;
  void set_wheelchair_boarding(::transit_realtime::Stop_WheelchairBoarding value);

  private:
  ::transit_realtime::Stop_WheelchairBoarding _internal_wheelchair_boarding() const;
  void _internal_set_wheelchair_boarding(::transit_realtime::Stop_WheelchairBoarding value);

  public:
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Stop, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Stop, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<Stop, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Stop, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Stop, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Stop, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Stop, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Stop, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Stop, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<Stop, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Stop, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Stop, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Stop, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Stop, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Stop, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Stop, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Stop, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Stop, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Stop, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:transit_realtime.Stop)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 14, 7,
      87, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Stop& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr stop_id_;
    ::google::protobuf::internal::ArenaStringPtr zone_id_;
    ::google::protobuf::internal::ArenaStringPtr parent_station_;
    ::google::protobuf::internal::ArenaStringPtr stop_timezone_;
    ::google::protobuf::internal::ArenaStringPtr level_id_;
    ::transit_realtime::TranslatedString* stop_code_;
    ::transit_realtime::TranslatedString* stop_name_;
    ::transit_realtime::TranslatedString* tts_stop_name_;
    ::transit_realtime::TranslatedString* stop_desc_;
    ::transit_realtime::TranslatedString* stop_url_;
    ::transit_realtime::TranslatedString* platform_code_;
    float stop_lat_;
    float stop_lon_;
    int wheelchair_boarding_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class EntitySelector final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:transit_realtime.EntitySelector) */ {
 public:
  inline EntitySelector() : EntitySelector(nullptr) {}
  ~EntitySelector() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EntitySelector* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EntitySelector));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EntitySelector(
      ::google::protobuf::internal::ConstantInitialized);

  inline EntitySelector(const EntitySelector& from) : EntitySelector(nullptr, from) {}
  inline EntitySelector(EntitySelector&& from) noexcept
      : EntitySelector(nullptr, std::move(from)) {}
  inline EntitySelector& operator=(const EntitySelector& from) {
    CopyFrom(from);
    return *this;
  }
  inline EntitySelector& operator=(EntitySelector&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EntitySelector& default_instance() {
    return *internal_default_instance();
  }
  static inline const EntitySelector* internal_default_instance() {
    return reinterpret_cast<const EntitySelector*>(
        &_EntitySelector_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(EntitySelector& a, EntitySelector& b) { a.Swap(&b); }
  inline void Swap(EntitySelector* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EntitySelector* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EntitySelector* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EntitySelector>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EntitySelector& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EntitySelector& from) { EntitySelector::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EntitySelector* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "transit_realtime.EntitySelector"; }

 protected:
  explicit EntitySelector(::google::protobuf::Arena* arena);
  EntitySelector(::google::protobuf::Arena* arena, const EntitySelector& from);
  EntitySelector(::google::protobuf::Arena* arena, EntitySelector&& from) noexcept
      : EntitySelector(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAgencyIdFieldNumber = 1,
    kRouteIdFieldNumber = 2,
    kStopIdFieldNumber = 5,
    kTripFieldNumber = 4,
    kRouteTypeFieldNumber = 3,
    kDirectionIdFieldNumber = 6,
  };
  // optional string agency_id = 1;
  bool has_agency_id() const;
  void clear_agency_id() ;
  const std::string& agency_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_agency_id(Arg_&& arg, Args_... args);
  std::string* mutable_agency_id();
  PROTOBUF_NODISCARD std::string* release_agency_id();
  void set_allocated_agency_id(std::string* value);

  private:
  const std::string& _internal_agency_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_agency_id(
      const std::string& value);
  std::string* _internal_mutable_agency_id();

  public:
  // optional string route_id = 2;
  bool has_route_id() const;
  void clear_route_id() ;
  const std::string& route_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_route_id(Arg_&& arg, Args_... args);
  std::string* mutable_route_id();
  PROTOBUF_NODISCARD std::string* release_route_id();
  void set_allocated_route_id(std::string* value);

  private:
  const std::string& _internal_route_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_route_id(
      const std::string& value);
  std::string* _internal_mutable_route_id();

  public:
  // optional string stop_id = 5;
  bool has_stop_id() const;
  void clear_stop_id() ;
  const std::string& stop_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_stop_id(Arg_&& arg, Args_... args);
  std::string* mutable_stop_id();
  PROTOBUF_NODISCARD std::string* release_stop_id();
  void set_allocated_stop_id(std::string* value);

  private:
  const std::string& _internal_stop_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stop_id(
      const std::string& value);
  std::string* _internal_mutable_stop_id();

  public:
  // optional .transit_realtime.TripDescriptor trip = 4;
  bool has_trip() const;
  void clear_trip() ;
  const ::transit_realtime::TripDescriptor& trip() const;
  PROTOBUF_NODISCARD ::transit_realtime::TripDescriptor* release_trip();
  ::transit_realtime::TripDescriptor* mutable_trip();
  void set_allocated_trip(::transit_realtime::TripDescriptor* value);
  void unsafe_arena_set_allocated_trip(::transit_realtime::TripDescriptor* value);
  ::transit_realtime::TripDescriptor* unsafe_arena_release_trip();

  private:
  const ::transit_realtime::TripDescriptor& _internal_trip() const;
  ::transit_realtime::TripDescriptor* _internal_mutable_trip();

  public:
  // optional int32 route_type = 3;
  bool has_route_type() const;
  void clear_route_type() ;
  ::int32_t route_type() const;
  void set_route_type(::int32_t value);

  private:
  ::int32_t _internal_route_type() const;
  void _internal_set_route_type(::int32_t value);

  public:
  // optional uint32 direction_id = 6;
  bool has_direction_id() const;
  void clear_direction_id() ;
  ::uint32_t direction_id() const;
  void set_direction_id(::uint32_t value);

  private:
  ::uint32_t _internal_direction_id() const;
  void _internal_set_direction_id(::uint32_t value);

  public:
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<EntitySelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<EntitySelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<EntitySelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<EntitySelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<EntitySelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<EntitySelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<EntitySelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<EntitySelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<EntitySelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<EntitySelector, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<EntitySelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<EntitySelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<EntitySelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<EntitySelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<EntitySelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<EntitySelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<EntitySelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<EntitySelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<EntitySelector, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:transit_realtime.EntitySelector)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      64, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const EntitySelector& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr agency_id_;
    ::google::protobuf::internal::ArenaStringPtr route_id_;
    ::google::protobuf::internal::ArenaStringPtr stop_id_;
    ::transit_realtime::TripDescriptor* trip_;
    ::int32_t route_type_;
    ::uint32_t direction_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class Alert final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:transit_realtime.Alert) */ {
 public:
  inline Alert() : Alert(nullptr) {}
  ~Alert() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Alert* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Alert));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Alert(
      ::google::protobuf::internal::ConstantInitialized);

  inline Alert(const Alert& from) : Alert(nullptr, from) {}
  inline Alert(Alert&& from) noexcept
      : Alert(nullptr, std::move(from)) {}
  inline Alert& operator=(const Alert& from) {
    CopyFrom(from);
    return *this;
  }
  inline Alert& operator=(Alert&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Alert& default_instance() {
    return *internal_default_instance();
  }
  static inline const Alert* internal_default_instance() {
    return reinterpret_cast<const Alert*>(
        &_Alert_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(Alert& a, Alert& b) { a.Swap(&b); }
  inline void Swap(Alert* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Alert* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Alert* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Alert>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Alert& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Alert& from) { Alert::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Alert* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "transit_realtime.Alert"; }

 protected:
  explicit Alert(::google::protobuf::Arena* arena);
  Alert(::google::protobuf::Arena* arena, const Alert& from);
  Alert(::google::protobuf::Arena* arena, Alert&& from) noexcept
      : Alert(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Cause = Alert_Cause;
  static constexpr Cause UNKNOWN_CAUSE = Alert_Cause_UNKNOWN_CAUSE;
  static constexpr Cause OTHER_CAUSE = Alert_Cause_OTHER_CAUSE;
  static constexpr Cause TECHNICAL_PROBLEM = Alert_Cause_TECHNICAL_PROBLEM;
  static constexpr Cause STRIKE = Alert_Cause_STRIKE;
  static constexpr Cause DEMONSTRATION = Alert_Cause_DEMONSTRATION;
  static constexpr Cause ACCIDENT = Alert_Cause_ACCIDENT;
  static constexpr Cause HOLIDAY = Alert_Cause_HOLIDAY;
  static constexpr Cause WEATHER = Alert_Cause_WEATHER;
  static constexpr Cause MAINTENANCE = Alert_Cause_MAINTENANCE;
  static constexpr Cause CONSTRUCTION = Alert_Cause_CONSTRUCTION;
  static constexpr Cause POLICE_ACTIVITY = Alert_Cause_POLICE_ACTIVITY;
  static constexpr Cause MEDICAL_EMERGENCY = Alert_Cause_MEDICAL_EMERGENCY;
  static inline bool Cause_IsValid(int value) {
    return Alert_Cause_IsValid(value);
  }
  static constexpr Cause Cause_MIN = Alert_Cause_Cause_MIN;
  static constexpr Cause Cause_MAX = Alert_Cause_Cause_MAX;
  static constexpr int Cause_ARRAYSIZE = Alert_Cause_Cause_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Cause_descriptor() {
    return Alert_Cause_descriptor();
  }
  template <typename T>
  static inline const std::string& Cause_Name(T value) {
    return Alert_Cause_Name(value);
  }
  static inline bool Cause_Parse(absl::string_view name, Cause* value) {
    return Alert_Cause_Parse(name, value);
  }
  using Effect = Alert_Effect;
  static constexpr Effect NO_SERVICE = Alert_Effect_NO_SERVICE;
  static constexpr Effect REDUCED_SERVICE = Alert_Effect_REDUCED_SERVICE;
  static constexpr Effect SIGNIFICANT_DELAYS = Alert_Effect_SIGNIFICANT_DELAYS;
  static constexpr Effect DETOUR = Alert_Effect_DETOUR;
  static constexpr Effect ADDITIONAL_SERVICE = Alert_Effect_ADDITIONAL_SERVICE;
  static constexpr Effect MODIFIED_SERVICE = Alert_Effect_MODIFIED_SERVICE;
  static constexpr Effect OTHER_EFFECT = Alert_Effect_OTHER_EFFECT;
  static constexpr Effect UNKNOWN_EFFECT = Alert_Effect_UNKNOWN_EFFECT;
  static constexpr Effect STOP_MOVED = Alert_Effect_STOP_MOVED;
  static constexpr Effect NO_EFFECT = Alert_Effect_NO_EFFECT;
  static constexpr Effect ACCESSIBILITY_ISSUE = Alert_Effect_ACCESSIBILITY_ISSUE;
  static inline bool Effect_IsValid(int value) {
    return Alert_Effect_IsValid(value);
  }
  static constexpr Effect Effect_MIN = Alert_Effect_Effect_MIN;
  static constexpr Effect Effect_MAX = Alert_Effect_Effect_MAX;
  static constexpr int Effect_ARRAYSIZE = Alert_Effect_Effect_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Effect_descriptor() {
    return Alert_Effect_descriptor();
  }
  template <typename T>
  static inline const std::string& Effect_Name(T value) {
    return Alert_Effect_Name(value);
  }
  static inline bool Effect_Parse(absl::string_view name, Effect* value) {
    return Alert_Effect_Parse(name, value);
  }
  using SeverityLevel = Alert_SeverityLevel;
  static constexpr SeverityLevel UNKNOWN_SEVERITY = Alert_SeverityLevel_UNKNOWN_SEVERITY;
  static constexpr SeverityLevel INFO = Alert_SeverityLevel_INFO;
  static constexpr SeverityLevel WARNING = Alert_SeverityLevel_WARNING;
  static constexpr SeverityLevel SEVERE = Alert_SeverityLevel_SEVERE;
  static inline bool SeverityLevel_IsValid(int value) {
    return Alert_SeverityLevel_IsValid(value);
  }
  static constexpr SeverityLevel SeverityLevel_MIN = Alert_SeverityLevel_SeverityLevel_MIN;
  static constexpr SeverityLevel SeverityLevel_MAX = Alert_SeverityLevel_SeverityLevel_MAX;
  static constexpr int SeverityLevel_ARRAYSIZE = Alert_SeverityLevel_SeverityLevel_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* SeverityLevel_descriptor() {
    return Alert_SeverityLevel_descriptor();
  }
  template <typename T>
  static inline const std::string& SeverityLevel_Name(T value) {
    return Alert_SeverityLevel_Name(value);
  }
  static inline bool SeverityLevel_Parse(absl::string_view name, SeverityLevel* value) {
    return Alert_SeverityLevel_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kActivePeriodFieldNumber = 1,
    kInformedEntityFieldNumber = 5,
    kUrlFieldNumber = 8,
    kHeaderTextFieldNumber = 10,
    kDescriptionTextFieldNumber = 11,
    kTtsHeaderTextFieldNumber = 12,
    kTtsDescriptionTextFieldNumber = 13,
    kImageFieldNumber = 15,
    kImageAlternativeTextFieldNumber = 16,
    kCauseDetailFieldNumber = 17,
    kEffectDetailFieldNumber = 18,
    kSeverityLevelFieldNumber = 14,
    kCauseFieldNumber = 6,
    kEffectFieldNumber = 7,
  };
  // repeated .transit_realtime.TimeRange active_period = 1;
  int active_period_size() const;
  private:
  int _internal_active_period_size() const;

  public:
  void clear_active_period() ;
  ::transit_realtime::TimeRange* mutable_active_period(int index);
  ::google::protobuf::RepeatedPtrField<::transit_realtime::TimeRange>* mutable_active_period();

  private:
  const ::google::protobuf::RepeatedPtrField<::transit_realtime::TimeRange>& _internal_active_period() const;
  ::google::protobuf::RepeatedPtrField<::transit_realtime::TimeRange>* _internal_mutable_active_period();
  public:
  const ::transit_realtime::TimeRange& active_period(int index) const;
  ::transit_realtime::TimeRange* add_active_period();
  const ::google::protobuf::RepeatedPtrField<::transit_realtime::TimeRange>& active_period() const;
  // repeated .transit_realtime.EntitySelector informed_entity = 5;
  int informed_entity_size() const;
  private:
  int _internal_informed_entity_size() const;

  public:
  void clear_informed_entity() ;
  ::transit_realtime::EntitySelector* mutable_informed_entity(int index);
  ::google::protobuf::RepeatedPtrField<::transit_realtime::EntitySelector>* mutable_informed_entity();

  private:
  const ::google::protobuf::RepeatedPtrField<::transit_realtime::EntitySelector>& _internal_informed_entity() const;
  ::google::protobuf::RepeatedPtrField<::transit_realtime::EntitySelector>* _internal_mutable_informed_entity();
  public:
  const ::transit_realtime::EntitySelector& informed_entity(int index) const;
  ::transit_realtime::EntitySelector* add_informed_entity();
  const ::google::protobuf::RepeatedPtrField<::transit_realtime::EntitySelector>& informed_entity() const;
  // optional .transit_realtime.TranslatedString url = 8;
  bool has_url() const;
  void clear_url() ;
  const ::transit_realtime::TranslatedString& url() const;
  PROTOBUF_NODISCARD ::transit_realtime::TranslatedString* release_url();
  ::transit_realtime::TranslatedString* mutable_url();
  void set_allocated_url(::transit_realtime::TranslatedString* value);
  void unsafe_arena_set_allocated_url(::transit_realtime::TranslatedString* value);
  ::transit_realtime::TranslatedString* unsafe_arena_release_url();

  private:
  const ::transit_realtime::TranslatedString& _internal_url() const;
  ::transit_realtime::TranslatedString* _internal_mutable_url();

  public:
  // optional .transit_realtime.TranslatedString header_text = 10;
  bool has_header_text() const;
  void clear_header_text() ;
  const ::transit_realtime::TranslatedString& header_text() const;
  PROTOBUF_NODISCARD ::transit_realtime::TranslatedString* release_header_text();
  ::transit_realtime::TranslatedString* mutable_header_text();
  void set_allocated_header_text(::transit_realtime::TranslatedString* value);
  void unsafe_arena_set_allocated_header_text(::transit_realtime::TranslatedString* value);
  ::transit_realtime::TranslatedString* unsafe_arena_release_header_text();

  private:
  const ::transit_realtime::TranslatedString& _internal_header_text() const;
  ::transit_realtime::TranslatedString* _internal_mutable_header_text();

  public:
  // optional .transit_realtime.TranslatedString description_text = 11;
  bool has_description_text() const;
  void clear_description_text() ;
  const ::transit_realtime::TranslatedString& description_text() const;
  PROTOBUF_NODISCARD ::transit_realtime::TranslatedString* release_description_text();
  ::transit_realtime::TranslatedString* mutable_description_text();
  void set_allocated_description_text(::transit_realtime::TranslatedString* value);
  void unsafe_arena_set_allocated_description_text(::transit_realtime::TranslatedString* value);
  ::transit_realtime::TranslatedString* unsafe_arena_release_description_text();

  private:
  const ::transit_realtime::TranslatedString& _internal_description_text() const;
  ::transit_realtime::TranslatedString* _internal_mutable_description_text();

  public:
  // optional .transit_realtime.TranslatedString tts_header_text = 12;
  bool has_tts_header_text() const;
  void clear_tts_header_text() ;
  const ::transit_realtime::TranslatedString& tts_header_text() const;
  PROTOBUF_NODISCARD ::transit_realtime::TranslatedString* release_tts_header_text();
  ::transit_realtime::TranslatedString* mutable_tts_header_text();
  void set_allocated_tts_header_text(::transit_realtime::TranslatedString* value);
  void unsafe_arena_set_allocated_tts_header_text(::transit_realtime::TranslatedString* value);
  ::transit_realtime::TranslatedString* unsafe_arena_release_tts_header_text();

  private:
  const ::transit_realtime::TranslatedString& _internal_tts_header_text() const;
  ::transit_realtime::TranslatedString* _internal_mutable_tts_header_text();

  public:
  // optional .transit_realtime.TranslatedString tts_description_text = 13;
  bool has_tts_description_text() const;
  void clear_tts_description_text() ;
  const ::transit_realtime::TranslatedString& tts_description_text() const;
  PROTOBUF_NODISCARD ::transit_realtime::TranslatedString* release_tts_description_text();
  ::transit_realtime::TranslatedString* mutable_tts_description_text();
  void set_allocated_tts_description_text(::transit_realtime::TranslatedString* value);
  void unsafe_arena_set_allocated_tts_description_text(::transit_realtime::TranslatedString* value);
  ::transit_realtime::TranslatedString* unsafe_arena_release_tts_description_text();

  private:
  const ::transit_realtime::TranslatedString& _internal_tts_description_text() const;
  ::transit_realtime::TranslatedString* _internal_mutable_tts_description_text();

  public:
  // optional .transit_realtime.TranslatedImage image = 15;
  bool has_image() const;
  void clear_image() ;
  const ::transit_realtime::TranslatedImage& image() const;
  PROTOBUF_NODISCARD ::transit_realtime::TranslatedImage* release_image();
  ::transit_realtime::TranslatedImage* mutable_image();
  void set_allocated_image(::transit_realtime::TranslatedImage* value);
  void unsafe_arena_set_allocated_image(::transit_realtime::TranslatedImage* value);
  ::transit_realtime::TranslatedImage* unsafe_arena_release_image();

  private:
  const ::transit_realtime::TranslatedImage& _internal_image() const;
  ::transit_realtime::TranslatedImage* _internal_mutable_image();

  public:
  // optional .transit_realtime.TranslatedString image_alternative_text = 16;
  bool has_image_alternative_text() const;
  void clear_image_alternative_text() ;
  const ::transit_realtime::TranslatedString& image_alternative_text() const;
  PROTOBUF_NODISCARD ::transit_realtime::TranslatedString* release_image_alternative_text();
  ::transit_realtime::TranslatedString* mutable_image_alternative_text();
  void set_allocated_image_alternative_text(::transit_realtime::TranslatedString* value);
  void unsafe_arena_set_allocated_image_alternative_text(::transit_realtime::TranslatedString* value);
  ::transit_realtime::TranslatedString* unsafe_arena_release_image_alternative_text();

  private:
  const ::transit_realtime::TranslatedString& _internal_image_alternative_text() const;
  ::transit_realtime::TranslatedString* _internal_mutable_image_alternative_text();

  public:
  // optional .transit_realtime.TranslatedString cause_detail = 17;
  bool has_cause_detail() const;
  void clear_cause_detail() ;
  const ::transit_realtime::TranslatedString& cause_detail() const;
  PROTOBUF_NODISCARD ::transit_realtime::TranslatedString* release_cause_detail();
  ::transit_realtime::TranslatedString* mutable_cause_detail();
  void set_allocated_cause_detail(::transit_realtime::TranslatedString* value);
  void unsafe_arena_set_allocated_cause_detail(::transit_realtime::TranslatedString* value);
  ::transit_realtime::TranslatedString* unsafe_arena_release_cause_detail();

  private:
  const ::transit_realtime::TranslatedString& _internal_cause_detail() const;
  ::transit_realtime::TranslatedString* _internal_mutable_cause_detail();

  public:
  // optional .transit_realtime.TranslatedString effect_detail = 18;
  bool has_effect_detail() const;
  void clear_effect_detail() ;
  const ::transit_realtime::TranslatedString& effect_detail() const;
  PROTOBUF_NODISCARD ::transit_realtime::TranslatedString* release_effect_detail();
  ::transit_realtime::TranslatedString* mutable_effect_detail();
  void set_allocated_effect_detail(::transit_realtime::TranslatedString* value);
  void unsafe_arena_set_allocated_effect_detail(::transit_realtime::TranslatedString* value);
  ::transit_realtime::TranslatedString* unsafe_arena_release_effect_detail();

  private:
  const ::transit_realtime::TranslatedString& _internal_effect_detail() const;
  ::transit_realtime::TranslatedString* _internal_mutable_effect_detail();

  public:
  // optional .transit_realtime.Alert.SeverityLevel severity_level = 14 [default = UNKNOWN_SEVERITY];
  bool has_severity_level() const;
  void clear_severity_level() ;
  ::transit_realtime::Alert_SeverityLevel severity_level() const;
  void set_severity_level(::transit_realtime::Alert_SeverityLevel value);

  private:
  ::transit_realtime::Alert_SeverityLevel _internal_severity_level() const;
  void _internal_set_severity_level(::transit_realtime::Alert_SeverityLevel value);

  public:
  // optional .transit_realtime.Alert.Cause cause = 6 [default = UNKNOWN_CAUSE];
  bool has_cause() const;
  void clear_cause() ;
  ::transit_realtime::Alert_Cause cause() const;
  void set_cause(::transit_realtime::Alert_Cause value);

  private:
  ::transit_realtime::Alert_Cause _internal_cause() const;
  void _internal_set_cause(::transit_realtime::Alert_Cause value);

  public:
  // optional .transit_realtime.Alert.Effect effect = 7 [default = UNKNOWN_EFFECT];
  bool has_effect() const;
  void clear_effect() ;
  ::transit_realtime::Alert_Effect effect() const;
  void set_effect(::transit_realtime::Alert_Effect value);

  private:
  ::transit_realtime::Alert_Effect _internal_effect() const;
  void _internal_set_effect(::transit_realtime::Alert_Effect value);

  public:
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Alert, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Alert, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<Alert, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Alert, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Alert, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Alert, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Alert, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Alert, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Alert, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<Alert, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Alert, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Alert, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Alert, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Alert, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Alert, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Alert, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Alert, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Alert, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<Alert, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:transit_realtime.Alert)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 14, 14,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Alert& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::transit_realtime::TimeRange > active_period_;
    ::google::protobuf::RepeatedPtrField< ::transit_realtime::EntitySelector > informed_entity_;
    ::transit_realtime::TranslatedString* url_;
    ::transit_realtime::TranslatedString* header_text_;
    ::transit_realtime::TranslatedString* description_text_;
    ::transit_realtime::TranslatedString* tts_header_text_;
    ::transit_realtime::TranslatedString* tts_description_text_;
    ::transit_realtime::TranslatedImage* image_;
    ::transit_realtime::TranslatedString* image_alternative_text_;
    ::transit_realtime::TranslatedString* cause_detail_;
    ::transit_realtime::TranslatedString* effect_detail_;
    int severity_level_;
    int cause_;
    int effect_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class FeedEntity final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:transit_realtime.FeedEntity) */ {
 public:
  inline FeedEntity() : FeedEntity(nullptr) {}
  ~FeedEntity() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FeedEntity* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FeedEntity));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FeedEntity(
      ::google::protobuf::internal::ConstantInitialized);

  inline FeedEntity(const FeedEntity& from) : FeedEntity(nullptr, from) {}
  inline FeedEntity(FeedEntity&& from) noexcept
      : FeedEntity(nullptr, std::move(from)) {}
  inline FeedEntity& operator=(const FeedEntity& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeedEntity& operator=(FeedEntity&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FeedEntity& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeedEntity* internal_default_instance() {
    return reinterpret_cast<const FeedEntity*>(
        &_FeedEntity_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(FeedEntity& a, FeedEntity& b) { a.Swap(&b); }
  inline void Swap(FeedEntity* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeedEntity* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeedEntity* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FeedEntity>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FeedEntity& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FeedEntity& from) { FeedEntity::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FeedEntity* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "transit_realtime.FeedEntity"; }

 protected:
  explicit FeedEntity(::google::protobuf::Arena* arena);
  FeedEntity(::google::protobuf::Arena* arena, const FeedEntity& from);
  FeedEntity(::google::protobuf::Arena* arena, FeedEntity&& from) noexcept
      : FeedEntity(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kTripUpdateFieldNumber = 3,
    kVehicleFieldNumber = 4,
    kAlertFieldNumber = 5,
    kShapeFieldNumber = 6,
    kStopFieldNumber = 7,
    kTripModificationsFieldNumber = 8,
    kIsDeletedFieldNumber = 2,
  };
  // required string id = 1;
  bool has_id() const;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // optional .transit_realtime.TripUpdate trip_update = 3;
  bool has_trip_update() const;
  void clear_trip_update() ;
  const ::transit_realtime::TripUpdate& trip_update() const;
  PROTOBUF_NODISCARD ::transit_realtime::TripUpdate* release_trip_update();
  ::transit_realtime::TripUpdate* mutable_trip_update();
  void set_allocated_trip_update(::transit_realtime::TripUpdate* value);
  void unsafe_arena_set_allocated_trip_update(::transit_realtime::TripUpdate* value);
  ::transit_realtime::TripUpdate* unsafe_arena_release_trip_update();

  private:
  const ::transit_realtime::TripUpdate& _internal_trip_update() const;
  ::transit_realtime::TripUpdate* _internal_mutable_trip_update();

  public:
  // optional .transit_realtime.VehiclePosition vehicle = 4;
  bool has_vehicle() const;
  void clear_vehicle() ;
  const ::transit_realtime::VehiclePosition& vehicle() const;
  PROTOBUF_NODISCARD ::transit_realtime::VehiclePosition* release_vehicle();
  ::transit_realtime::VehiclePosition* mutable_vehicle();
  void set_allocated_vehicle(::transit_realtime::VehiclePosition* value);
  void unsafe_arena_set_allocated_vehicle(::transit_realtime::VehiclePosition* value);
  ::transit_realtime::VehiclePosition* unsafe_arena_release_vehicle();

  private:
  const ::transit_realtime::VehiclePosition& _internal_vehicle() const;
  ::transit_realtime::VehiclePosition* _internal_mutable_vehicle();

  public:
  // optional .transit_realtime.Alert alert = 5;
  bool has_alert() const;
  void clear_alert() ;
  const ::transit_realtime::Alert& alert() const;
  PROTOBUF_NODISCARD ::transit_realtime::Alert* release_alert();
  ::transit_realtime::Alert* mutable_alert();
  void set_allocated_alert(::transit_realtime::Alert* value);
  void unsafe_arena_set_allocated_alert(::transit_realtime::Alert* value);
  ::transit_realtime::Alert* unsafe_arena_release_alert();

  private:
  const ::transit_realtime::Alert& _internal_alert() const;
  ::transit_realtime::Alert* _internal_mutable_alert();

  public:
  // optional .transit_realtime.Shape shape = 6;
  bool has_shape() const;
  void clear_shape() ;
  const ::transit_realtime::Shape& shape() const;
  PROTOBUF_NODISCARD ::transit_realtime::Shape* release_shape();
  ::transit_realtime::Shape* mutable_shape();
  void set_allocated_shape(::transit_realtime::Shape* value);
  void unsafe_arena_set_allocated_shape(::transit_realtime::Shape* value);
  ::transit_realtime::Shape* unsafe_arena_release_shape();

  private:
  const ::transit_realtime::Shape& _internal_shape() const;
  ::transit_realtime::Shape* _internal_mutable_shape();

  public:
  // optional .transit_realtime.Stop stop = 7;
  bool has_stop() const;
  void clear_stop() ;
  const ::transit_realtime::Stop& stop() const;
  PROTOBUF_NODISCARD ::transit_realtime::Stop* release_stop();
  ::transit_realtime::Stop* mutable_stop();
  void set_allocated_stop(::transit_realtime::Stop* value);
  void unsafe_arena_set_allocated_stop(::transit_realtime::Stop* value);
  ::transit_realtime::Stop* unsafe_arena_release_stop();

  private:
  const ::transit_realtime::Stop& _internal_stop() const;
  ::transit_realtime::Stop* _internal_mutable_stop();

  public:
  // optional .transit_realtime.TripModifications trip_modifications = 8;
  bool has_trip_modifications() const;
  void clear_trip_modifications() ;
  const ::transit_realtime::TripModifications& trip_modifications() const;
  PROTOBUF_NODISCARD ::transit_realtime::TripModifications* release_trip_modifications();
  ::transit_realtime::TripModifications* mutable_trip_modifications();
  void set_allocated_trip_modifications(::transit_realtime::TripModifications* value);
  void unsafe_arena_set_allocated_trip_modifications(::transit_realtime::TripModifications* value);
  ::transit_realtime::TripModifications* unsafe_arena_release_trip_modifications();

  private:
  const ::transit_realtime::TripModifications& _internal_trip_modifications() const;
  ::transit_realtime::TripModifications* _internal_mutable_trip_modifications();

  public:
  // optional bool is_deleted = 2 [default = false];
  bool has_is_deleted() const;
  void clear_is_deleted() ;
  bool is_deleted() const;
  void set_is_deleted(bool value);

  private:
  bool _internal_is_deleted() const;
  void _internal_set_is_deleted(bool value);

  public:
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedEntity, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedEntity, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedEntity, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedEntity, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedEntity, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedEntity, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedEntity, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedEntity, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedEntity, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<FeedEntity, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedEntity, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedEntity, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedEntity, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedEntity, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedEntity, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedEntity, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedEntity, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedEntity, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedEntity, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:transit_realtime.FeedEntity)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 6,
      46, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FeedEntity& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::transit_realtime::TripUpdate* trip_update_;
    ::transit_realtime::VehiclePosition* vehicle_;
    ::transit_realtime::Alert* alert_;
    ::transit_realtime::Shape* shape_;
    ::transit_realtime::Stop* stop_;
    ::transit_realtime::TripModifications* trip_modifications_;
    bool is_deleted_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};
// -------------------------------------------------------------------

class FeedMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:transit_realtime.FeedMessage) */ {
 public:
  inline FeedMessage() : FeedMessage(nullptr) {}
  ~FeedMessage() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FeedMessage* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FeedMessage));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FeedMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline FeedMessage(const FeedMessage& from) : FeedMessage(nullptr, from) {}
  inline FeedMessage(FeedMessage&& from) noexcept
      : FeedMessage(nullptr, std::move(from)) {}
  inline FeedMessage& operator=(const FeedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeedMessage& operator=(FeedMessage&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FeedMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeedMessage* internal_default_instance() {
    return reinterpret_cast<const FeedMessage*>(
        &_FeedMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(FeedMessage& a, FeedMessage& b) { a.Swap(&b); }
  inline void Swap(FeedMessage* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeedMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeedMessage* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FeedMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FeedMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FeedMessage& from) { FeedMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return IsInitializedImpl(*this);
  }

  private:
  static bool IsInitializedImpl(const MessageLite& msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FeedMessage* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "transit_realtime.FeedMessage"; }

 protected:
  explicit FeedMessage(::google::protobuf::Arena* arena);
  FeedMessage(::google::protobuf::Arena* arena, const FeedMessage& from);
  FeedMessage(::google::protobuf::Arena* arena, FeedMessage&& from) noexcept
      : FeedMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEntityFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .transit_realtime.FeedEntity entity = 2;
  int entity_size() const;
  private:
  int _internal_entity_size() const;

  public:
  void clear_entity() ;
  ::transit_realtime::FeedEntity* mutable_entity(int index);
  ::google::protobuf::RepeatedPtrField<::transit_realtime::FeedEntity>* mutable_entity();

  private:
  const ::google::protobuf::RepeatedPtrField<::transit_realtime::FeedEntity>& _internal_entity() const;
  ::google::protobuf::RepeatedPtrField<::transit_realtime::FeedEntity>* _internal_mutable_entity();
  public:
  const ::transit_realtime::FeedEntity& entity(int index) const;
  ::transit_realtime::FeedEntity* add_entity();
  const ::google::protobuf::RepeatedPtrField<::transit_realtime::FeedEntity>& entity() const;
  // required .transit_realtime.FeedHeader header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::transit_realtime::FeedHeader& header() const;
  PROTOBUF_NODISCARD ::transit_realtime::FeedHeader* release_header();
  ::transit_realtime::FeedHeader* mutable_header();
  void set_allocated_header(::transit_realtime::FeedHeader* value);
  void unsafe_arena_set_allocated_header(::transit_realtime::FeedHeader* value);
  ::transit_realtime::FeedHeader* unsafe_arena_release_header();

  private:
  const ::transit_realtime::FeedHeader& _internal_header() const;
  ::transit_realtime::FeedHeader* _internal_mutable_header();

  public:
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Singular>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedMessage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.Has(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedMessage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    _impl_._extensions_.ClearExtension(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            typename = typename _proto_TypeTraits::Repeated>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedMessage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _impl_._extensions_.ExtensionSize(id.number());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedMessage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Singular::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedMessage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, id.default_value());
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedMessage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), _field_type, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedMessage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::ConstType value) {
    _proto_TypeTraits::Set(id.number(), _field_type, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedMessage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::SetAllocated(id.number(), _field_type, value,
                                    &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void UnsafeArenaSetAllocatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedMessage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Singular::MutableType value) {
    _proto_TypeTraits::UnsafeArenaSetAllocated(id.number(), _field_type,
                                               value, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  PROTOBUF_NODISCARD inline
      typename _proto_TypeTraits::Singular::MutableType
      ReleaseExtension(
          const ::google::protobuf::internal::ExtensionIdentifier<FeedMessage, _proto_TypeTraits,
                                           _field_type, _is_packed>& id) {
    return _proto_TypeTraits::Release(id.number(), _field_type, &_impl_._extensions_);
  }
  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Singular::MutableType
  UnsafeArenaReleaseExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedMessage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) {
    return _proto_TypeTraits::UnsafeArenaRelease(id.number(), _field_type,
                                                 &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<!_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedMessage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed,
            std::enable_if_t<_proto_TypeTraits::kLifetimeBound, int> = 0>
  inline typename _proto_TypeTraits::Repeated::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedMessage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Get(id.number(), _impl_._extensions_, index);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedMessage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index) ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::Mutable(id.number(), index, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedMessage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      int index, typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedMessage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    typename _proto_TypeTraits::Repeated::MutableType to_add =
        _proto_TypeTraits::Add(id.number(), _field_type, &_impl_._extensions_);
    return to_add;
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedMessage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id,
      typename _proto_TypeTraits::Repeated::ConstType value) {
    _proto_TypeTraits::Add(id.number(), _field_type, _is_packed, value,
                           &_impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline const typename _proto_TypeTraits::Repeated::RepeatedFieldType&
  GetRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedMessage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id) const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::GetRepeated(id.number(), _impl_._extensions_);
  }

  template <typename _proto_TypeTraits, ::google::protobuf::internal::FieldType _field_type,
            bool _is_packed>
  inline typename _proto_TypeTraits::Repeated::RepeatedFieldType*
  MutableRepeatedExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<FeedMessage, _proto_TypeTraits,
                                       _field_type, _is_packed>& id)
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _proto_TypeTraits::MutableRepeated(id.number(), _field_type,
                                              _is_packed, &_impl_._extensions_);
  }
  // @@protoc_insertion_point(class_scope:transit_realtime.FeedMessage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const FeedMessage& from_msg);
    ::google::protobuf::internal::ExtensionSet _extensions_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::transit_realtime::FeedEntity > entity_;
    ::transit_realtime::FeedHeader* header_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_gtfs_2drealtime_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// FeedMessage

// required .transit_realtime.FeedHeader header = 1;
inline bool FeedMessage::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void FeedMessage::clear_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::transit_realtime::FeedHeader& FeedMessage::_internal_header() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::transit_realtime::FeedHeader* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::FeedHeader&>(::transit_realtime::_FeedHeader_default_instance_);
}
inline const ::transit_realtime::FeedHeader& FeedMessage::header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.FeedMessage.header)
  return _internal_header();
}
inline void FeedMessage::unsafe_arena_set_allocated_header(::transit_realtime::FeedHeader* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = reinterpret_cast<::transit_realtime::FeedHeader*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.FeedMessage.header)
}
inline ::transit_realtime::FeedHeader* FeedMessage::release_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::transit_realtime::FeedHeader* released = _impl_.header_;
  _impl_.header_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::transit_realtime::FeedHeader* FeedMessage::unsafe_arena_release_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.FeedMessage.header)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::transit_realtime::FeedHeader* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::transit_realtime::FeedHeader* FeedMessage::_internal_mutable_header() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.header_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::transit_realtime::FeedHeader>(GetArena());
    _impl_.header_ = reinterpret_cast<::transit_realtime::FeedHeader*>(p);
  }
  return _impl_.header_;
}
inline ::transit_realtime::FeedHeader* FeedMessage::mutable_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::transit_realtime::FeedHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:transit_realtime.FeedMessage.header)
  return _msg;
}
inline void FeedMessage::set_allocated_header(::transit_realtime::FeedHeader* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.header_ = reinterpret_cast<::transit_realtime::FeedHeader*>(value);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.FeedMessage.header)
}

// repeated .transit_realtime.FeedEntity entity = 2;
inline int FeedMessage::_internal_entity_size() const {
  return _internal_entity().size();
}
inline int FeedMessage::entity_size() const {
  return _internal_entity_size();
}
inline void FeedMessage::clear_entity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.entity_.Clear();
}
inline ::transit_realtime::FeedEntity* FeedMessage::mutable_entity(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:transit_realtime.FeedMessage.entity)
  return _internal_mutable_entity()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::transit_realtime::FeedEntity>* FeedMessage::mutable_entity()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:transit_realtime.FeedMessage.entity)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_entity();
}
inline const ::transit_realtime::FeedEntity& FeedMessage::entity(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.FeedMessage.entity)
  return _internal_entity().Get(index);
}
inline ::transit_realtime::FeedEntity* FeedMessage::add_entity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::transit_realtime::FeedEntity* _add = _internal_mutable_entity()->Add();
  // @@protoc_insertion_point(field_add:transit_realtime.FeedMessage.entity)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::transit_realtime::FeedEntity>& FeedMessage::entity() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:transit_realtime.FeedMessage.entity)
  return _internal_entity();
}
inline const ::google::protobuf::RepeatedPtrField<::transit_realtime::FeedEntity>&
FeedMessage::_internal_entity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.entity_;
}
inline ::google::protobuf::RepeatedPtrField<::transit_realtime::FeedEntity>*
FeedMessage::_internal_mutable_entity() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.entity_;
}

// -------------------------------------------------------------------

// FeedHeader

// required string gtfs_realtime_version = 1;
inline bool FeedHeader::has_gtfs_realtime_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void FeedHeader::clear_gtfs_realtime_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.gtfs_realtime_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FeedHeader::gtfs_realtime_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.FeedHeader.gtfs_realtime_version)
  return _internal_gtfs_realtime_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FeedHeader::set_gtfs_realtime_version(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.gtfs_realtime_version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:transit_realtime.FeedHeader.gtfs_realtime_version)
}
inline std::string* FeedHeader::mutable_gtfs_realtime_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_gtfs_realtime_version();
  // @@protoc_insertion_point(field_mutable:transit_realtime.FeedHeader.gtfs_realtime_version)
  return _s;
}
inline const std::string& FeedHeader::_internal_gtfs_realtime_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.gtfs_realtime_version_.Get();
}
inline void FeedHeader::_internal_set_gtfs_realtime_version(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.gtfs_realtime_version_.Set(value, GetArena());
}
inline std::string* FeedHeader::_internal_mutable_gtfs_realtime_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.gtfs_realtime_version_.Mutable( GetArena());
}
inline std::string* FeedHeader::release_gtfs_realtime_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.FeedHeader.gtfs_realtime_version)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.gtfs_realtime_version_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.gtfs_realtime_version_.Set("", GetArena());
  }
  return released;
}
inline void FeedHeader::set_allocated_gtfs_realtime_version(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.gtfs_realtime_version_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.gtfs_realtime_version_.IsDefault()) {
    _impl_.gtfs_realtime_version_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.FeedHeader.gtfs_realtime_version)
}

// optional .transit_realtime.FeedHeader.Incrementality incrementality = 2 [default = FULL_DATASET];
inline bool FeedHeader::has_incrementality() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void FeedHeader::clear_incrementality() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.incrementality_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::transit_realtime::FeedHeader_Incrementality FeedHeader::incrementality() const {
  // @@protoc_insertion_point(field_get:transit_realtime.FeedHeader.incrementality)
  return _internal_incrementality();
}
inline void FeedHeader::set_incrementality(::transit_realtime::FeedHeader_Incrementality value) {
  _internal_set_incrementality(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:transit_realtime.FeedHeader.incrementality)
}
inline ::transit_realtime::FeedHeader_Incrementality FeedHeader::_internal_incrementality() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::transit_realtime::FeedHeader_Incrementality>(_impl_.incrementality_);
}
inline void FeedHeader::_internal_set_incrementality(::transit_realtime::FeedHeader_Incrementality value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  assert(::transit_realtime::FeedHeader_Incrementality_IsValid(value));
  _impl_.incrementality_ = value;
}

// optional uint64 timestamp = 3;
inline bool FeedHeader::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void FeedHeader::clear_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t FeedHeader::timestamp() const {
  // @@protoc_insertion_point(field_get:transit_realtime.FeedHeader.timestamp)
  return _internal_timestamp();
}
inline void FeedHeader::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:transit_realtime.FeedHeader.timestamp)
}
inline ::uint64_t FeedHeader::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timestamp_;
}
inline void FeedHeader::_internal_set_timestamp(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = value;
}

// optional string feed_version = 4;
inline bool FeedHeader::has_feed_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void FeedHeader::clear_feed_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.feed_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& FeedHeader::feed_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.FeedHeader.feed_version)
  return _internal_feed_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FeedHeader::set_feed_version(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.feed_version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:transit_realtime.FeedHeader.feed_version)
}
inline std::string* FeedHeader::mutable_feed_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_feed_version();
  // @@protoc_insertion_point(field_mutable:transit_realtime.FeedHeader.feed_version)
  return _s;
}
inline const std::string& FeedHeader::_internal_feed_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.feed_version_.Get();
}
inline void FeedHeader::_internal_set_feed_version(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.feed_version_.Set(value, GetArena());
}
inline std::string* FeedHeader::_internal_mutable_feed_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.feed_version_.Mutable( GetArena());
}
inline std::string* FeedHeader::release_feed_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.FeedHeader.feed_version)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.feed_version_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.feed_version_.Set("", GetArena());
  }
  return released;
}
inline void FeedHeader::set_allocated_feed_version(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.feed_version_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.feed_version_.IsDefault()) {
    _impl_.feed_version_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.FeedHeader.feed_version)
}

// -------------------------------------------------------------------

// FeedEntity

// required string id = 1;
inline bool FeedEntity::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void FeedEntity::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FeedEntity::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.FeedEntity.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FeedEntity::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:transit_realtime.FeedEntity.id)
}
inline std::string* FeedEntity::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.FeedEntity.id)
  return _s;
}
inline const std::string& FeedEntity::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void FeedEntity::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* FeedEntity::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* FeedEntity::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.FeedEntity.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.id_.Set("", GetArena());
  }
  return released;
}
inline void FeedEntity::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.FeedEntity.id)
}

// optional bool is_deleted = 2 [default = false];
inline bool FeedEntity::has_is_deleted() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void FeedEntity::clear_is_deleted() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_deleted_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool FeedEntity::is_deleted() const {
  // @@protoc_insertion_point(field_get:transit_realtime.FeedEntity.is_deleted)
  return _internal_is_deleted();
}
inline void FeedEntity::set_is_deleted(bool value) {
  _internal_set_is_deleted(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:transit_realtime.FeedEntity.is_deleted)
}
inline bool FeedEntity::_internal_is_deleted() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_deleted_;
}
inline void FeedEntity::_internal_set_is_deleted(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_deleted_ = value;
}

// optional .transit_realtime.TripUpdate trip_update = 3;
inline bool FeedEntity::has_trip_update() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.trip_update_ != nullptr);
  return value;
}
inline void FeedEntity::clear_trip_update() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.trip_update_ != nullptr) _impl_.trip_update_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::transit_realtime::TripUpdate& FeedEntity::_internal_trip_update() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::transit_realtime::TripUpdate* p = _impl_.trip_update_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TripUpdate&>(::transit_realtime::_TripUpdate_default_instance_);
}
inline const ::transit_realtime::TripUpdate& FeedEntity::trip_update() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.FeedEntity.trip_update)
  return _internal_trip_update();
}
inline void FeedEntity::unsafe_arena_set_allocated_trip_update(::transit_realtime::TripUpdate* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.trip_update_);
  }
  _impl_.trip_update_ = reinterpret_cast<::transit_realtime::TripUpdate*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.FeedEntity.trip_update)
}
inline ::transit_realtime::TripUpdate* FeedEntity::release_trip_update() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::transit_realtime::TripUpdate* released = _impl_.trip_update_;
  _impl_.trip_update_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::transit_realtime::TripUpdate* FeedEntity::unsafe_arena_release_trip_update() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.FeedEntity.trip_update)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::transit_realtime::TripUpdate* temp = _impl_.trip_update_;
  _impl_.trip_update_ = nullptr;
  return temp;
}
inline ::transit_realtime::TripUpdate* FeedEntity::_internal_mutable_trip_update() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.trip_update_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::transit_realtime::TripUpdate>(GetArena());
    _impl_.trip_update_ = reinterpret_cast<::transit_realtime::TripUpdate*>(p);
  }
  return _impl_.trip_update_;
}
inline ::transit_realtime::TripUpdate* FeedEntity::mutable_trip_update() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::transit_realtime::TripUpdate* _msg = _internal_mutable_trip_update();
  // @@protoc_insertion_point(field_mutable:transit_realtime.FeedEntity.trip_update)
  return _msg;
}
inline void FeedEntity::set_allocated_trip_update(::transit_realtime::TripUpdate* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.trip_update_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.trip_update_ = reinterpret_cast<::transit_realtime::TripUpdate*>(value);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.FeedEntity.trip_update)
}

// optional .transit_realtime.VehiclePosition vehicle = 4;
inline bool FeedEntity::has_vehicle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.vehicle_ != nullptr);
  return value;
}
inline void FeedEntity::clear_vehicle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.vehicle_ != nullptr) _impl_.vehicle_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::transit_realtime::VehiclePosition& FeedEntity::_internal_vehicle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::transit_realtime::VehiclePosition* p = _impl_.vehicle_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::VehiclePosition&>(::transit_realtime::_VehiclePosition_default_instance_);
}
inline const ::transit_realtime::VehiclePosition& FeedEntity::vehicle() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.FeedEntity.vehicle)
  return _internal_vehicle();
}
inline void FeedEntity::unsafe_arena_set_allocated_vehicle(::transit_realtime::VehiclePosition* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vehicle_);
  }
  _impl_.vehicle_ = reinterpret_cast<::transit_realtime::VehiclePosition*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.FeedEntity.vehicle)
}
inline ::transit_realtime::VehiclePosition* FeedEntity::release_vehicle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::transit_realtime::VehiclePosition* released = _impl_.vehicle_;
  _impl_.vehicle_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::transit_realtime::VehiclePosition* FeedEntity::unsafe_arena_release_vehicle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.FeedEntity.vehicle)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::transit_realtime::VehiclePosition* temp = _impl_.vehicle_;
  _impl_.vehicle_ = nullptr;
  return temp;
}
inline ::transit_realtime::VehiclePosition* FeedEntity::_internal_mutable_vehicle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.vehicle_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::transit_realtime::VehiclePosition>(GetArena());
    _impl_.vehicle_ = reinterpret_cast<::transit_realtime::VehiclePosition*>(p);
  }
  return _impl_.vehicle_;
}
inline ::transit_realtime::VehiclePosition* FeedEntity::mutable_vehicle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::transit_realtime::VehiclePosition* _msg = _internal_mutable_vehicle();
  // @@protoc_insertion_point(field_mutable:transit_realtime.FeedEntity.vehicle)
  return _msg;
}
inline void FeedEntity::set_allocated_vehicle(::transit_realtime::VehiclePosition* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.vehicle_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.vehicle_ = reinterpret_cast<::transit_realtime::VehiclePosition*>(value);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.FeedEntity.vehicle)
}

// optional .transit_realtime.Alert alert = 5;
inline bool FeedEntity::has_alert() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.alert_ != nullptr);
  return value;
}
inline void FeedEntity::clear_alert() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.alert_ != nullptr) _impl_.alert_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::transit_realtime::Alert& FeedEntity::_internal_alert() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::transit_realtime::Alert* p = _impl_.alert_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::Alert&>(::transit_realtime::_Alert_default_instance_);
}
inline const ::transit_realtime::Alert& FeedEntity::alert() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.FeedEntity.alert)
  return _internal_alert();
}
inline void FeedEntity::unsafe_arena_set_allocated_alert(::transit_realtime::Alert* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.alert_);
  }
  _impl_.alert_ = reinterpret_cast<::transit_realtime::Alert*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.FeedEntity.alert)
}
inline ::transit_realtime::Alert* FeedEntity::release_alert() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::transit_realtime::Alert* released = _impl_.alert_;
  _impl_.alert_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::transit_realtime::Alert* FeedEntity::unsafe_arena_release_alert() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.FeedEntity.alert)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::transit_realtime::Alert* temp = _impl_.alert_;
  _impl_.alert_ = nullptr;
  return temp;
}
inline ::transit_realtime::Alert* FeedEntity::_internal_mutable_alert() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.alert_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::transit_realtime::Alert>(GetArena());
    _impl_.alert_ = reinterpret_cast<::transit_realtime::Alert*>(p);
  }
  return _impl_.alert_;
}
inline ::transit_realtime::Alert* FeedEntity::mutable_alert() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::transit_realtime::Alert* _msg = _internal_mutable_alert();
  // @@protoc_insertion_point(field_mutable:transit_realtime.FeedEntity.alert)
  return _msg;
}
inline void FeedEntity::set_allocated_alert(::transit_realtime::Alert* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.alert_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.alert_ = reinterpret_cast<::transit_realtime::Alert*>(value);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.FeedEntity.alert)
}

// optional .transit_realtime.Shape shape = 6;
inline bool FeedEntity::has_shape() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.shape_ != nullptr);
  return value;
}
inline void FeedEntity::clear_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shape_ != nullptr) _impl_.shape_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::transit_realtime::Shape& FeedEntity::_internal_shape() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::transit_realtime::Shape* p = _impl_.shape_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::Shape&>(::transit_realtime::_Shape_default_instance_);
}
inline const ::transit_realtime::Shape& FeedEntity::shape() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.FeedEntity.shape)
  return _internal_shape();
}
inline void FeedEntity::unsafe_arena_set_allocated_shape(::transit_realtime::Shape* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shape_);
  }
  _impl_.shape_ = reinterpret_cast<::transit_realtime::Shape*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.FeedEntity.shape)
}
inline ::transit_realtime::Shape* FeedEntity::release_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::transit_realtime::Shape* released = _impl_.shape_;
  _impl_.shape_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::transit_realtime::Shape* FeedEntity::unsafe_arena_release_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.FeedEntity.shape)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::transit_realtime::Shape* temp = _impl_.shape_;
  _impl_.shape_ = nullptr;
  return temp;
}
inline ::transit_realtime::Shape* FeedEntity::_internal_mutable_shape() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.shape_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::transit_realtime::Shape>(GetArena());
    _impl_.shape_ = reinterpret_cast<::transit_realtime::Shape*>(p);
  }
  return _impl_.shape_;
}
inline ::transit_realtime::Shape* FeedEntity::mutable_shape() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::transit_realtime::Shape* _msg = _internal_mutable_shape();
  // @@protoc_insertion_point(field_mutable:transit_realtime.FeedEntity.shape)
  return _msg;
}
inline void FeedEntity::set_allocated_shape(::transit_realtime::Shape* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.shape_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.shape_ = reinterpret_cast<::transit_realtime::Shape*>(value);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.FeedEntity.shape)
}

// optional .transit_realtime.Stop stop = 7;
inline bool FeedEntity::has_stop() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stop_ != nullptr);
  return value;
}
inline void FeedEntity::clear_stop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.stop_ != nullptr) _impl_.stop_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::transit_realtime::Stop& FeedEntity::_internal_stop() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::transit_realtime::Stop* p = _impl_.stop_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::Stop&>(::transit_realtime::_Stop_default_instance_);
}
inline const ::transit_realtime::Stop& FeedEntity::stop() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.FeedEntity.stop)
  return _internal_stop();
}
inline void FeedEntity::unsafe_arena_set_allocated_stop(::transit_realtime::Stop* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stop_);
  }
  _impl_.stop_ = reinterpret_cast<::transit_realtime::Stop*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.FeedEntity.stop)
}
inline ::transit_realtime::Stop* FeedEntity::release_stop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::transit_realtime::Stop* released = _impl_.stop_;
  _impl_.stop_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::transit_realtime::Stop* FeedEntity::unsafe_arena_release_stop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.FeedEntity.stop)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::transit_realtime::Stop* temp = _impl_.stop_;
  _impl_.stop_ = nullptr;
  return temp;
}
inline ::transit_realtime::Stop* FeedEntity::_internal_mutable_stop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.stop_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::transit_realtime::Stop>(GetArena());
    _impl_.stop_ = reinterpret_cast<::transit_realtime::Stop*>(p);
  }
  return _impl_.stop_;
}
inline ::transit_realtime::Stop* FeedEntity::mutable_stop() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::transit_realtime::Stop* _msg = _internal_mutable_stop();
  // @@protoc_insertion_point(field_mutable:transit_realtime.FeedEntity.stop)
  return _msg;
}
inline void FeedEntity::set_allocated_stop(::transit_realtime::Stop* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.stop_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.stop_ = reinterpret_cast<::transit_realtime::Stop*>(value);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.FeedEntity.stop)
}

// optional .transit_realtime.TripModifications trip_modifications = 8;
inline bool FeedEntity::has_trip_modifications() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.trip_modifications_ != nullptr);
  return value;
}
inline void FeedEntity::clear_trip_modifications() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.trip_modifications_ != nullptr) _impl_.trip_modifications_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::transit_realtime::TripModifications& FeedEntity::_internal_trip_modifications() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::transit_realtime::TripModifications* p = _impl_.trip_modifications_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TripModifications&>(::transit_realtime::_TripModifications_default_instance_);
}
inline const ::transit_realtime::TripModifications& FeedEntity::trip_modifications() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.FeedEntity.trip_modifications)
  return _internal_trip_modifications();
}
inline void FeedEntity::unsafe_arena_set_allocated_trip_modifications(::transit_realtime::TripModifications* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.trip_modifications_);
  }
  _impl_.trip_modifications_ = reinterpret_cast<::transit_realtime::TripModifications*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.FeedEntity.trip_modifications)
}
inline ::transit_realtime::TripModifications* FeedEntity::release_trip_modifications() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::transit_realtime::TripModifications* released = _impl_.trip_modifications_;
  _impl_.trip_modifications_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::transit_realtime::TripModifications* FeedEntity::unsafe_arena_release_trip_modifications() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.FeedEntity.trip_modifications)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::transit_realtime::TripModifications* temp = _impl_.trip_modifications_;
  _impl_.trip_modifications_ = nullptr;
  return temp;
}
inline ::transit_realtime::TripModifications* FeedEntity::_internal_mutable_trip_modifications() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.trip_modifications_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::transit_realtime::TripModifications>(GetArena());
    _impl_.trip_modifications_ = reinterpret_cast<::transit_realtime::TripModifications*>(p);
  }
  return _impl_.trip_modifications_;
}
inline ::transit_realtime::TripModifications* FeedEntity::mutable_trip_modifications() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000040u;
  ::transit_realtime::TripModifications* _msg = _internal_mutable_trip_modifications();
  // @@protoc_insertion_point(field_mutable:transit_realtime.FeedEntity.trip_modifications)
  return _msg;
}
inline void FeedEntity::set_allocated_trip_modifications(::transit_realtime::TripModifications* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.trip_modifications_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.trip_modifications_ = reinterpret_cast<::transit_realtime::TripModifications*>(value);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.FeedEntity.trip_modifications)
}

// -------------------------------------------------------------------

// TripUpdate_StopTimeEvent

// optional int32 delay = 1;
inline bool TripUpdate_StopTimeEvent::has_delay() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TripUpdate_StopTimeEvent::clear_delay() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delay_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t TripUpdate_StopTimeEvent::delay() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.StopTimeEvent.delay)
  return _internal_delay();
}
inline void TripUpdate_StopTimeEvent::set_delay(::int32_t value) {
  _internal_set_delay(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:transit_realtime.TripUpdate.StopTimeEvent.delay)
}
inline ::int32_t TripUpdate_StopTimeEvent::_internal_delay() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.delay_;
}
inline void TripUpdate_StopTimeEvent::_internal_set_delay(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delay_ = value;
}

// optional int64 time = 2;
inline bool TripUpdate_StopTimeEvent::has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TripUpdate_StopTimeEvent::clear_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t TripUpdate_StopTimeEvent::time() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.StopTimeEvent.time)
  return _internal_time();
}
inline void TripUpdate_StopTimeEvent::set_time(::int64_t value) {
  _internal_set_time(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:transit_realtime.TripUpdate.StopTimeEvent.time)
}
inline ::int64_t TripUpdate_StopTimeEvent::_internal_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_;
}
inline void TripUpdate_StopTimeEvent::_internal_set_time(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = value;
}

// optional int32 uncertainty = 3;
inline bool TripUpdate_StopTimeEvent::has_uncertainty() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void TripUpdate_StopTimeEvent::clear_uncertainty() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uncertainty_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t TripUpdate_StopTimeEvent::uncertainty() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.StopTimeEvent.uncertainty)
  return _internal_uncertainty();
}
inline void TripUpdate_StopTimeEvent::set_uncertainty(::int32_t value) {
  _internal_set_uncertainty(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:transit_realtime.TripUpdate.StopTimeEvent.uncertainty)
}
inline ::int32_t TripUpdate_StopTimeEvent::_internal_uncertainty() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.uncertainty_;
}
inline void TripUpdate_StopTimeEvent::_internal_set_uncertainty(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uncertainty_ = value;
}

// -------------------------------------------------------------------

// TripUpdate_StopTimeUpdate_StopTimeProperties

// optional string assigned_stop_id = 1;
inline bool TripUpdate_StopTimeUpdate_StopTimeProperties::has_assigned_stop_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TripUpdate_StopTimeUpdate_StopTimeProperties::clear_assigned_stop_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.assigned_stop_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TripUpdate_StopTimeUpdate_StopTimeProperties::assigned_stop_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties.assigned_stop_id)
  return _internal_assigned_stop_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TripUpdate_StopTimeUpdate_StopTimeProperties::set_assigned_stop_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.assigned_stop_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties.assigned_stop_id)
}
inline std::string* TripUpdate_StopTimeUpdate_StopTimeProperties::mutable_assigned_stop_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_assigned_stop_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties.assigned_stop_id)
  return _s;
}
inline const std::string& TripUpdate_StopTimeUpdate_StopTimeProperties::_internal_assigned_stop_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.assigned_stop_id_.Get();
}
inline void TripUpdate_StopTimeUpdate_StopTimeProperties::_internal_set_assigned_stop_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.assigned_stop_id_.Set(value, GetArena());
}
inline std::string* TripUpdate_StopTimeUpdate_StopTimeProperties::_internal_mutable_assigned_stop_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.assigned_stop_id_.Mutable( GetArena());
}
inline std::string* TripUpdate_StopTimeUpdate_StopTimeProperties::release_assigned_stop_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties.assigned_stop_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.assigned_stop_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.assigned_stop_id_.Set("", GetArena());
  }
  return released;
}
inline void TripUpdate_StopTimeUpdate_StopTimeProperties::set_allocated_assigned_stop_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.assigned_stop_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.assigned_stop_id_.IsDefault()) {
    _impl_.assigned_stop_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties.assigned_stop_id)
}

// -------------------------------------------------------------------

// TripUpdate_StopTimeUpdate

// optional uint32 stop_sequence = 1;
inline bool TripUpdate_StopTimeUpdate::has_stop_sequence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void TripUpdate_StopTimeUpdate::clear_stop_sequence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stop_sequence_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t TripUpdate_StopTimeUpdate::stop_sequence() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.StopTimeUpdate.stop_sequence)
  return _internal_stop_sequence();
}
inline void TripUpdate_StopTimeUpdate::set_stop_sequence(::uint32_t value) {
  _internal_set_stop_sequence(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:transit_realtime.TripUpdate.StopTimeUpdate.stop_sequence)
}
inline ::uint32_t TripUpdate_StopTimeUpdate::_internal_stop_sequence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stop_sequence_;
}
inline void TripUpdate_StopTimeUpdate::_internal_set_stop_sequence(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stop_sequence_ = value;
}

// optional string stop_id = 4;
inline bool TripUpdate_StopTimeUpdate::has_stop_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TripUpdate_StopTimeUpdate::clear_stop_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stop_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TripUpdate_StopTimeUpdate::stop_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.StopTimeUpdate.stop_id)
  return _internal_stop_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TripUpdate_StopTimeUpdate::set_stop_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.stop_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:transit_realtime.TripUpdate.StopTimeUpdate.stop_id)
}
inline std::string* TripUpdate_StopTimeUpdate::mutable_stop_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_stop_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripUpdate.StopTimeUpdate.stop_id)
  return _s;
}
inline const std::string& TripUpdate_StopTimeUpdate::_internal_stop_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stop_id_.Get();
}
inline void TripUpdate_StopTimeUpdate::_internal_set_stop_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.stop_id_.Set(value, GetArena());
}
inline std::string* TripUpdate_StopTimeUpdate::_internal_mutable_stop_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.stop_id_.Mutable( GetArena());
}
inline std::string* TripUpdate_StopTimeUpdate::release_stop_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.TripUpdate.StopTimeUpdate.stop_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.stop_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.stop_id_.Set("", GetArena());
  }
  return released;
}
inline void TripUpdate_StopTimeUpdate::set_allocated_stop_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.stop_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.stop_id_.IsDefault()) {
    _impl_.stop_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripUpdate.StopTimeUpdate.stop_id)
}

// optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2;
inline bool TripUpdate_StopTimeUpdate::has_arrival() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.arrival_ != nullptr);
  return value;
}
inline void TripUpdate_StopTimeUpdate::clear_arrival() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.arrival_ != nullptr) _impl_.arrival_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::transit_realtime::TripUpdate_StopTimeEvent& TripUpdate_StopTimeUpdate::_internal_arrival() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::transit_realtime::TripUpdate_StopTimeEvent* p = _impl_.arrival_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TripUpdate_StopTimeEvent&>(::transit_realtime::_TripUpdate_StopTimeEvent_default_instance_);
}
inline const ::transit_realtime::TripUpdate_StopTimeEvent& TripUpdate_StopTimeUpdate::arrival() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.StopTimeUpdate.arrival)
  return _internal_arrival();
}
inline void TripUpdate_StopTimeUpdate::unsafe_arena_set_allocated_arrival(::transit_realtime::TripUpdate_StopTimeEvent* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.arrival_);
  }
  _impl_.arrival_ = reinterpret_cast<::transit_realtime::TripUpdate_StopTimeEvent*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.TripUpdate.StopTimeUpdate.arrival)
}
inline ::transit_realtime::TripUpdate_StopTimeEvent* TripUpdate_StopTimeUpdate::release_arrival() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::transit_realtime::TripUpdate_StopTimeEvent* released = _impl_.arrival_;
  _impl_.arrival_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::transit_realtime::TripUpdate_StopTimeEvent* TripUpdate_StopTimeUpdate::unsafe_arena_release_arrival() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.TripUpdate.StopTimeUpdate.arrival)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::transit_realtime::TripUpdate_StopTimeEvent* temp = _impl_.arrival_;
  _impl_.arrival_ = nullptr;
  return temp;
}
inline ::transit_realtime::TripUpdate_StopTimeEvent* TripUpdate_StopTimeUpdate::_internal_mutable_arrival() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.arrival_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::transit_realtime::TripUpdate_StopTimeEvent>(GetArena());
    _impl_.arrival_ = reinterpret_cast<::transit_realtime::TripUpdate_StopTimeEvent*>(p);
  }
  return _impl_.arrival_;
}
inline ::transit_realtime::TripUpdate_StopTimeEvent* TripUpdate_StopTimeUpdate::mutable_arrival() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::transit_realtime::TripUpdate_StopTimeEvent* _msg = _internal_mutable_arrival();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripUpdate.StopTimeUpdate.arrival)
  return _msg;
}
inline void TripUpdate_StopTimeUpdate::set_allocated_arrival(::transit_realtime::TripUpdate_StopTimeEvent* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.arrival_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.arrival_ = reinterpret_cast<::transit_realtime::TripUpdate_StopTimeEvent*>(value);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripUpdate.StopTimeUpdate.arrival)
}

// optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3;
inline bool TripUpdate_StopTimeUpdate::has_departure() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.departure_ != nullptr);
  return value;
}
inline void TripUpdate_StopTimeUpdate::clear_departure() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.departure_ != nullptr) _impl_.departure_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::transit_realtime::TripUpdate_StopTimeEvent& TripUpdate_StopTimeUpdate::_internal_departure() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::transit_realtime::TripUpdate_StopTimeEvent* p = _impl_.departure_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TripUpdate_StopTimeEvent&>(::transit_realtime::_TripUpdate_StopTimeEvent_default_instance_);
}
inline const ::transit_realtime::TripUpdate_StopTimeEvent& TripUpdate_StopTimeUpdate::departure() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.StopTimeUpdate.departure)
  return _internal_departure();
}
inline void TripUpdate_StopTimeUpdate::unsafe_arena_set_allocated_departure(::transit_realtime::TripUpdate_StopTimeEvent* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.departure_);
  }
  _impl_.departure_ = reinterpret_cast<::transit_realtime::TripUpdate_StopTimeEvent*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.TripUpdate.StopTimeUpdate.departure)
}
inline ::transit_realtime::TripUpdate_StopTimeEvent* TripUpdate_StopTimeUpdate::release_departure() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::transit_realtime::TripUpdate_StopTimeEvent* released = _impl_.departure_;
  _impl_.departure_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::transit_realtime::TripUpdate_StopTimeEvent* TripUpdate_StopTimeUpdate::unsafe_arena_release_departure() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.TripUpdate.StopTimeUpdate.departure)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::transit_realtime::TripUpdate_StopTimeEvent* temp = _impl_.departure_;
  _impl_.departure_ = nullptr;
  return temp;
}
inline ::transit_realtime::TripUpdate_StopTimeEvent* TripUpdate_StopTimeUpdate::_internal_mutable_departure() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.departure_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::transit_realtime::TripUpdate_StopTimeEvent>(GetArena());
    _impl_.departure_ = reinterpret_cast<::transit_realtime::TripUpdate_StopTimeEvent*>(p);
  }
  return _impl_.departure_;
}
inline ::transit_realtime::TripUpdate_StopTimeEvent* TripUpdate_StopTimeUpdate::mutable_departure() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::transit_realtime::TripUpdate_StopTimeEvent* _msg = _internal_mutable_departure();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripUpdate.StopTimeUpdate.departure)
  return _msg;
}
inline void TripUpdate_StopTimeUpdate::set_allocated_departure(::transit_realtime::TripUpdate_StopTimeEvent* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.departure_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.departure_ = reinterpret_cast<::transit_realtime::TripUpdate_StopTimeEvent*>(value);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripUpdate.StopTimeUpdate.departure)
}

// optional .transit_realtime.VehiclePosition.OccupancyStatus departure_occupancy_status = 7;
inline bool TripUpdate_StopTimeUpdate::has_departure_occupancy_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void TripUpdate_StopTimeUpdate::clear_departure_occupancy_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.departure_occupancy_status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::transit_realtime::VehiclePosition_OccupancyStatus TripUpdate_StopTimeUpdate::departure_occupancy_status() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.StopTimeUpdate.departure_occupancy_status)
  return _internal_departure_occupancy_status();
}
inline void TripUpdate_StopTimeUpdate::set_departure_occupancy_status(::transit_realtime::VehiclePosition_OccupancyStatus value) {
  _internal_set_departure_occupancy_status(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:transit_realtime.TripUpdate.StopTimeUpdate.departure_occupancy_status)
}
inline ::transit_realtime::VehiclePosition_OccupancyStatus TripUpdate_StopTimeUpdate::_internal_departure_occupancy_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::transit_realtime::VehiclePosition_OccupancyStatus>(_impl_.departure_occupancy_status_);
}
inline void TripUpdate_StopTimeUpdate::_internal_set_departure_occupancy_status(::transit_realtime::VehiclePosition_OccupancyStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  assert(::transit_realtime::VehiclePosition_OccupancyStatus_IsValid(value));
  _impl_.departure_occupancy_status_ = value;
}

// optional .transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship = 5 [default = SCHEDULED];
inline bool TripUpdate_StopTimeUpdate::has_schedule_relationship() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void TripUpdate_StopTimeUpdate::clear_schedule_relationship() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.schedule_relationship_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship TripUpdate_StopTimeUpdate::schedule_relationship() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.StopTimeUpdate.schedule_relationship)
  return _internal_schedule_relationship();
}
inline void TripUpdate_StopTimeUpdate::set_schedule_relationship(::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship value) {
  _internal_set_schedule_relationship(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:transit_realtime.TripUpdate.StopTimeUpdate.schedule_relationship)
}
inline ::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship TripUpdate_StopTimeUpdate::_internal_schedule_relationship() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship>(_impl_.schedule_relationship_);
}
inline void TripUpdate_StopTimeUpdate::_internal_set_schedule_relationship(::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  assert(::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship_IsValid(value));
  _impl_.schedule_relationship_ = value;
}

// optional .transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties stop_time_properties = 6;
inline bool TripUpdate_StopTimeUpdate::has_stop_time_properties() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stop_time_properties_ != nullptr);
  return value;
}
inline void TripUpdate_StopTimeUpdate::clear_stop_time_properties() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.stop_time_properties_ != nullptr) _impl_.stop_time_properties_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties& TripUpdate_StopTimeUpdate::_internal_stop_time_properties() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties* p = _impl_.stop_time_properties_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties&>(::transit_realtime::_TripUpdate_StopTimeUpdate_StopTimeProperties_default_instance_);
}
inline const ::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties& TripUpdate_StopTimeUpdate::stop_time_properties() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.StopTimeUpdate.stop_time_properties)
  return _internal_stop_time_properties();
}
inline void TripUpdate_StopTimeUpdate::unsafe_arena_set_allocated_stop_time_properties(::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stop_time_properties_);
  }
  _impl_.stop_time_properties_ = reinterpret_cast<::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.TripUpdate.StopTimeUpdate.stop_time_properties)
}
inline ::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties* TripUpdate_StopTimeUpdate::release_stop_time_properties() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties* released = _impl_.stop_time_properties_;
  _impl_.stop_time_properties_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties* TripUpdate_StopTimeUpdate::unsafe_arena_release_stop_time_properties() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.TripUpdate.StopTimeUpdate.stop_time_properties)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties* temp = _impl_.stop_time_properties_;
  _impl_.stop_time_properties_ = nullptr;
  return temp;
}
inline ::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties* TripUpdate_StopTimeUpdate::_internal_mutable_stop_time_properties() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.stop_time_properties_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties>(GetArena());
    _impl_.stop_time_properties_ = reinterpret_cast<::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties*>(p);
  }
  return _impl_.stop_time_properties_;
}
inline ::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties* TripUpdate_StopTimeUpdate::mutable_stop_time_properties() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties* _msg = _internal_mutable_stop_time_properties();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripUpdate.StopTimeUpdate.stop_time_properties)
  return _msg;
}
inline void TripUpdate_StopTimeUpdate::set_allocated_stop_time_properties(::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.stop_time_properties_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.stop_time_properties_ = reinterpret_cast<::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties*>(value);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripUpdate.StopTimeUpdate.stop_time_properties)
}

// -------------------------------------------------------------------

// TripUpdate_TripProperties

// optional string trip_id = 1;
inline bool TripUpdate_TripProperties::has_trip_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TripUpdate_TripProperties::clear_trip_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.trip_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TripUpdate_TripProperties::trip_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.TripProperties.trip_id)
  return _internal_trip_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TripUpdate_TripProperties::set_trip_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.trip_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:transit_realtime.TripUpdate.TripProperties.trip_id)
}
inline std::string* TripUpdate_TripProperties::mutable_trip_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_trip_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripUpdate.TripProperties.trip_id)
  return _s;
}
inline const std::string& TripUpdate_TripProperties::_internal_trip_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.trip_id_.Get();
}
inline void TripUpdate_TripProperties::_internal_set_trip_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.trip_id_.Set(value, GetArena());
}
inline std::string* TripUpdate_TripProperties::_internal_mutable_trip_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.trip_id_.Mutable( GetArena());
}
inline std::string* TripUpdate_TripProperties::release_trip_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.TripUpdate.TripProperties.trip_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.trip_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.trip_id_.Set("", GetArena());
  }
  return released;
}
inline void TripUpdate_TripProperties::set_allocated_trip_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.trip_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.trip_id_.IsDefault()) {
    _impl_.trip_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripUpdate.TripProperties.trip_id)
}

// optional string start_date = 2;
inline bool TripUpdate_TripProperties::has_start_date() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TripUpdate_TripProperties::clear_start_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.start_date_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TripUpdate_TripProperties::start_date() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.TripProperties.start_date)
  return _internal_start_date();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TripUpdate_TripProperties::set_start_date(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.start_date_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:transit_realtime.TripUpdate.TripProperties.start_date)
}
inline std::string* TripUpdate_TripProperties::mutable_start_date() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_start_date();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripUpdate.TripProperties.start_date)
  return _s;
}
inline const std::string& TripUpdate_TripProperties::_internal_start_date() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.start_date_.Get();
}
inline void TripUpdate_TripProperties::_internal_set_start_date(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.start_date_.Set(value, GetArena());
}
inline std::string* TripUpdate_TripProperties::_internal_mutable_start_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.start_date_.Mutable( GetArena());
}
inline std::string* TripUpdate_TripProperties::release_start_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.TripUpdate.TripProperties.start_date)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.start_date_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.start_date_.Set("", GetArena());
  }
  return released;
}
inline void TripUpdate_TripProperties::set_allocated_start_date(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.start_date_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.start_date_.IsDefault()) {
    _impl_.start_date_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripUpdate.TripProperties.start_date)
}

// optional string start_time = 3;
inline bool TripUpdate_TripProperties::has_start_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void TripUpdate_TripProperties::clear_start_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.start_time_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TripUpdate_TripProperties::start_time() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.TripProperties.start_time)
  return _internal_start_time();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TripUpdate_TripProperties::set_start_time(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.start_time_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:transit_realtime.TripUpdate.TripProperties.start_time)
}
inline std::string* TripUpdate_TripProperties::mutable_start_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_start_time();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripUpdate.TripProperties.start_time)
  return _s;
}
inline const std::string& TripUpdate_TripProperties::_internal_start_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.start_time_.Get();
}
inline void TripUpdate_TripProperties::_internal_set_start_time(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.start_time_.Set(value, GetArena());
}
inline std::string* TripUpdate_TripProperties::_internal_mutable_start_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.start_time_.Mutable( GetArena());
}
inline std::string* TripUpdate_TripProperties::release_start_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.TripUpdate.TripProperties.start_time)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.start_time_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.start_time_.Set("", GetArena());
  }
  return released;
}
inline void TripUpdate_TripProperties::set_allocated_start_time(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.start_time_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.start_time_.IsDefault()) {
    _impl_.start_time_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripUpdate.TripProperties.start_time)
}

// optional string shape_id = 4;
inline bool TripUpdate_TripProperties::has_shape_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void TripUpdate_TripProperties::clear_shape_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& TripUpdate_TripProperties::shape_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.TripProperties.shape_id)
  return _internal_shape_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TripUpdate_TripProperties::set_shape_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.shape_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:transit_realtime.TripUpdate.TripProperties.shape_id)
}
inline std::string* TripUpdate_TripProperties::mutable_shape_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_shape_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripUpdate.TripProperties.shape_id)
  return _s;
}
inline const std::string& TripUpdate_TripProperties::_internal_shape_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shape_id_.Get();
}
inline void TripUpdate_TripProperties::_internal_set_shape_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.shape_id_.Set(value, GetArena());
}
inline std::string* TripUpdate_TripProperties::_internal_mutable_shape_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.shape_id_.Mutable( GetArena());
}
inline std::string* TripUpdate_TripProperties::release_shape_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.TripUpdate.TripProperties.shape_id)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.shape_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.shape_id_.Set("", GetArena());
  }
  return released;
}
inline void TripUpdate_TripProperties::set_allocated_shape_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.shape_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.shape_id_.IsDefault()) {
    _impl_.shape_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripUpdate.TripProperties.shape_id)
}

// -------------------------------------------------------------------

// TripUpdate

// required .transit_realtime.TripDescriptor trip = 1;
inline bool TripUpdate::has_trip() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.trip_ != nullptr);
  return value;
}
inline void TripUpdate::clear_trip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.trip_ != nullptr) _impl_.trip_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::transit_realtime::TripDescriptor& TripUpdate::_internal_trip() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::transit_realtime::TripDescriptor* p = _impl_.trip_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TripDescriptor&>(::transit_realtime::_TripDescriptor_default_instance_);
}
inline const ::transit_realtime::TripDescriptor& TripUpdate::trip() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.trip)
  return _internal_trip();
}
inline void TripUpdate::unsafe_arena_set_allocated_trip(::transit_realtime::TripDescriptor* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.trip_);
  }
  _impl_.trip_ = reinterpret_cast<::transit_realtime::TripDescriptor*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.TripUpdate.trip)
}
inline ::transit_realtime::TripDescriptor* TripUpdate::release_trip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::transit_realtime::TripDescriptor* released = _impl_.trip_;
  _impl_.trip_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::transit_realtime::TripDescriptor* TripUpdate::unsafe_arena_release_trip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.TripUpdate.trip)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::transit_realtime::TripDescriptor* temp = _impl_.trip_;
  _impl_.trip_ = nullptr;
  return temp;
}
inline ::transit_realtime::TripDescriptor* TripUpdate::_internal_mutable_trip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.trip_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::transit_realtime::TripDescriptor>(GetArena());
    _impl_.trip_ = reinterpret_cast<::transit_realtime::TripDescriptor*>(p);
  }
  return _impl_.trip_;
}
inline ::transit_realtime::TripDescriptor* TripUpdate::mutable_trip() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::transit_realtime::TripDescriptor* _msg = _internal_mutable_trip();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripUpdate.trip)
  return _msg;
}
inline void TripUpdate::set_allocated_trip(::transit_realtime::TripDescriptor* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.trip_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.trip_ = reinterpret_cast<::transit_realtime::TripDescriptor*>(value);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripUpdate.trip)
}

// optional .transit_realtime.VehicleDescriptor vehicle = 3;
inline bool TripUpdate::has_vehicle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.vehicle_ != nullptr);
  return value;
}
inline void TripUpdate::clear_vehicle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.vehicle_ != nullptr) _impl_.vehicle_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::transit_realtime::VehicleDescriptor& TripUpdate::_internal_vehicle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::transit_realtime::VehicleDescriptor* p = _impl_.vehicle_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::VehicleDescriptor&>(::transit_realtime::_VehicleDescriptor_default_instance_);
}
inline const ::transit_realtime::VehicleDescriptor& TripUpdate::vehicle() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.vehicle)
  return _internal_vehicle();
}
inline void TripUpdate::unsafe_arena_set_allocated_vehicle(::transit_realtime::VehicleDescriptor* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vehicle_);
  }
  _impl_.vehicle_ = reinterpret_cast<::transit_realtime::VehicleDescriptor*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.TripUpdate.vehicle)
}
inline ::transit_realtime::VehicleDescriptor* TripUpdate::release_vehicle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::transit_realtime::VehicleDescriptor* released = _impl_.vehicle_;
  _impl_.vehicle_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::transit_realtime::VehicleDescriptor* TripUpdate::unsafe_arena_release_vehicle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.TripUpdate.vehicle)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::transit_realtime::VehicleDescriptor* temp = _impl_.vehicle_;
  _impl_.vehicle_ = nullptr;
  return temp;
}
inline ::transit_realtime::VehicleDescriptor* TripUpdate::_internal_mutable_vehicle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.vehicle_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::transit_realtime::VehicleDescriptor>(GetArena());
    _impl_.vehicle_ = reinterpret_cast<::transit_realtime::VehicleDescriptor*>(p);
  }
  return _impl_.vehicle_;
}
inline ::transit_realtime::VehicleDescriptor* TripUpdate::mutable_vehicle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::transit_realtime::VehicleDescriptor* _msg = _internal_mutable_vehicle();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripUpdate.vehicle)
  return _msg;
}
inline void TripUpdate::set_allocated_vehicle(::transit_realtime::VehicleDescriptor* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.vehicle_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.vehicle_ = reinterpret_cast<::transit_realtime::VehicleDescriptor*>(value);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripUpdate.vehicle)
}

// repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;
inline int TripUpdate::_internal_stop_time_update_size() const {
  return _internal_stop_time_update().size();
}
inline int TripUpdate::stop_time_update_size() const {
  return _internal_stop_time_update_size();
}
inline void TripUpdate::clear_stop_time_update() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stop_time_update_.Clear();
}
inline ::transit_realtime::TripUpdate_StopTimeUpdate* TripUpdate::mutable_stop_time_update(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripUpdate.stop_time_update)
  return _internal_mutable_stop_time_update()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::transit_realtime::TripUpdate_StopTimeUpdate>* TripUpdate::mutable_stop_time_update()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:transit_realtime.TripUpdate.stop_time_update)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_stop_time_update();
}
inline const ::transit_realtime::TripUpdate_StopTimeUpdate& TripUpdate::stop_time_update(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.stop_time_update)
  return _internal_stop_time_update().Get(index);
}
inline ::transit_realtime::TripUpdate_StopTimeUpdate* TripUpdate::add_stop_time_update() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::transit_realtime::TripUpdate_StopTimeUpdate* _add = _internal_mutable_stop_time_update()->Add();
  // @@protoc_insertion_point(field_add:transit_realtime.TripUpdate.stop_time_update)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::transit_realtime::TripUpdate_StopTimeUpdate>& TripUpdate::stop_time_update() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:transit_realtime.TripUpdate.stop_time_update)
  return _internal_stop_time_update();
}
inline const ::google::protobuf::RepeatedPtrField<::transit_realtime::TripUpdate_StopTimeUpdate>&
TripUpdate::_internal_stop_time_update() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stop_time_update_;
}
inline ::google::protobuf::RepeatedPtrField<::transit_realtime::TripUpdate_StopTimeUpdate>*
TripUpdate::_internal_mutable_stop_time_update() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.stop_time_update_;
}

// optional uint64 timestamp = 4;
inline bool TripUpdate::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void TripUpdate::clear_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t TripUpdate::timestamp() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.timestamp)
  return _internal_timestamp();
}
inline void TripUpdate::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:transit_realtime.TripUpdate.timestamp)
}
inline ::uint64_t TripUpdate::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timestamp_;
}
inline void TripUpdate::_internal_set_timestamp(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = value;
}

// optional int32 delay = 5;
inline bool TripUpdate::has_delay() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void TripUpdate::clear_delay() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delay_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t TripUpdate::delay() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.delay)
  return _internal_delay();
}
inline void TripUpdate::set_delay(::int32_t value) {
  _internal_set_delay(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:transit_realtime.TripUpdate.delay)
}
inline ::int32_t TripUpdate::_internal_delay() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.delay_;
}
inline void TripUpdate::_internal_set_delay(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.delay_ = value;
}

// optional .transit_realtime.TripUpdate.TripProperties trip_properties = 6;
inline bool TripUpdate::has_trip_properties() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.trip_properties_ != nullptr);
  return value;
}
inline void TripUpdate::clear_trip_properties() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.trip_properties_ != nullptr) _impl_.trip_properties_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::transit_realtime::TripUpdate_TripProperties& TripUpdate::_internal_trip_properties() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::transit_realtime::TripUpdate_TripProperties* p = _impl_.trip_properties_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TripUpdate_TripProperties&>(::transit_realtime::_TripUpdate_TripProperties_default_instance_);
}
inline const ::transit_realtime::TripUpdate_TripProperties& TripUpdate::trip_properties() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.trip_properties)
  return _internal_trip_properties();
}
inline void TripUpdate::unsafe_arena_set_allocated_trip_properties(::transit_realtime::TripUpdate_TripProperties* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.trip_properties_);
  }
  _impl_.trip_properties_ = reinterpret_cast<::transit_realtime::TripUpdate_TripProperties*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.TripUpdate.trip_properties)
}
inline ::transit_realtime::TripUpdate_TripProperties* TripUpdate::release_trip_properties() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::transit_realtime::TripUpdate_TripProperties* released = _impl_.trip_properties_;
  _impl_.trip_properties_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::transit_realtime::TripUpdate_TripProperties* TripUpdate::unsafe_arena_release_trip_properties() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.TripUpdate.trip_properties)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::transit_realtime::TripUpdate_TripProperties* temp = _impl_.trip_properties_;
  _impl_.trip_properties_ = nullptr;
  return temp;
}
inline ::transit_realtime::TripUpdate_TripProperties* TripUpdate::_internal_mutable_trip_properties() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.trip_properties_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::transit_realtime::TripUpdate_TripProperties>(GetArena());
    _impl_.trip_properties_ = reinterpret_cast<::transit_realtime::TripUpdate_TripProperties*>(p);
  }
  return _impl_.trip_properties_;
}
inline ::transit_realtime::TripUpdate_TripProperties* TripUpdate::mutable_trip_properties() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::transit_realtime::TripUpdate_TripProperties* _msg = _internal_mutable_trip_properties();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripUpdate.trip_properties)
  return _msg;
}
inline void TripUpdate::set_allocated_trip_properties(::transit_realtime::TripUpdate_TripProperties* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.trip_properties_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.trip_properties_ = reinterpret_cast<::transit_realtime::TripUpdate_TripProperties*>(value);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripUpdate.trip_properties)
}

// -------------------------------------------------------------------

// VehiclePosition_CarriageDetails

// optional string id = 1;
inline bool VehiclePosition_CarriageDetails::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void VehiclePosition_CarriageDetails::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VehiclePosition_CarriageDetails::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.CarriageDetails.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VehiclePosition_CarriageDetails::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:transit_realtime.VehiclePosition.CarriageDetails.id)
}
inline std::string* VehiclePosition_CarriageDetails::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.VehiclePosition.CarriageDetails.id)
  return _s;
}
inline const std::string& VehiclePosition_CarriageDetails::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void VehiclePosition_CarriageDetails::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* VehiclePosition_CarriageDetails::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* VehiclePosition_CarriageDetails::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.VehiclePosition.CarriageDetails.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.id_.Set("", GetArena());
  }
  return released;
}
inline void VehiclePosition_CarriageDetails::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.VehiclePosition.CarriageDetails.id)
}

// optional string label = 2;
inline bool VehiclePosition_CarriageDetails::has_label() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void VehiclePosition_CarriageDetails::clear_label() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.label_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& VehiclePosition_CarriageDetails::label() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.CarriageDetails.label)
  return _internal_label();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VehiclePosition_CarriageDetails::set_label(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.label_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:transit_realtime.VehiclePosition.CarriageDetails.label)
}
inline std::string* VehiclePosition_CarriageDetails::mutable_label() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:transit_realtime.VehiclePosition.CarriageDetails.label)
  return _s;
}
inline const std::string& VehiclePosition_CarriageDetails::_internal_label() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.label_.Get();
}
inline void VehiclePosition_CarriageDetails::_internal_set_label(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.label_.Set(value, GetArena());
}
inline std::string* VehiclePosition_CarriageDetails::_internal_mutable_label() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.label_.Mutable( GetArena());
}
inline std::string* VehiclePosition_CarriageDetails::release_label() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.VehiclePosition.CarriageDetails.label)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.label_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.label_.Set("", GetArena());
  }
  return released;
}
inline void VehiclePosition_CarriageDetails::set_allocated_label(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.label_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.label_.IsDefault()) {
    _impl_.label_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.VehiclePosition.CarriageDetails.label)
}

// optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 3 [default = NO_DATA_AVAILABLE];
inline bool VehiclePosition_CarriageDetails::has_occupancy_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void VehiclePosition_CarriageDetails::clear_occupancy_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.occupancy_status_ = 7;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::transit_realtime::VehiclePosition_OccupancyStatus VehiclePosition_CarriageDetails::occupancy_status() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.CarriageDetails.occupancy_status)
  return _internal_occupancy_status();
}
inline void VehiclePosition_CarriageDetails::set_occupancy_status(::transit_realtime::VehiclePosition_OccupancyStatus value) {
  _internal_set_occupancy_status(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:transit_realtime.VehiclePosition.CarriageDetails.occupancy_status)
}
inline ::transit_realtime::VehiclePosition_OccupancyStatus VehiclePosition_CarriageDetails::_internal_occupancy_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::transit_realtime::VehiclePosition_OccupancyStatus>(_impl_.occupancy_status_);
}
inline void VehiclePosition_CarriageDetails::_internal_set_occupancy_status(::transit_realtime::VehiclePosition_OccupancyStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  assert(::transit_realtime::VehiclePosition_OccupancyStatus_IsValid(value));
  _impl_.occupancy_status_ = value;
}

// optional int32 occupancy_percentage = 4 [default = -1];
inline bool VehiclePosition_CarriageDetails::has_occupancy_percentage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void VehiclePosition_CarriageDetails::clear_occupancy_percentage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.occupancy_percentage_ = -1;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t VehiclePosition_CarriageDetails::occupancy_percentage() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.CarriageDetails.occupancy_percentage)
  return _internal_occupancy_percentage();
}
inline void VehiclePosition_CarriageDetails::set_occupancy_percentage(::int32_t value) {
  _internal_set_occupancy_percentage(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:transit_realtime.VehiclePosition.CarriageDetails.occupancy_percentage)
}
inline ::int32_t VehiclePosition_CarriageDetails::_internal_occupancy_percentage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.occupancy_percentage_;
}
inline void VehiclePosition_CarriageDetails::_internal_set_occupancy_percentage(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.occupancy_percentage_ = value;
}

// optional uint32 carriage_sequence = 5;
inline bool VehiclePosition_CarriageDetails::has_carriage_sequence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void VehiclePosition_CarriageDetails::clear_carriage_sequence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.carriage_sequence_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t VehiclePosition_CarriageDetails::carriage_sequence() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.CarriageDetails.carriage_sequence)
  return _internal_carriage_sequence();
}
inline void VehiclePosition_CarriageDetails::set_carriage_sequence(::uint32_t value) {
  _internal_set_carriage_sequence(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:transit_realtime.VehiclePosition.CarriageDetails.carriage_sequence)
}
inline ::uint32_t VehiclePosition_CarriageDetails::_internal_carriage_sequence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.carriage_sequence_;
}
inline void VehiclePosition_CarriageDetails::_internal_set_carriage_sequence(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.carriage_sequence_ = value;
}

// -------------------------------------------------------------------

// VehiclePosition

// optional .transit_realtime.TripDescriptor trip = 1;
inline bool VehiclePosition::has_trip() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.trip_ != nullptr);
  return value;
}
inline void VehiclePosition::clear_trip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.trip_ != nullptr) _impl_.trip_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::transit_realtime::TripDescriptor& VehiclePosition::_internal_trip() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::transit_realtime::TripDescriptor* p = _impl_.trip_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TripDescriptor&>(::transit_realtime::_TripDescriptor_default_instance_);
}
inline const ::transit_realtime::TripDescriptor& VehiclePosition::trip() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.trip)
  return _internal_trip();
}
inline void VehiclePosition::unsafe_arena_set_allocated_trip(::transit_realtime::TripDescriptor* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.trip_);
  }
  _impl_.trip_ = reinterpret_cast<::transit_realtime::TripDescriptor*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.VehiclePosition.trip)
}
inline ::transit_realtime::TripDescriptor* VehiclePosition::release_trip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::transit_realtime::TripDescriptor* released = _impl_.trip_;
  _impl_.trip_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::transit_realtime::TripDescriptor* VehiclePosition::unsafe_arena_release_trip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.VehiclePosition.trip)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::transit_realtime::TripDescriptor* temp = _impl_.trip_;
  _impl_.trip_ = nullptr;
  return temp;
}
inline ::transit_realtime::TripDescriptor* VehiclePosition::_internal_mutable_trip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.trip_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::transit_realtime::TripDescriptor>(GetArena());
    _impl_.trip_ = reinterpret_cast<::transit_realtime::TripDescriptor*>(p);
  }
  return _impl_.trip_;
}
inline ::transit_realtime::TripDescriptor* VehiclePosition::mutable_trip() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::transit_realtime::TripDescriptor* _msg = _internal_mutable_trip();
  // @@protoc_insertion_point(field_mutable:transit_realtime.VehiclePosition.trip)
  return _msg;
}
inline void VehiclePosition::set_allocated_trip(::transit_realtime::TripDescriptor* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.trip_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.trip_ = reinterpret_cast<::transit_realtime::TripDescriptor*>(value);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.VehiclePosition.trip)
}

// optional .transit_realtime.VehicleDescriptor vehicle = 8;
inline bool VehiclePosition::has_vehicle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.vehicle_ != nullptr);
  return value;
}
inline void VehiclePosition::clear_vehicle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.vehicle_ != nullptr) _impl_.vehicle_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::transit_realtime::VehicleDescriptor& VehiclePosition::_internal_vehicle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::transit_realtime::VehicleDescriptor* p = _impl_.vehicle_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::VehicleDescriptor&>(::transit_realtime::_VehicleDescriptor_default_instance_);
}
inline const ::transit_realtime::VehicleDescriptor& VehiclePosition::vehicle() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.vehicle)
  return _internal_vehicle();
}
inline void VehiclePosition::unsafe_arena_set_allocated_vehicle(::transit_realtime::VehicleDescriptor* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.vehicle_);
  }
  _impl_.vehicle_ = reinterpret_cast<::transit_realtime::VehicleDescriptor*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.VehiclePosition.vehicle)
}
inline ::transit_realtime::VehicleDescriptor* VehiclePosition::release_vehicle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::transit_realtime::VehicleDescriptor* released = _impl_.vehicle_;
  _impl_.vehicle_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::transit_realtime::VehicleDescriptor* VehiclePosition::unsafe_arena_release_vehicle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.VehiclePosition.vehicle)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::transit_realtime::VehicleDescriptor* temp = _impl_.vehicle_;
  _impl_.vehicle_ = nullptr;
  return temp;
}
inline ::transit_realtime::VehicleDescriptor* VehiclePosition::_internal_mutable_vehicle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.vehicle_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::transit_realtime::VehicleDescriptor>(GetArena());
    _impl_.vehicle_ = reinterpret_cast<::transit_realtime::VehicleDescriptor*>(p);
  }
  return _impl_.vehicle_;
}
inline ::transit_realtime::VehicleDescriptor* VehiclePosition::mutable_vehicle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::transit_realtime::VehicleDescriptor* _msg = _internal_mutable_vehicle();
  // @@protoc_insertion_point(field_mutable:transit_realtime.VehiclePosition.vehicle)
  return _msg;
}
inline void VehiclePosition::set_allocated_vehicle(::transit_realtime::VehicleDescriptor* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.vehicle_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.vehicle_ = reinterpret_cast<::transit_realtime::VehicleDescriptor*>(value);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.VehiclePosition.vehicle)
}

// optional .transit_realtime.Position position = 2;
inline bool VehiclePosition::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void VehiclePosition::clear_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::transit_realtime::Position& VehiclePosition::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::transit_realtime::Position* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::Position&>(::transit_realtime::_Position_default_instance_);
}
inline const ::transit_realtime::Position& VehiclePosition::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.position)
  return _internal_position();
}
inline void VehiclePosition::unsafe_arena_set_allocated_position(::transit_realtime::Position* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::transit_realtime::Position*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.VehiclePosition.position)
}
inline ::transit_realtime::Position* VehiclePosition::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::transit_realtime::Position* released = _impl_.position_;
  _impl_.position_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::transit_realtime::Position* VehiclePosition::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.VehiclePosition.position)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::transit_realtime::Position* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::transit_realtime::Position* VehiclePosition::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::transit_realtime::Position>(GetArena());
    _impl_.position_ = reinterpret_cast<::transit_realtime::Position*>(p);
  }
  return _impl_.position_;
}
inline ::transit_realtime::Position* VehiclePosition::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::transit_realtime::Position* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:transit_realtime.VehiclePosition.position)
  return _msg;
}
inline void VehiclePosition::set_allocated_position(::transit_realtime::Position* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.position_ = reinterpret_cast<::transit_realtime::Position*>(value);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.VehiclePosition.position)
}

// optional uint32 current_stop_sequence = 3;
inline bool VehiclePosition::has_current_stop_sequence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void VehiclePosition::clear_current_stop_sequence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_stop_sequence_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t VehiclePosition::current_stop_sequence() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.current_stop_sequence)
  return _internal_current_stop_sequence();
}
inline void VehiclePosition::set_current_stop_sequence(::uint32_t value) {
  _internal_set_current_stop_sequence(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:transit_realtime.VehiclePosition.current_stop_sequence)
}
inline ::uint32_t VehiclePosition::_internal_current_stop_sequence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.current_stop_sequence_;
}
inline void VehiclePosition::_internal_set_current_stop_sequence(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_stop_sequence_ = value;
}

// optional string stop_id = 7;
inline bool VehiclePosition::has_stop_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void VehiclePosition::clear_stop_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stop_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VehiclePosition::stop_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.stop_id)
  return _internal_stop_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VehiclePosition::set_stop_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.stop_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:transit_realtime.VehiclePosition.stop_id)
}
inline std::string* VehiclePosition::mutable_stop_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_stop_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.VehiclePosition.stop_id)
  return _s;
}
inline const std::string& VehiclePosition::_internal_stop_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stop_id_.Get();
}
inline void VehiclePosition::_internal_set_stop_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.stop_id_.Set(value, GetArena());
}
inline std::string* VehiclePosition::_internal_mutable_stop_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.stop_id_.Mutable( GetArena());
}
inline std::string* VehiclePosition::release_stop_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.VehiclePosition.stop_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.stop_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.stop_id_.Set("", GetArena());
  }
  return released;
}
inline void VehiclePosition::set_allocated_stop_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.stop_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.stop_id_.IsDefault()) {
    _impl_.stop_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.VehiclePosition.stop_id)
}

// optional .transit_realtime.VehiclePosition.VehicleStopStatus current_status = 4 [default = IN_TRANSIT_TO];
inline bool VehiclePosition::has_current_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void VehiclePosition::clear_current_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_status_ = 2;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::transit_realtime::VehiclePosition_VehicleStopStatus VehiclePosition::current_status() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.current_status)
  return _internal_current_status();
}
inline void VehiclePosition::set_current_status(::transit_realtime::VehiclePosition_VehicleStopStatus value) {
  _internal_set_current_status(value);
  _impl_._has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_set:transit_realtime.VehiclePosition.current_status)
}
inline ::transit_realtime::VehiclePosition_VehicleStopStatus VehiclePosition::_internal_current_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::transit_realtime::VehiclePosition_VehicleStopStatus>(_impl_.current_status_);
}
inline void VehiclePosition::_internal_set_current_status(::transit_realtime::VehiclePosition_VehicleStopStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  assert(::transit_realtime::VehiclePosition_VehicleStopStatus_IsValid(value));
  _impl_.current_status_ = value;
}

// optional uint64 timestamp = 5;
inline bool VehiclePosition::has_timestamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void VehiclePosition::clear_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint64_t VehiclePosition::timestamp() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.timestamp)
  return _internal_timestamp();
}
inline void VehiclePosition::set_timestamp(::uint64_t value) {
  _internal_set_timestamp(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:transit_realtime.VehiclePosition.timestamp)
}
inline ::uint64_t VehiclePosition::_internal_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.timestamp_;
}
inline void VehiclePosition::_internal_set_timestamp(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.timestamp_ = value;
}

// optional .transit_realtime.VehiclePosition.CongestionLevel congestion_level = 6;
inline bool VehiclePosition::has_congestion_level() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void VehiclePosition::clear_congestion_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.congestion_level_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::transit_realtime::VehiclePosition_CongestionLevel VehiclePosition::congestion_level() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.congestion_level)
  return _internal_congestion_level();
}
inline void VehiclePosition::set_congestion_level(::transit_realtime::VehiclePosition_CongestionLevel value) {
  _internal_set_congestion_level(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:transit_realtime.VehiclePosition.congestion_level)
}
inline ::transit_realtime::VehiclePosition_CongestionLevel VehiclePosition::_internal_congestion_level() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::transit_realtime::VehiclePosition_CongestionLevel>(_impl_.congestion_level_);
}
inline void VehiclePosition::_internal_set_congestion_level(::transit_realtime::VehiclePosition_CongestionLevel value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  assert(::transit_realtime::VehiclePosition_CongestionLevel_IsValid(value));
  _impl_.congestion_level_ = value;
}

// optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 9;
inline bool VehiclePosition::has_occupancy_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void VehiclePosition::clear_occupancy_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.occupancy_status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::transit_realtime::VehiclePosition_OccupancyStatus VehiclePosition::occupancy_status() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.occupancy_status)
  return _internal_occupancy_status();
}
inline void VehiclePosition::set_occupancy_status(::transit_realtime::VehiclePosition_OccupancyStatus value) {
  _internal_set_occupancy_status(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:transit_realtime.VehiclePosition.occupancy_status)
}
inline ::transit_realtime::VehiclePosition_OccupancyStatus VehiclePosition::_internal_occupancy_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::transit_realtime::VehiclePosition_OccupancyStatus>(_impl_.occupancy_status_);
}
inline void VehiclePosition::_internal_set_occupancy_status(::transit_realtime::VehiclePosition_OccupancyStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  assert(::transit_realtime::VehiclePosition_OccupancyStatus_IsValid(value));
  _impl_.occupancy_status_ = value;
}

// optional uint32 occupancy_percentage = 10;
inline bool VehiclePosition::has_occupancy_percentage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void VehiclePosition::clear_occupancy_percentage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.occupancy_percentage_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::uint32_t VehiclePosition::occupancy_percentage() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.occupancy_percentage)
  return _internal_occupancy_percentage();
}
inline void VehiclePosition::set_occupancy_percentage(::uint32_t value) {
  _internal_set_occupancy_percentage(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:transit_realtime.VehiclePosition.occupancy_percentage)
}
inline ::uint32_t VehiclePosition::_internal_occupancy_percentage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.occupancy_percentage_;
}
inline void VehiclePosition::_internal_set_occupancy_percentage(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.occupancy_percentage_ = value;
}

// repeated .transit_realtime.VehiclePosition.CarriageDetails multi_carriage_details = 11;
inline int VehiclePosition::_internal_multi_carriage_details_size() const {
  return _internal_multi_carriage_details().size();
}
inline int VehiclePosition::multi_carriage_details_size() const {
  return _internal_multi_carriage_details_size();
}
inline void VehiclePosition::clear_multi_carriage_details() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.multi_carriage_details_.Clear();
}
inline ::transit_realtime::VehiclePosition_CarriageDetails* VehiclePosition::mutable_multi_carriage_details(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:transit_realtime.VehiclePosition.multi_carriage_details)
  return _internal_mutable_multi_carriage_details()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::transit_realtime::VehiclePosition_CarriageDetails>* VehiclePosition::mutable_multi_carriage_details()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:transit_realtime.VehiclePosition.multi_carriage_details)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_multi_carriage_details();
}
inline const ::transit_realtime::VehiclePosition_CarriageDetails& VehiclePosition::multi_carriage_details(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.multi_carriage_details)
  return _internal_multi_carriage_details().Get(index);
}
inline ::transit_realtime::VehiclePosition_CarriageDetails* VehiclePosition::add_multi_carriage_details() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::transit_realtime::VehiclePosition_CarriageDetails* _add = _internal_mutable_multi_carriage_details()->Add();
  // @@protoc_insertion_point(field_add:transit_realtime.VehiclePosition.multi_carriage_details)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::transit_realtime::VehiclePosition_CarriageDetails>& VehiclePosition::multi_carriage_details() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:transit_realtime.VehiclePosition.multi_carriage_details)
  return _internal_multi_carriage_details();
}
inline const ::google::protobuf::RepeatedPtrField<::transit_realtime::VehiclePosition_CarriageDetails>&
VehiclePosition::_internal_multi_carriage_details() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.multi_carriage_details_;
}
inline ::google::protobuf::RepeatedPtrField<::transit_realtime::VehiclePosition_CarriageDetails>*
VehiclePosition::_internal_mutable_multi_carriage_details() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.multi_carriage_details_;
}

// -------------------------------------------------------------------

// Alert

// repeated .transit_realtime.TimeRange active_period = 1;
inline int Alert::_internal_active_period_size() const {
  return _internal_active_period().size();
}
inline int Alert::active_period_size() const {
  return _internal_active_period_size();
}
inline void Alert::clear_active_period() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.active_period_.Clear();
}
inline ::transit_realtime::TimeRange* Alert::mutable_active_period(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:transit_realtime.Alert.active_period)
  return _internal_mutable_active_period()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::transit_realtime::TimeRange>* Alert::mutable_active_period()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:transit_realtime.Alert.active_period)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_active_period();
}
inline const ::transit_realtime::TimeRange& Alert::active_period(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.Alert.active_period)
  return _internal_active_period().Get(index);
}
inline ::transit_realtime::TimeRange* Alert::add_active_period() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::transit_realtime::TimeRange* _add = _internal_mutable_active_period()->Add();
  // @@protoc_insertion_point(field_add:transit_realtime.Alert.active_period)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::transit_realtime::TimeRange>& Alert::active_period() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:transit_realtime.Alert.active_period)
  return _internal_active_period();
}
inline const ::google::protobuf::RepeatedPtrField<::transit_realtime::TimeRange>&
Alert::_internal_active_period() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.active_period_;
}
inline ::google::protobuf::RepeatedPtrField<::transit_realtime::TimeRange>*
Alert::_internal_mutable_active_period() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.active_period_;
}

// repeated .transit_realtime.EntitySelector informed_entity = 5;
inline int Alert::_internal_informed_entity_size() const {
  return _internal_informed_entity().size();
}
inline int Alert::informed_entity_size() const {
  return _internal_informed_entity_size();
}
inline void Alert::clear_informed_entity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.informed_entity_.Clear();
}
inline ::transit_realtime::EntitySelector* Alert::mutable_informed_entity(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:transit_realtime.Alert.informed_entity)
  return _internal_mutable_informed_entity()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::transit_realtime::EntitySelector>* Alert::mutable_informed_entity()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:transit_realtime.Alert.informed_entity)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_informed_entity();
}
inline const ::transit_realtime::EntitySelector& Alert::informed_entity(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.Alert.informed_entity)
  return _internal_informed_entity().Get(index);
}
inline ::transit_realtime::EntitySelector* Alert::add_informed_entity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::transit_realtime::EntitySelector* _add = _internal_mutable_informed_entity()->Add();
  // @@protoc_insertion_point(field_add:transit_realtime.Alert.informed_entity)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::transit_realtime::EntitySelector>& Alert::informed_entity() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:transit_realtime.Alert.informed_entity)
  return _internal_informed_entity();
}
inline const ::google::protobuf::RepeatedPtrField<::transit_realtime::EntitySelector>&
Alert::_internal_informed_entity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.informed_entity_;
}
inline ::google::protobuf::RepeatedPtrField<::transit_realtime::EntitySelector>*
Alert::_internal_mutable_informed_entity() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.informed_entity_;
}

// optional .transit_realtime.Alert.Cause cause = 6 [default = UNKNOWN_CAUSE];
inline bool Alert::has_cause() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void Alert::clear_cause() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cause_ = 1;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::transit_realtime::Alert_Cause Alert::cause() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Alert.cause)
  return _internal_cause();
}
inline void Alert::set_cause(::transit_realtime::Alert_Cause value) {
  _internal_set_cause(value);
  _impl_._has_bits_[0] |= 0x00000400u;
  // @@protoc_insertion_point(field_set:transit_realtime.Alert.cause)
}
inline ::transit_realtime::Alert_Cause Alert::_internal_cause() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::transit_realtime::Alert_Cause>(_impl_.cause_);
}
inline void Alert::_internal_set_cause(::transit_realtime::Alert_Cause value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  assert(::transit_realtime::Alert_Cause_IsValid(value));
  _impl_.cause_ = value;
}

// optional .transit_realtime.Alert.Effect effect = 7 [default = UNKNOWN_EFFECT];
inline bool Alert::has_effect() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void Alert::clear_effect() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.effect_ = 8;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::transit_realtime::Alert_Effect Alert::effect() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Alert.effect)
  return _internal_effect();
}
inline void Alert::set_effect(::transit_realtime::Alert_Effect value) {
  _internal_set_effect(value);
  _impl_._has_bits_[0] |= 0x00000800u;
  // @@protoc_insertion_point(field_set:transit_realtime.Alert.effect)
}
inline ::transit_realtime::Alert_Effect Alert::_internal_effect() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::transit_realtime::Alert_Effect>(_impl_.effect_);
}
inline void Alert::_internal_set_effect(::transit_realtime::Alert_Effect value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  assert(::transit_realtime::Alert_Effect_IsValid(value));
  _impl_.effect_ = value;
}

// optional .transit_realtime.TranslatedString url = 8;
inline bool Alert::has_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.url_ != nullptr);
  return value;
}
inline void Alert::clear_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.url_ != nullptr) _impl_.url_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::transit_realtime::TranslatedString& Alert::_internal_url() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::transit_realtime::TranslatedString* p = _impl_.url_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TranslatedString&>(::transit_realtime::_TranslatedString_default_instance_);
}
inline const ::transit_realtime::TranslatedString& Alert::url() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.Alert.url)
  return _internal_url();
}
inline void Alert::unsafe_arena_set_allocated_url(::transit_realtime::TranslatedString* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.url_);
  }
  _impl_.url_ = reinterpret_cast<::transit_realtime::TranslatedString*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.Alert.url)
}
inline ::transit_realtime::TranslatedString* Alert::release_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::transit_realtime::TranslatedString* released = _impl_.url_;
  _impl_.url_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::transit_realtime::TranslatedString* Alert::unsafe_arena_release_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.Alert.url)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::transit_realtime::TranslatedString* temp = _impl_.url_;
  _impl_.url_ = nullptr;
  return temp;
}
inline ::transit_realtime::TranslatedString* Alert::_internal_mutable_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.url_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::transit_realtime::TranslatedString>(GetArena());
    _impl_.url_ = reinterpret_cast<::transit_realtime::TranslatedString*>(p);
  }
  return _impl_.url_;
}
inline ::transit_realtime::TranslatedString* Alert::mutable_url() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::transit_realtime::TranslatedString* _msg = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:transit_realtime.Alert.url)
  return _msg;
}
inline void Alert::set_allocated_url(::transit_realtime::TranslatedString* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.url_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.url_ = reinterpret_cast<::transit_realtime::TranslatedString*>(value);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.Alert.url)
}

// optional .transit_realtime.TranslatedString header_text = 10;
inline bool Alert::has_header_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_text_ != nullptr);
  return value;
}
inline void Alert::clear_header_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.header_text_ != nullptr) _impl_.header_text_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::transit_realtime::TranslatedString& Alert::_internal_header_text() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::transit_realtime::TranslatedString* p = _impl_.header_text_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TranslatedString&>(::transit_realtime::_TranslatedString_default_instance_);
}
inline const ::transit_realtime::TranslatedString& Alert::header_text() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.Alert.header_text)
  return _internal_header_text();
}
inline void Alert::unsafe_arena_set_allocated_header_text(::transit_realtime::TranslatedString* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_text_);
  }
  _impl_.header_text_ = reinterpret_cast<::transit_realtime::TranslatedString*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.Alert.header_text)
}
inline ::transit_realtime::TranslatedString* Alert::release_header_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::transit_realtime::TranslatedString* released = _impl_.header_text_;
  _impl_.header_text_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::transit_realtime::TranslatedString* Alert::unsafe_arena_release_header_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.Alert.header_text)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::transit_realtime::TranslatedString* temp = _impl_.header_text_;
  _impl_.header_text_ = nullptr;
  return temp;
}
inline ::transit_realtime::TranslatedString* Alert::_internal_mutable_header_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.header_text_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::transit_realtime::TranslatedString>(GetArena());
    _impl_.header_text_ = reinterpret_cast<::transit_realtime::TranslatedString*>(p);
  }
  return _impl_.header_text_;
}
inline ::transit_realtime::TranslatedString* Alert::mutable_header_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::transit_realtime::TranslatedString* _msg = _internal_mutable_header_text();
  // @@protoc_insertion_point(field_mutable:transit_realtime.Alert.header_text)
  return _msg;
}
inline void Alert::set_allocated_header_text(::transit_realtime::TranslatedString* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.header_text_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.header_text_ = reinterpret_cast<::transit_realtime::TranslatedString*>(value);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.Alert.header_text)
}

// optional .transit_realtime.TranslatedString description_text = 11;
inline bool Alert::has_description_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.description_text_ != nullptr);
  return value;
}
inline void Alert::clear_description_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.description_text_ != nullptr) _impl_.description_text_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::transit_realtime::TranslatedString& Alert::_internal_description_text() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::transit_realtime::TranslatedString* p = _impl_.description_text_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TranslatedString&>(::transit_realtime::_TranslatedString_default_instance_);
}
inline const ::transit_realtime::TranslatedString& Alert::description_text() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.Alert.description_text)
  return _internal_description_text();
}
inline void Alert::unsafe_arena_set_allocated_description_text(::transit_realtime::TranslatedString* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.description_text_);
  }
  _impl_.description_text_ = reinterpret_cast<::transit_realtime::TranslatedString*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.Alert.description_text)
}
inline ::transit_realtime::TranslatedString* Alert::release_description_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::transit_realtime::TranslatedString* released = _impl_.description_text_;
  _impl_.description_text_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::transit_realtime::TranslatedString* Alert::unsafe_arena_release_description_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.Alert.description_text)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::transit_realtime::TranslatedString* temp = _impl_.description_text_;
  _impl_.description_text_ = nullptr;
  return temp;
}
inline ::transit_realtime::TranslatedString* Alert::_internal_mutable_description_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.description_text_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::transit_realtime::TranslatedString>(GetArena());
    _impl_.description_text_ = reinterpret_cast<::transit_realtime::TranslatedString*>(p);
  }
  return _impl_.description_text_;
}
inline ::transit_realtime::TranslatedString* Alert::mutable_description_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::transit_realtime::TranslatedString* _msg = _internal_mutable_description_text();
  // @@protoc_insertion_point(field_mutable:transit_realtime.Alert.description_text)
  return _msg;
}
inline void Alert::set_allocated_description_text(::transit_realtime::TranslatedString* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.description_text_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.description_text_ = reinterpret_cast<::transit_realtime::TranslatedString*>(value);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.Alert.description_text)
}

// optional .transit_realtime.TranslatedString tts_header_text = 12;
inline bool Alert::has_tts_header_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tts_header_text_ != nullptr);
  return value;
}
inline void Alert::clear_tts_header_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tts_header_text_ != nullptr) _impl_.tts_header_text_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::transit_realtime::TranslatedString& Alert::_internal_tts_header_text() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::transit_realtime::TranslatedString* p = _impl_.tts_header_text_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TranslatedString&>(::transit_realtime::_TranslatedString_default_instance_);
}
inline const ::transit_realtime::TranslatedString& Alert::tts_header_text() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.Alert.tts_header_text)
  return _internal_tts_header_text();
}
inline void Alert::unsafe_arena_set_allocated_tts_header_text(::transit_realtime::TranslatedString* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tts_header_text_);
  }
  _impl_.tts_header_text_ = reinterpret_cast<::transit_realtime::TranslatedString*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.Alert.tts_header_text)
}
inline ::transit_realtime::TranslatedString* Alert::release_tts_header_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::transit_realtime::TranslatedString* released = _impl_.tts_header_text_;
  _impl_.tts_header_text_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::transit_realtime::TranslatedString* Alert::unsafe_arena_release_tts_header_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.Alert.tts_header_text)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::transit_realtime::TranslatedString* temp = _impl_.tts_header_text_;
  _impl_.tts_header_text_ = nullptr;
  return temp;
}
inline ::transit_realtime::TranslatedString* Alert::_internal_mutable_tts_header_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tts_header_text_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::transit_realtime::TranslatedString>(GetArena());
    _impl_.tts_header_text_ = reinterpret_cast<::transit_realtime::TranslatedString*>(p);
  }
  return _impl_.tts_header_text_;
}
inline ::transit_realtime::TranslatedString* Alert::mutable_tts_header_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::transit_realtime::TranslatedString* _msg = _internal_mutable_tts_header_text();
  // @@protoc_insertion_point(field_mutable:transit_realtime.Alert.tts_header_text)
  return _msg;
}
inline void Alert::set_allocated_tts_header_text(::transit_realtime::TranslatedString* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.tts_header_text_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.tts_header_text_ = reinterpret_cast<::transit_realtime::TranslatedString*>(value);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.Alert.tts_header_text)
}

// optional .transit_realtime.TranslatedString tts_description_text = 13;
inline bool Alert::has_tts_description_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tts_description_text_ != nullptr);
  return value;
}
inline void Alert::clear_tts_description_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tts_description_text_ != nullptr) _impl_.tts_description_text_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::transit_realtime::TranslatedString& Alert::_internal_tts_description_text() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::transit_realtime::TranslatedString* p = _impl_.tts_description_text_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TranslatedString&>(::transit_realtime::_TranslatedString_default_instance_);
}
inline const ::transit_realtime::TranslatedString& Alert::tts_description_text() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.Alert.tts_description_text)
  return _internal_tts_description_text();
}
inline void Alert::unsafe_arena_set_allocated_tts_description_text(::transit_realtime::TranslatedString* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tts_description_text_);
  }
  _impl_.tts_description_text_ = reinterpret_cast<::transit_realtime::TranslatedString*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.Alert.tts_description_text)
}
inline ::transit_realtime::TranslatedString* Alert::release_tts_description_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::transit_realtime::TranslatedString* released = _impl_.tts_description_text_;
  _impl_.tts_description_text_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::transit_realtime::TranslatedString* Alert::unsafe_arena_release_tts_description_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.Alert.tts_description_text)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::transit_realtime::TranslatedString* temp = _impl_.tts_description_text_;
  _impl_.tts_description_text_ = nullptr;
  return temp;
}
inline ::transit_realtime::TranslatedString* Alert::_internal_mutable_tts_description_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tts_description_text_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::transit_realtime::TranslatedString>(GetArena());
    _impl_.tts_description_text_ = reinterpret_cast<::transit_realtime::TranslatedString*>(p);
  }
  return _impl_.tts_description_text_;
}
inline ::transit_realtime::TranslatedString* Alert::mutable_tts_description_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::transit_realtime::TranslatedString* _msg = _internal_mutable_tts_description_text();
  // @@protoc_insertion_point(field_mutable:transit_realtime.Alert.tts_description_text)
  return _msg;
}
inline void Alert::set_allocated_tts_description_text(::transit_realtime::TranslatedString* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.tts_description_text_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.tts_description_text_ = reinterpret_cast<::transit_realtime::TranslatedString*>(value);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.Alert.tts_description_text)
}

// optional .transit_realtime.Alert.SeverityLevel severity_level = 14 [default = UNKNOWN_SEVERITY];
inline bool Alert::has_severity_level() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void Alert::clear_severity_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.severity_level_ = 1;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::transit_realtime::Alert_SeverityLevel Alert::severity_level() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Alert.severity_level)
  return _internal_severity_level();
}
inline void Alert::set_severity_level(::transit_realtime::Alert_SeverityLevel value) {
  _internal_set_severity_level(value);
  _impl_._has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_set:transit_realtime.Alert.severity_level)
}
inline ::transit_realtime::Alert_SeverityLevel Alert::_internal_severity_level() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::transit_realtime::Alert_SeverityLevel>(_impl_.severity_level_);
}
inline void Alert::_internal_set_severity_level(::transit_realtime::Alert_SeverityLevel value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  assert(::transit_realtime::Alert_SeverityLevel_IsValid(value));
  _impl_.severity_level_ = value;
}

// optional .transit_realtime.TranslatedImage image = 15;
inline bool Alert::has_image() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.image_ != nullptr);
  return value;
}
inline void Alert::clear_image() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.image_ != nullptr) _impl_.image_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::transit_realtime::TranslatedImage& Alert::_internal_image() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::transit_realtime::TranslatedImage* p = _impl_.image_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TranslatedImage&>(::transit_realtime::_TranslatedImage_default_instance_);
}
inline const ::transit_realtime::TranslatedImage& Alert::image() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.Alert.image)
  return _internal_image();
}
inline void Alert::unsafe_arena_set_allocated_image(::transit_realtime::TranslatedImage* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.image_);
  }
  _impl_.image_ = reinterpret_cast<::transit_realtime::TranslatedImage*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.Alert.image)
}
inline ::transit_realtime::TranslatedImage* Alert::release_image() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::transit_realtime::TranslatedImage* released = _impl_.image_;
  _impl_.image_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::transit_realtime::TranslatedImage* Alert::unsafe_arena_release_image() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.Alert.image)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::transit_realtime::TranslatedImage* temp = _impl_.image_;
  _impl_.image_ = nullptr;
  return temp;
}
inline ::transit_realtime::TranslatedImage* Alert::_internal_mutable_image() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.image_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::transit_realtime::TranslatedImage>(GetArena());
    _impl_.image_ = reinterpret_cast<::transit_realtime::TranslatedImage*>(p);
  }
  return _impl_.image_;
}
inline ::transit_realtime::TranslatedImage* Alert::mutable_image() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::transit_realtime::TranslatedImage* _msg = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:transit_realtime.Alert.image)
  return _msg;
}
inline void Alert::set_allocated_image(::transit_realtime::TranslatedImage* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.image_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.image_ = reinterpret_cast<::transit_realtime::TranslatedImage*>(value);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.Alert.image)
}

// optional .transit_realtime.TranslatedString image_alternative_text = 16;
inline bool Alert::has_image_alternative_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.image_alternative_text_ != nullptr);
  return value;
}
inline void Alert::clear_image_alternative_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.image_alternative_text_ != nullptr) _impl_.image_alternative_text_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::transit_realtime::TranslatedString& Alert::_internal_image_alternative_text() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::transit_realtime::TranslatedString* p = _impl_.image_alternative_text_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TranslatedString&>(::transit_realtime::_TranslatedString_default_instance_);
}
inline const ::transit_realtime::TranslatedString& Alert::image_alternative_text() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.Alert.image_alternative_text)
  return _internal_image_alternative_text();
}
inline void Alert::unsafe_arena_set_allocated_image_alternative_text(::transit_realtime::TranslatedString* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.image_alternative_text_);
  }
  _impl_.image_alternative_text_ = reinterpret_cast<::transit_realtime::TranslatedString*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.Alert.image_alternative_text)
}
inline ::transit_realtime::TranslatedString* Alert::release_image_alternative_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::transit_realtime::TranslatedString* released = _impl_.image_alternative_text_;
  _impl_.image_alternative_text_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::transit_realtime::TranslatedString* Alert::unsafe_arena_release_image_alternative_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.Alert.image_alternative_text)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::transit_realtime::TranslatedString* temp = _impl_.image_alternative_text_;
  _impl_.image_alternative_text_ = nullptr;
  return temp;
}
inline ::transit_realtime::TranslatedString* Alert::_internal_mutable_image_alternative_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.image_alternative_text_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::transit_realtime::TranslatedString>(GetArena());
    _impl_.image_alternative_text_ = reinterpret_cast<::transit_realtime::TranslatedString*>(p);
  }
  return _impl_.image_alternative_text_;
}
inline ::transit_realtime::TranslatedString* Alert::mutable_image_alternative_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000040u;
  ::transit_realtime::TranslatedString* _msg = _internal_mutable_image_alternative_text();
  // @@protoc_insertion_point(field_mutable:transit_realtime.Alert.image_alternative_text)
  return _msg;
}
inline void Alert::set_allocated_image_alternative_text(::transit_realtime::TranslatedString* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.image_alternative_text_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.image_alternative_text_ = reinterpret_cast<::transit_realtime::TranslatedString*>(value);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.Alert.image_alternative_text)
}

// optional .transit_realtime.TranslatedString cause_detail = 17;
inline bool Alert::has_cause_detail() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cause_detail_ != nullptr);
  return value;
}
inline void Alert::clear_cause_detail() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.cause_detail_ != nullptr) _impl_.cause_detail_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::transit_realtime::TranslatedString& Alert::_internal_cause_detail() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::transit_realtime::TranslatedString* p = _impl_.cause_detail_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TranslatedString&>(::transit_realtime::_TranslatedString_default_instance_);
}
inline const ::transit_realtime::TranslatedString& Alert::cause_detail() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.Alert.cause_detail)
  return _internal_cause_detail();
}
inline void Alert::unsafe_arena_set_allocated_cause_detail(::transit_realtime::TranslatedString* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.cause_detail_);
  }
  _impl_.cause_detail_ = reinterpret_cast<::transit_realtime::TranslatedString*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.Alert.cause_detail)
}
inline ::transit_realtime::TranslatedString* Alert::release_cause_detail() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::transit_realtime::TranslatedString* released = _impl_.cause_detail_;
  _impl_.cause_detail_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::transit_realtime::TranslatedString* Alert::unsafe_arena_release_cause_detail() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.Alert.cause_detail)

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::transit_realtime::TranslatedString* temp = _impl_.cause_detail_;
  _impl_.cause_detail_ = nullptr;
  return temp;
}
inline ::transit_realtime::TranslatedString* Alert::_internal_mutable_cause_detail() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.cause_detail_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::transit_realtime::TranslatedString>(GetArena());
    _impl_.cause_detail_ = reinterpret_cast<::transit_realtime::TranslatedString*>(p);
  }
  return _impl_.cause_detail_;
}
inline ::transit_realtime::TranslatedString* Alert::mutable_cause_detail() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000080u;
  ::transit_realtime::TranslatedString* _msg = _internal_mutable_cause_detail();
  // @@protoc_insertion_point(field_mutable:transit_realtime.Alert.cause_detail)
  return _msg;
}
inline void Alert::set_allocated_cause_detail(::transit_realtime::TranslatedString* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.cause_detail_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }

  _impl_.cause_detail_ = reinterpret_cast<::transit_realtime::TranslatedString*>(value);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.Alert.cause_detail)
}

// optional .transit_realtime.TranslatedString effect_detail = 18;
inline bool Alert::has_effect_detail() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.effect_detail_ != nullptr);
  return value;
}
inline void Alert::clear_effect_detail() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.effect_detail_ != nullptr) _impl_.effect_detail_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::transit_realtime::TranslatedString& Alert::_internal_effect_detail() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::transit_realtime::TranslatedString* p = _impl_.effect_detail_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TranslatedString&>(::transit_realtime::_TranslatedString_default_instance_);
}
inline const ::transit_realtime::TranslatedString& Alert::effect_detail() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.Alert.effect_detail)
  return _internal_effect_detail();
}
inline void Alert::unsafe_arena_set_allocated_effect_detail(::transit_realtime::TranslatedString* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.effect_detail_);
  }
  _impl_.effect_detail_ = reinterpret_cast<::transit_realtime::TranslatedString*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.Alert.effect_detail)
}
inline ::transit_realtime::TranslatedString* Alert::release_effect_detail() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::transit_realtime::TranslatedString* released = _impl_.effect_detail_;
  _impl_.effect_detail_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::transit_realtime::TranslatedString* Alert::unsafe_arena_release_effect_detail() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.Alert.effect_detail)

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::transit_realtime::TranslatedString* temp = _impl_.effect_detail_;
  _impl_.effect_detail_ = nullptr;
  return temp;
}
inline ::transit_realtime::TranslatedString* Alert::_internal_mutable_effect_detail() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.effect_detail_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::transit_realtime::TranslatedString>(GetArena());
    _impl_.effect_detail_ = reinterpret_cast<::transit_realtime::TranslatedString*>(p);
  }
  return _impl_.effect_detail_;
}
inline ::transit_realtime::TranslatedString* Alert::mutable_effect_detail() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000100u;
  ::transit_realtime::TranslatedString* _msg = _internal_mutable_effect_detail();
  // @@protoc_insertion_point(field_mutable:transit_realtime.Alert.effect_detail)
  return _msg;
}
inline void Alert::set_allocated_effect_detail(::transit_realtime::TranslatedString* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.effect_detail_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }

  _impl_.effect_detail_ = reinterpret_cast<::transit_realtime::TranslatedString*>(value);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.Alert.effect_detail)
}

// -------------------------------------------------------------------

// TimeRange

// optional uint64 start = 1;
inline bool TimeRange::has_start() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TimeRange::clear_start() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.start_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t TimeRange::start() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TimeRange.start)
  return _internal_start();
}
inline void TimeRange::set_start(::uint64_t value) {
  _internal_set_start(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:transit_realtime.TimeRange.start)
}
inline ::uint64_t TimeRange::_internal_start() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.start_;
}
inline void TimeRange::_internal_set_start(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.start_ = value;
}

// optional uint64 end = 2;
inline bool TimeRange::has_end() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TimeRange::clear_end() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.end_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t TimeRange::end() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TimeRange.end)
  return _internal_end();
}
inline void TimeRange::set_end(::uint64_t value) {
  _internal_set_end(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:transit_realtime.TimeRange.end)
}
inline ::uint64_t TimeRange::_internal_end() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.end_;
}
inline void TimeRange::_internal_set_end(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.end_ = value;
}

// -------------------------------------------------------------------

// Position

// required float latitude = 1;
inline bool Position::has_latitude() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Position::clear_latitude() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.latitude_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float Position::latitude() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Position.latitude)
  return _internal_latitude();
}
inline void Position::set_latitude(float value) {
  _internal_set_latitude(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:transit_realtime.Position.latitude)
}
inline float Position::_internal_latitude() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.latitude_;
}
inline void Position::_internal_set_latitude(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.latitude_ = value;
}

// required float longitude = 2;
inline bool Position::has_longitude() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Position::clear_longitude() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.longitude_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Position::longitude() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Position.longitude)
  return _internal_longitude();
}
inline void Position::set_longitude(float value) {
  _internal_set_longitude(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:transit_realtime.Position.longitude)
}
inline float Position::_internal_longitude() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.longitude_;
}
inline void Position::_internal_set_longitude(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.longitude_ = value;
}

// optional float bearing = 3;
inline bool Position::has_bearing() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void Position::clear_bearing() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bearing_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float Position::bearing() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Position.bearing)
  return _internal_bearing();
}
inline void Position::set_bearing(float value) {
  _internal_set_bearing(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:transit_realtime.Position.bearing)
}
inline float Position::_internal_bearing() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.bearing_;
}
inline void Position::_internal_set_bearing(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bearing_ = value;
}

// optional double odometer = 4;
inline bool Position::has_odometer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Position::clear_odometer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.odometer_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double Position::odometer() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Position.odometer)
  return _internal_odometer();
}
inline void Position::set_odometer(double value) {
  _internal_set_odometer(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:transit_realtime.Position.odometer)
}
inline double Position::_internal_odometer() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.odometer_;
}
inline void Position::_internal_set_odometer(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.odometer_ = value;
}

// optional float speed = 5;
inline bool Position::has_speed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void Position::clear_speed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.speed_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float Position::speed() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Position.speed)
  return _internal_speed();
}
inline void Position::set_speed(float value) {
  _internal_set_speed(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:transit_realtime.Position.speed)
}
inline float Position::_internal_speed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.speed_;
}
inline void Position::_internal_set_speed(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.speed_ = value;
}

// -------------------------------------------------------------------

// TripDescriptor_ModifiedTripSelector

// optional string modifications_id = 1;
inline bool TripDescriptor_ModifiedTripSelector::has_modifications_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TripDescriptor_ModifiedTripSelector::clear_modifications_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.modifications_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TripDescriptor_ModifiedTripSelector::modifications_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.TripDescriptor.ModifiedTripSelector.modifications_id)
  return _internal_modifications_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TripDescriptor_ModifiedTripSelector::set_modifications_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.modifications_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:transit_realtime.TripDescriptor.ModifiedTripSelector.modifications_id)
}
inline std::string* TripDescriptor_ModifiedTripSelector::mutable_modifications_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_modifications_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripDescriptor.ModifiedTripSelector.modifications_id)
  return _s;
}
inline const std::string& TripDescriptor_ModifiedTripSelector::_internal_modifications_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.modifications_id_.Get();
}
inline void TripDescriptor_ModifiedTripSelector::_internal_set_modifications_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.modifications_id_.Set(value, GetArena());
}
inline std::string* TripDescriptor_ModifiedTripSelector::_internal_mutable_modifications_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.modifications_id_.Mutable( GetArena());
}
inline std::string* TripDescriptor_ModifiedTripSelector::release_modifications_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.TripDescriptor.ModifiedTripSelector.modifications_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.modifications_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.modifications_id_.Set("", GetArena());
  }
  return released;
}
inline void TripDescriptor_ModifiedTripSelector::set_allocated_modifications_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.modifications_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.modifications_id_.IsDefault()) {
    _impl_.modifications_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripDescriptor.ModifiedTripSelector.modifications_id)
}

// optional string affected_trip_id = 2;
inline bool TripDescriptor_ModifiedTripSelector::has_affected_trip_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TripDescriptor_ModifiedTripSelector::clear_affected_trip_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.affected_trip_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TripDescriptor_ModifiedTripSelector::affected_trip_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.TripDescriptor.ModifiedTripSelector.affected_trip_id)
  return _internal_affected_trip_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TripDescriptor_ModifiedTripSelector::set_affected_trip_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.affected_trip_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:transit_realtime.TripDescriptor.ModifiedTripSelector.affected_trip_id)
}
inline std::string* TripDescriptor_ModifiedTripSelector::mutable_affected_trip_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_affected_trip_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripDescriptor.ModifiedTripSelector.affected_trip_id)
  return _s;
}
inline const std::string& TripDescriptor_ModifiedTripSelector::_internal_affected_trip_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.affected_trip_id_.Get();
}
inline void TripDescriptor_ModifiedTripSelector::_internal_set_affected_trip_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.affected_trip_id_.Set(value, GetArena());
}
inline std::string* TripDescriptor_ModifiedTripSelector::_internal_mutable_affected_trip_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.affected_trip_id_.Mutable( GetArena());
}
inline std::string* TripDescriptor_ModifiedTripSelector::release_affected_trip_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.TripDescriptor.ModifiedTripSelector.affected_trip_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.affected_trip_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.affected_trip_id_.Set("", GetArena());
  }
  return released;
}
inline void TripDescriptor_ModifiedTripSelector::set_allocated_affected_trip_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.affected_trip_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.affected_trip_id_.IsDefault()) {
    _impl_.affected_trip_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripDescriptor.ModifiedTripSelector.affected_trip_id)
}

// optional string start_time = 3;
inline bool TripDescriptor_ModifiedTripSelector::has_start_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void TripDescriptor_ModifiedTripSelector::clear_start_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.start_time_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TripDescriptor_ModifiedTripSelector::start_time() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.TripDescriptor.ModifiedTripSelector.start_time)
  return _internal_start_time();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TripDescriptor_ModifiedTripSelector::set_start_time(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.start_time_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:transit_realtime.TripDescriptor.ModifiedTripSelector.start_time)
}
inline std::string* TripDescriptor_ModifiedTripSelector::mutable_start_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_start_time();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripDescriptor.ModifiedTripSelector.start_time)
  return _s;
}
inline const std::string& TripDescriptor_ModifiedTripSelector::_internal_start_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.start_time_.Get();
}
inline void TripDescriptor_ModifiedTripSelector::_internal_set_start_time(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.start_time_.Set(value, GetArena());
}
inline std::string* TripDescriptor_ModifiedTripSelector::_internal_mutable_start_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.start_time_.Mutable( GetArena());
}
inline std::string* TripDescriptor_ModifiedTripSelector::release_start_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.TripDescriptor.ModifiedTripSelector.start_time)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.start_time_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.start_time_.Set("", GetArena());
  }
  return released;
}
inline void TripDescriptor_ModifiedTripSelector::set_allocated_start_time(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.start_time_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.start_time_.IsDefault()) {
    _impl_.start_time_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripDescriptor.ModifiedTripSelector.start_time)
}

// optional string start_date = 4;
inline bool TripDescriptor_ModifiedTripSelector::has_start_date() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void TripDescriptor_ModifiedTripSelector::clear_start_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.start_date_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& TripDescriptor_ModifiedTripSelector::start_date() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.TripDescriptor.ModifiedTripSelector.start_date)
  return _internal_start_date();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TripDescriptor_ModifiedTripSelector::set_start_date(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.start_date_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:transit_realtime.TripDescriptor.ModifiedTripSelector.start_date)
}
inline std::string* TripDescriptor_ModifiedTripSelector::mutable_start_date() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_start_date();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripDescriptor.ModifiedTripSelector.start_date)
  return _s;
}
inline const std::string& TripDescriptor_ModifiedTripSelector::_internal_start_date() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.start_date_.Get();
}
inline void TripDescriptor_ModifiedTripSelector::_internal_set_start_date(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.start_date_.Set(value, GetArena());
}
inline std::string* TripDescriptor_ModifiedTripSelector::_internal_mutable_start_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.start_date_.Mutable( GetArena());
}
inline std::string* TripDescriptor_ModifiedTripSelector::release_start_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.TripDescriptor.ModifiedTripSelector.start_date)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.start_date_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.start_date_.Set("", GetArena());
  }
  return released;
}
inline void TripDescriptor_ModifiedTripSelector::set_allocated_start_date(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.start_date_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.start_date_.IsDefault()) {
    _impl_.start_date_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripDescriptor.ModifiedTripSelector.start_date)
}

// -------------------------------------------------------------------

// TripDescriptor

// optional string trip_id = 1;
inline bool TripDescriptor::has_trip_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TripDescriptor::clear_trip_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.trip_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TripDescriptor::trip_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.TripDescriptor.trip_id)
  return _internal_trip_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TripDescriptor::set_trip_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.trip_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:transit_realtime.TripDescriptor.trip_id)
}
inline std::string* TripDescriptor::mutable_trip_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_trip_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripDescriptor.trip_id)
  return _s;
}
inline const std::string& TripDescriptor::_internal_trip_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.trip_id_.Get();
}
inline void TripDescriptor::_internal_set_trip_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.trip_id_.Set(value, GetArena());
}
inline std::string* TripDescriptor::_internal_mutable_trip_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.trip_id_.Mutable( GetArena());
}
inline std::string* TripDescriptor::release_trip_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.TripDescriptor.trip_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.trip_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.trip_id_.Set("", GetArena());
  }
  return released;
}
inline void TripDescriptor::set_allocated_trip_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.trip_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.trip_id_.IsDefault()) {
    _impl_.trip_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripDescriptor.trip_id)
}

// optional string route_id = 5;
inline bool TripDescriptor::has_route_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void TripDescriptor::clear_route_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.route_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& TripDescriptor::route_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.TripDescriptor.route_id)
  return _internal_route_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TripDescriptor::set_route_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.route_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:transit_realtime.TripDescriptor.route_id)
}
inline std::string* TripDescriptor::mutable_route_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_route_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripDescriptor.route_id)
  return _s;
}
inline const std::string& TripDescriptor::_internal_route_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.route_id_.Get();
}
inline void TripDescriptor::_internal_set_route_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.route_id_.Set(value, GetArena());
}
inline std::string* TripDescriptor::_internal_mutable_route_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.route_id_.Mutable( GetArena());
}
inline std::string* TripDescriptor::release_route_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.TripDescriptor.route_id)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.route_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.route_id_.Set("", GetArena());
  }
  return released;
}
inline void TripDescriptor::set_allocated_route_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.route_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.route_id_.IsDefault()) {
    _impl_.route_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripDescriptor.route_id)
}

// optional uint32 direction_id = 6;
inline bool TripDescriptor::has_direction_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void TripDescriptor::clear_direction_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.direction_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint32_t TripDescriptor::direction_id() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripDescriptor.direction_id)
  return _internal_direction_id();
}
inline void TripDescriptor::set_direction_id(::uint32_t value) {
  _internal_set_direction_id(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:transit_realtime.TripDescriptor.direction_id)
}
inline ::uint32_t TripDescriptor::_internal_direction_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.direction_id_;
}
inline void TripDescriptor::_internal_set_direction_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.direction_id_ = value;
}

// optional string start_time = 2;
inline bool TripDescriptor::has_start_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TripDescriptor::clear_start_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.start_time_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TripDescriptor::start_time() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.TripDescriptor.start_time)
  return _internal_start_time();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TripDescriptor::set_start_time(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.start_time_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:transit_realtime.TripDescriptor.start_time)
}
inline std::string* TripDescriptor::mutable_start_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_start_time();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripDescriptor.start_time)
  return _s;
}
inline const std::string& TripDescriptor::_internal_start_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.start_time_.Get();
}
inline void TripDescriptor::_internal_set_start_time(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.start_time_.Set(value, GetArena());
}
inline std::string* TripDescriptor::_internal_mutable_start_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.start_time_.Mutable( GetArena());
}
inline std::string* TripDescriptor::release_start_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.TripDescriptor.start_time)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.start_time_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.start_time_.Set("", GetArena());
  }
  return released;
}
inline void TripDescriptor::set_allocated_start_time(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.start_time_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.start_time_.IsDefault()) {
    _impl_.start_time_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripDescriptor.start_time)
}

// optional string start_date = 3;
inline bool TripDescriptor::has_start_date() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void TripDescriptor::clear_start_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.start_date_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TripDescriptor::start_date() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.TripDescriptor.start_date)
  return _internal_start_date();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TripDescriptor::set_start_date(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.start_date_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:transit_realtime.TripDescriptor.start_date)
}
inline std::string* TripDescriptor::mutable_start_date() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_start_date();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripDescriptor.start_date)
  return _s;
}
inline const std::string& TripDescriptor::_internal_start_date() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.start_date_.Get();
}
inline void TripDescriptor::_internal_set_start_date(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.start_date_.Set(value, GetArena());
}
inline std::string* TripDescriptor::_internal_mutable_start_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.start_date_.Mutable( GetArena());
}
inline std::string* TripDescriptor::release_start_date() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.TripDescriptor.start_date)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.start_date_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.start_date_.Set("", GetArena());
  }
  return released;
}
inline void TripDescriptor::set_allocated_start_date(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.start_date_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.start_date_.IsDefault()) {
    _impl_.start_date_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripDescriptor.start_date)
}

// optional .transit_realtime.TripDescriptor.ScheduleRelationship schedule_relationship = 4;
inline bool TripDescriptor::has_schedule_relationship() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void TripDescriptor::clear_schedule_relationship() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.schedule_relationship_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::transit_realtime::TripDescriptor_ScheduleRelationship TripDescriptor::schedule_relationship() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripDescriptor.schedule_relationship)
  return _internal_schedule_relationship();
}
inline void TripDescriptor::set_schedule_relationship(::transit_realtime::TripDescriptor_ScheduleRelationship value) {
  _internal_set_schedule_relationship(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:transit_realtime.TripDescriptor.schedule_relationship)
}
inline ::transit_realtime::TripDescriptor_ScheduleRelationship TripDescriptor::_internal_schedule_relationship() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::transit_realtime::TripDescriptor_ScheduleRelationship>(_impl_.schedule_relationship_);
}
inline void TripDescriptor::_internal_set_schedule_relationship(::transit_realtime::TripDescriptor_ScheduleRelationship value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  assert(::transit_realtime::TripDescriptor_ScheduleRelationship_IsValid(value));
  _impl_.schedule_relationship_ = value;
}

// optional .transit_realtime.TripDescriptor.ModifiedTripSelector modified_trip = 7;
inline bool TripDescriptor::has_modified_trip() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.modified_trip_ != nullptr);
  return value;
}
inline void TripDescriptor::clear_modified_trip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.modified_trip_ != nullptr) _impl_.modified_trip_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::transit_realtime::TripDescriptor_ModifiedTripSelector& TripDescriptor::_internal_modified_trip() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::transit_realtime::TripDescriptor_ModifiedTripSelector* p = _impl_.modified_trip_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TripDescriptor_ModifiedTripSelector&>(::transit_realtime::_TripDescriptor_ModifiedTripSelector_default_instance_);
}
inline const ::transit_realtime::TripDescriptor_ModifiedTripSelector& TripDescriptor::modified_trip() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.TripDescriptor.modified_trip)
  return _internal_modified_trip();
}
inline void TripDescriptor::unsafe_arena_set_allocated_modified_trip(::transit_realtime::TripDescriptor_ModifiedTripSelector* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.modified_trip_);
  }
  _impl_.modified_trip_ = reinterpret_cast<::transit_realtime::TripDescriptor_ModifiedTripSelector*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.TripDescriptor.modified_trip)
}
inline ::transit_realtime::TripDescriptor_ModifiedTripSelector* TripDescriptor::release_modified_trip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::transit_realtime::TripDescriptor_ModifiedTripSelector* released = _impl_.modified_trip_;
  _impl_.modified_trip_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::transit_realtime::TripDescriptor_ModifiedTripSelector* TripDescriptor::unsafe_arena_release_modified_trip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.TripDescriptor.modified_trip)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::transit_realtime::TripDescriptor_ModifiedTripSelector* temp = _impl_.modified_trip_;
  _impl_.modified_trip_ = nullptr;
  return temp;
}
inline ::transit_realtime::TripDescriptor_ModifiedTripSelector* TripDescriptor::_internal_mutable_modified_trip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.modified_trip_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::transit_realtime::TripDescriptor_ModifiedTripSelector>(GetArena());
    _impl_.modified_trip_ = reinterpret_cast<::transit_realtime::TripDescriptor_ModifiedTripSelector*>(p);
  }
  return _impl_.modified_trip_;
}
inline ::transit_realtime::TripDescriptor_ModifiedTripSelector* TripDescriptor::mutable_modified_trip() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::transit_realtime::TripDescriptor_ModifiedTripSelector* _msg = _internal_mutable_modified_trip();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripDescriptor.modified_trip)
  return _msg;
}
inline void TripDescriptor::set_allocated_modified_trip(::transit_realtime::TripDescriptor_ModifiedTripSelector* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.modified_trip_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.modified_trip_ = reinterpret_cast<::transit_realtime::TripDescriptor_ModifiedTripSelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripDescriptor.modified_trip)
}

// -------------------------------------------------------------------

// VehicleDescriptor

// optional string id = 1;
inline bool VehicleDescriptor::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void VehicleDescriptor::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VehicleDescriptor::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.VehicleDescriptor.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VehicleDescriptor::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:transit_realtime.VehicleDescriptor.id)
}
inline std::string* VehicleDescriptor::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.VehicleDescriptor.id)
  return _s;
}
inline const std::string& VehicleDescriptor::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void VehicleDescriptor::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_.Set(value, GetArena());
}
inline std::string* VehicleDescriptor::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* VehicleDescriptor::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.VehicleDescriptor.id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.id_.Set("", GetArena());
  }
  return released;
}
inline void VehicleDescriptor::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.VehicleDescriptor.id)
}

// optional string label = 2;
inline bool VehicleDescriptor::has_label() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void VehicleDescriptor::clear_label() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.label_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& VehicleDescriptor::label() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.VehicleDescriptor.label)
  return _internal_label();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VehicleDescriptor::set_label(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.label_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:transit_realtime.VehicleDescriptor.label)
}
inline std::string* VehicleDescriptor::mutable_label() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:transit_realtime.VehicleDescriptor.label)
  return _s;
}
inline const std::string& VehicleDescriptor::_internal_label() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.label_.Get();
}
inline void VehicleDescriptor::_internal_set_label(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.label_.Set(value, GetArena());
}
inline std::string* VehicleDescriptor::_internal_mutable_label() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.label_.Mutable( GetArena());
}
inline std::string* VehicleDescriptor::release_label() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.VehicleDescriptor.label)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.label_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.label_.Set("", GetArena());
  }
  return released;
}
inline void VehicleDescriptor::set_allocated_label(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.label_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.label_.IsDefault()) {
    _impl_.label_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.VehicleDescriptor.label)
}

// optional string license_plate = 3;
inline bool VehicleDescriptor::has_license_plate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void VehicleDescriptor::clear_license_plate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.license_plate_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& VehicleDescriptor::license_plate() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.VehicleDescriptor.license_plate)
  return _internal_license_plate();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VehicleDescriptor::set_license_plate(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.license_plate_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:transit_realtime.VehicleDescriptor.license_plate)
}
inline std::string* VehicleDescriptor::mutable_license_plate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_license_plate();
  // @@protoc_insertion_point(field_mutable:transit_realtime.VehicleDescriptor.license_plate)
  return _s;
}
inline const std::string& VehicleDescriptor::_internal_license_plate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.license_plate_.Get();
}
inline void VehicleDescriptor::_internal_set_license_plate(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.license_plate_.Set(value, GetArena());
}
inline std::string* VehicleDescriptor::_internal_mutable_license_plate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.license_plate_.Mutable( GetArena());
}
inline std::string* VehicleDescriptor::release_license_plate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.VehicleDescriptor.license_plate)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.license_plate_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.license_plate_.Set("", GetArena());
  }
  return released;
}
inline void VehicleDescriptor::set_allocated_license_plate(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.license_plate_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.license_plate_.IsDefault()) {
    _impl_.license_plate_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.VehicleDescriptor.license_plate)
}

// optional .transit_realtime.VehicleDescriptor.WheelchairAccessible wheelchair_accessible = 4 [default = NO_VALUE];
inline bool VehicleDescriptor::has_wheelchair_accessible() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void VehicleDescriptor::clear_wheelchair_accessible() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wheelchair_accessible_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::transit_realtime::VehicleDescriptor_WheelchairAccessible VehicleDescriptor::wheelchair_accessible() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehicleDescriptor.wheelchair_accessible)
  return _internal_wheelchair_accessible();
}
inline void VehicleDescriptor::set_wheelchair_accessible(::transit_realtime::VehicleDescriptor_WheelchairAccessible value) {
  _internal_set_wheelchair_accessible(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:transit_realtime.VehicleDescriptor.wheelchair_accessible)
}
inline ::transit_realtime::VehicleDescriptor_WheelchairAccessible VehicleDescriptor::_internal_wheelchair_accessible() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::transit_realtime::VehicleDescriptor_WheelchairAccessible>(_impl_.wheelchair_accessible_);
}
inline void VehicleDescriptor::_internal_set_wheelchair_accessible(::transit_realtime::VehicleDescriptor_WheelchairAccessible value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  assert(::transit_realtime::VehicleDescriptor_WheelchairAccessible_IsValid(value));
  _impl_.wheelchair_accessible_ = value;
}

// -------------------------------------------------------------------

// EntitySelector

// optional string agency_id = 1;
inline bool EntitySelector::has_agency_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void EntitySelector::clear_agency_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.agency_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& EntitySelector::agency_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.EntitySelector.agency_id)
  return _internal_agency_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EntitySelector::set_agency_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.agency_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:transit_realtime.EntitySelector.agency_id)
}
inline std::string* EntitySelector::mutable_agency_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_agency_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.EntitySelector.agency_id)
  return _s;
}
inline const std::string& EntitySelector::_internal_agency_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.agency_id_.Get();
}
inline void EntitySelector::_internal_set_agency_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.agency_id_.Set(value, GetArena());
}
inline std::string* EntitySelector::_internal_mutable_agency_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.agency_id_.Mutable( GetArena());
}
inline std::string* EntitySelector::release_agency_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.EntitySelector.agency_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.agency_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.agency_id_.Set("", GetArena());
  }
  return released;
}
inline void EntitySelector::set_allocated_agency_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.agency_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.agency_id_.IsDefault()) {
    _impl_.agency_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.EntitySelector.agency_id)
}

// optional string route_id = 2;
inline bool EntitySelector::has_route_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void EntitySelector::clear_route_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.route_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& EntitySelector::route_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.EntitySelector.route_id)
  return _internal_route_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EntitySelector::set_route_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.route_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:transit_realtime.EntitySelector.route_id)
}
inline std::string* EntitySelector::mutable_route_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_route_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.EntitySelector.route_id)
  return _s;
}
inline const std::string& EntitySelector::_internal_route_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.route_id_.Get();
}
inline void EntitySelector::_internal_set_route_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.route_id_.Set(value, GetArena());
}
inline std::string* EntitySelector::_internal_mutable_route_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.route_id_.Mutable( GetArena());
}
inline std::string* EntitySelector::release_route_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.EntitySelector.route_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.route_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.route_id_.Set("", GetArena());
  }
  return released;
}
inline void EntitySelector::set_allocated_route_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.route_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.route_id_.IsDefault()) {
    _impl_.route_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.EntitySelector.route_id)
}

// optional int32 route_type = 3;
inline bool EntitySelector::has_route_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void EntitySelector::clear_route_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.route_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t EntitySelector::route_type() const {
  // @@protoc_insertion_point(field_get:transit_realtime.EntitySelector.route_type)
  return _internal_route_type();
}
inline void EntitySelector::set_route_type(::int32_t value) {
  _internal_set_route_type(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:transit_realtime.EntitySelector.route_type)
}
inline ::int32_t EntitySelector::_internal_route_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.route_type_;
}
inline void EntitySelector::_internal_set_route_type(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.route_type_ = value;
}

// optional .transit_realtime.TripDescriptor trip = 4;
inline bool EntitySelector::has_trip() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.trip_ != nullptr);
  return value;
}
inline void EntitySelector::clear_trip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.trip_ != nullptr) _impl_.trip_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::transit_realtime::TripDescriptor& EntitySelector::_internal_trip() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::transit_realtime::TripDescriptor* p = _impl_.trip_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TripDescriptor&>(::transit_realtime::_TripDescriptor_default_instance_);
}
inline const ::transit_realtime::TripDescriptor& EntitySelector::trip() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.EntitySelector.trip)
  return _internal_trip();
}
inline void EntitySelector::unsafe_arena_set_allocated_trip(::transit_realtime::TripDescriptor* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.trip_);
  }
  _impl_.trip_ = reinterpret_cast<::transit_realtime::TripDescriptor*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.EntitySelector.trip)
}
inline ::transit_realtime::TripDescriptor* EntitySelector::release_trip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::transit_realtime::TripDescriptor* released = _impl_.trip_;
  _impl_.trip_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::transit_realtime::TripDescriptor* EntitySelector::unsafe_arena_release_trip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.EntitySelector.trip)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::transit_realtime::TripDescriptor* temp = _impl_.trip_;
  _impl_.trip_ = nullptr;
  return temp;
}
inline ::transit_realtime::TripDescriptor* EntitySelector::_internal_mutable_trip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.trip_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::transit_realtime::TripDescriptor>(GetArena());
    _impl_.trip_ = reinterpret_cast<::transit_realtime::TripDescriptor*>(p);
  }
  return _impl_.trip_;
}
inline ::transit_realtime::TripDescriptor* EntitySelector::mutable_trip() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::transit_realtime::TripDescriptor* _msg = _internal_mutable_trip();
  // @@protoc_insertion_point(field_mutable:transit_realtime.EntitySelector.trip)
  return _msg;
}
inline void EntitySelector::set_allocated_trip(::transit_realtime::TripDescriptor* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.trip_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.trip_ = reinterpret_cast<::transit_realtime::TripDescriptor*>(value);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.EntitySelector.trip)
}

// optional string stop_id = 5;
inline bool EntitySelector::has_stop_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void EntitySelector::clear_stop_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stop_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& EntitySelector::stop_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.EntitySelector.stop_id)
  return _internal_stop_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EntitySelector::set_stop_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.stop_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:transit_realtime.EntitySelector.stop_id)
}
inline std::string* EntitySelector::mutable_stop_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_stop_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.EntitySelector.stop_id)
  return _s;
}
inline const std::string& EntitySelector::_internal_stop_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stop_id_.Get();
}
inline void EntitySelector::_internal_set_stop_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.stop_id_.Set(value, GetArena());
}
inline std::string* EntitySelector::_internal_mutable_stop_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.stop_id_.Mutable( GetArena());
}
inline std::string* EntitySelector::release_stop_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.EntitySelector.stop_id)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.stop_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.stop_id_.Set("", GetArena());
  }
  return released;
}
inline void EntitySelector::set_allocated_stop_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.stop_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.stop_id_.IsDefault()) {
    _impl_.stop_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.EntitySelector.stop_id)
}

// optional uint32 direction_id = 6;
inline bool EntitySelector::has_direction_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void EntitySelector::clear_direction_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.direction_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint32_t EntitySelector::direction_id() const {
  // @@protoc_insertion_point(field_get:transit_realtime.EntitySelector.direction_id)
  return _internal_direction_id();
}
inline void EntitySelector::set_direction_id(::uint32_t value) {
  _internal_set_direction_id(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:transit_realtime.EntitySelector.direction_id)
}
inline ::uint32_t EntitySelector::_internal_direction_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.direction_id_;
}
inline void EntitySelector::_internal_set_direction_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.direction_id_ = value;
}

// -------------------------------------------------------------------

// TranslatedString_Translation

// required string text = 1;
inline bool TranslatedString_Translation::has_text() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TranslatedString_Translation::clear_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.text_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TranslatedString_Translation::text() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.TranslatedString.Translation.text)
  return _internal_text();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TranslatedString_Translation::set_text(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.text_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:transit_realtime.TranslatedString.Translation.text)
}
inline std::string* TranslatedString_Translation::mutable_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TranslatedString.Translation.text)
  return _s;
}
inline const std::string& TranslatedString_Translation::_internal_text() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.text_.Get();
}
inline void TranslatedString_Translation::_internal_set_text(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.text_.Set(value, GetArena());
}
inline std::string* TranslatedString_Translation::_internal_mutable_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.text_.Mutable( GetArena());
}
inline std::string* TranslatedString_Translation::release_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.TranslatedString.Translation.text)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.text_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.text_.Set("", GetArena());
  }
  return released;
}
inline void TranslatedString_Translation::set_allocated_text(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.text_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.text_.IsDefault()) {
    _impl_.text_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TranslatedString.Translation.text)
}

// optional string language = 2;
inline bool TranslatedString_Translation::has_language() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TranslatedString_Translation::clear_language() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.language_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TranslatedString_Translation::language() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.TranslatedString.Translation.language)
  return _internal_language();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TranslatedString_Translation::set_language(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.language_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:transit_realtime.TranslatedString.Translation.language)
}
inline std::string* TranslatedString_Translation::mutable_language() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TranslatedString.Translation.language)
  return _s;
}
inline const std::string& TranslatedString_Translation::_internal_language() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.language_.Get();
}
inline void TranslatedString_Translation::_internal_set_language(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.language_.Set(value, GetArena());
}
inline std::string* TranslatedString_Translation::_internal_mutable_language() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.language_.Mutable( GetArena());
}
inline std::string* TranslatedString_Translation::release_language() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.TranslatedString.Translation.language)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.language_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.language_.Set("", GetArena());
  }
  return released;
}
inline void TranslatedString_Translation::set_allocated_language(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.language_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.language_.IsDefault()) {
    _impl_.language_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TranslatedString.Translation.language)
}

// -------------------------------------------------------------------

// TranslatedString

// repeated .transit_realtime.TranslatedString.Translation translation = 1;
inline int TranslatedString::_internal_translation_size() const {
  return _internal_translation().size();
}
inline int TranslatedString::translation_size() const {
  return _internal_translation_size();
}
inline void TranslatedString::clear_translation() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.translation_.Clear();
}
inline ::transit_realtime::TranslatedString_Translation* TranslatedString::mutable_translation(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:transit_realtime.TranslatedString.translation)
  return _internal_mutable_translation()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::transit_realtime::TranslatedString_Translation>* TranslatedString::mutable_translation()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:transit_realtime.TranslatedString.translation)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_translation();
}
inline const ::transit_realtime::TranslatedString_Translation& TranslatedString::translation(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.TranslatedString.translation)
  return _internal_translation().Get(index);
}
inline ::transit_realtime::TranslatedString_Translation* TranslatedString::add_translation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::transit_realtime::TranslatedString_Translation* _add = _internal_mutable_translation()->Add();
  // @@protoc_insertion_point(field_add:transit_realtime.TranslatedString.translation)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::transit_realtime::TranslatedString_Translation>& TranslatedString::translation() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:transit_realtime.TranslatedString.translation)
  return _internal_translation();
}
inline const ::google::protobuf::RepeatedPtrField<::transit_realtime::TranslatedString_Translation>&
TranslatedString::_internal_translation() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.translation_;
}
inline ::google::protobuf::RepeatedPtrField<::transit_realtime::TranslatedString_Translation>*
TranslatedString::_internal_mutable_translation() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.translation_;
}

// -------------------------------------------------------------------

// TranslatedImage_LocalizedImage

// required string url = 1;
inline bool TranslatedImage_LocalizedImage::has_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TranslatedImage_LocalizedImage::clear_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TranslatedImage_LocalizedImage::url() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.TranslatedImage.LocalizedImage.url)
  return _internal_url();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TranslatedImage_LocalizedImage::set_url(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.url_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:transit_realtime.TranslatedImage.LocalizedImage.url)
}
inline std::string* TranslatedImage_LocalizedImage::mutable_url() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TranslatedImage.LocalizedImage.url)
  return _s;
}
inline const std::string& TranslatedImage_LocalizedImage::_internal_url() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.url_.Get();
}
inline void TranslatedImage_LocalizedImage::_internal_set_url(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.url_.Set(value, GetArena());
}
inline std::string* TranslatedImage_LocalizedImage::_internal_mutable_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.url_.Mutable( GetArena());
}
inline std::string* TranslatedImage_LocalizedImage::release_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.TranslatedImage.LocalizedImage.url)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.url_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.url_.Set("", GetArena());
  }
  return released;
}
inline void TranslatedImage_LocalizedImage::set_allocated_url(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.url_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TranslatedImage.LocalizedImage.url)
}

// required string media_type = 2;
inline bool TranslatedImage_LocalizedImage::has_media_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TranslatedImage_LocalizedImage::clear_media_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.media_type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TranslatedImage_LocalizedImage::media_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.TranslatedImage.LocalizedImage.media_type)
  return _internal_media_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TranslatedImage_LocalizedImage::set_media_type(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.media_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:transit_realtime.TranslatedImage.LocalizedImage.media_type)
}
inline std::string* TranslatedImage_LocalizedImage::mutable_media_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_media_type();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TranslatedImage.LocalizedImage.media_type)
  return _s;
}
inline const std::string& TranslatedImage_LocalizedImage::_internal_media_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.media_type_.Get();
}
inline void TranslatedImage_LocalizedImage::_internal_set_media_type(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.media_type_.Set(value, GetArena());
}
inline std::string* TranslatedImage_LocalizedImage::_internal_mutable_media_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.media_type_.Mutable( GetArena());
}
inline std::string* TranslatedImage_LocalizedImage::release_media_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.TranslatedImage.LocalizedImage.media_type)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.media_type_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.media_type_.Set("", GetArena());
  }
  return released;
}
inline void TranslatedImage_LocalizedImage::set_allocated_media_type(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.media_type_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.media_type_.IsDefault()) {
    _impl_.media_type_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TranslatedImage.LocalizedImage.media_type)
}

// optional string language = 3;
inline bool TranslatedImage_LocalizedImage::has_language() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void TranslatedImage_LocalizedImage::clear_language() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.language_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TranslatedImage_LocalizedImage::language() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.TranslatedImage.LocalizedImage.language)
  return _internal_language();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TranslatedImage_LocalizedImage::set_language(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.language_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:transit_realtime.TranslatedImage.LocalizedImage.language)
}
inline std::string* TranslatedImage_LocalizedImage::mutable_language() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TranslatedImage.LocalizedImage.language)
  return _s;
}
inline const std::string& TranslatedImage_LocalizedImage::_internal_language() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.language_.Get();
}
inline void TranslatedImage_LocalizedImage::_internal_set_language(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.language_.Set(value, GetArena());
}
inline std::string* TranslatedImage_LocalizedImage::_internal_mutable_language() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.language_.Mutable( GetArena());
}
inline std::string* TranslatedImage_LocalizedImage::release_language() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.TranslatedImage.LocalizedImage.language)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.language_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.language_.Set("", GetArena());
  }
  return released;
}
inline void TranslatedImage_LocalizedImage::set_allocated_language(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.language_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.language_.IsDefault()) {
    _impl_.language_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TranslatedImage.LocalizedImage.language)
}

// -------------------------------------------------------------------

// TranslatedImage

// repeated .transit_realtime.TranslatedImage.LocalizedImage localized_image = 1;
inline int TranslatedImage::_internal_localized_image_size() const {
  return _internal_localized_image().size();
}
inline int TranslatedImage::localized_image_size() const {
  return _internal_localized_image_size();
}
inline void TranslatedImage::clear_localized_image() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.localized_image_.Clear();
}
inline ::transit_realtime::TranslatedImage_LocalizedImage* TranslatedImage::mutable_localized_image(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:transit_realtime.TranslatedImage.localized_image)
  return _internal_mutable_localized_image()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::transit_realtime::TranslatedImage_LocalizedImage>* TranslatedImage::mutable_localized_image()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:transit_realtime.TranslatedImage.localized_image)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_localized_image();
}
inline const ::transit_realtime::TranslatedImage_LocalizedImage& TranslatedImage::localized_image(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.TranslatedImage.localized_image)
  return _internal_localized_image().Get(index);
}
inline ::transit_realtime::TranslatedImage_LocalizedImage* TranslatedImage::add_localized_image() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::transit_realtime::TranslatedImage_LocalizedImage* _add = _internal_mutable_localized_image()->Add();
  // @@protoc_insertion_point(field_add:transit_realtime.TranslatedImage.localized_image)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::transit_realtime::TranslatedImage_LocalizedImage>& TranslatedImage::localized_image() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:transit_realtime.TranslatedImage.localized_image)
  return _internal_localized_image();
}
inline const ::google::protobuf::RepeatedPtrField<::transit_realtime::TranslatedImage_LocalizedImage>&
TranslatedImage::_internal_localized_image() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.localized_image_;
}
inline ::google::protobuf::RepeatedPtrField<::transit_realtime::TranslatedImage_LocalizedImage>*
TranslatedImage::_internal_mutable_localized_image() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.localized_image_;
}

// -------------------------------------------------------------------

// Shape

// optional string shape_id = 1;
inline bool Shape::has_shape_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Shape::clear_shape_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Shape::shape_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.Shape.shape_id)
  return _internal_shape_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Shape::set_shape_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.shape_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:transit_realtime.Shape.shape_id)
}
inline std::string* Shape::mutable_shape_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_shape_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.Shape.shape_id)
  return _s;
}
inline const std::string& Shape::_internal_shape_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shape_id_.Get();
}
inline void Shape::_internal_set_shape_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.shape_id_.Set(value, GetArena());
}
inline std::string* Shape::_internal_mutable_shape_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.shape_id_.Mutable( GetArena());
}
inline std::string* Shape::release_shape_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.Shape.shape_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.shape_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.shape_id_.Set("", GetArena());
  }
  return released;
}
inline void Shape::set_allocated_shape_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.shape_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.shape_id_.IsDefault()) {
    _impl_.shape_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.Shape.shape_id)
}

// optional string encoded_polyline = 2;
inline bool Shape::has_encoded_polyline() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Shape::clear_encoded_polyline() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.encoded_polyline_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Shape::encoded_polyline() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.Shape.encoded_polyline)
  return _internal_encoded_polyline();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Shape::set_encoded_polyline(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.encoded_polyline_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:transit_realtime.Shape.encoded_polyline)
}
inline std::string* Shape::mutable_encoded_polyline() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_encoded_polyline();
  // @@protoc_insertion_point(field_mutable:transit_realtime.Shape.encoded_polyline)
  return _s;
}
inline const std::string& Shape::_internal_encoded_polyline() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.encoded_polyline_.Get();
}
inline void Shape::_internal_set_encoded_polyline(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.encoded_polyline_.Set(value, GetArena());
}
inline std::string* Shape::_internal_mutable_encoded_polyline() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.encoded_polyline_.Mutable( GetArena());
}
inline std::string* Shape::release_encoded_polyline() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.Shape.encoded_polyline)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.encoded_polyline_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.encoded_polyline_.Set("", GetArena());
  }
  return released;
}
inline void Shape::set_allocated_encoded_polyline(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.encoded_polyline_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.encoded_polyline_.IsDefault()) {
    _impl_.encoded_polyline_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.Shape.encoded_polyline)
}

// -------------------------------------------------------------------

// Stop

// optional string stop_id = 1;
inline bool Stop::has_stop_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Stop::clear_stop_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stop_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Stop::stop_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.Stop.stop_id)
  return _internal_stop_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Stop::set_stop_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.stop_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:transit_realtime.Stop.stop_id)
}
inline std::string* Stop::mutable_stop_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_stop_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.Stop.stop_id)
  return _s;
}
inline const std::string& Stop::_internal_stop_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stop_id_.Get();
}
inline void Stop::_internal_set_stop_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.stop_id_.Set(value, GetArena());
}
inline std::string* Stop::_internal_mutable_stop_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.stop_id_.Mutable( GetArena());
}
inline std::string* Stop::release_stop_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.Stop.stop_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.stop_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.stop_id_.Set("", GetArena());
  }
  return released;
}
inline void Stop::set_allocated_stop_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.stop_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.stop_id_.IsDefault()) {
    _impl_.stop_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.Stop.stop_id)
}

// optional .transit_realtime.TranslatedString stop_code = 2;
inline bool Stop::has_stop_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stop_code_ != nullptr);
  return value;
}
inline void Stop::clear_stop_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.stop_code_ != nullptr) _impl_.stop_code_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::transit_realtime::TranslatedString& Stop::_internal_stop_code() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::transit_realtime::TranslatedString* p = _impl_.stop_code_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TranslatedString&>(::transit_realtime::_TranslatedString_default_instance_);
}
inline const ::transit_realtime::TranslatedString& Stop::stop_code() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.Stop.stop_code)
  return _internal_stop_code();
}
inline void Stop::unsafe_arena_set_allocated_stop_code(::transit_realtime::TranslatedString* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stop_code_);
  }
  _impl_.stop_code_ = reinterpret_cast<::transit_realtime::TranslatedString*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.Stop.stop_code)
}
inline ::transit_realtime::TranslatedString* Stop::release_stop_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::transit_realtime::TranslatedString* released = _impl_.stop_code_;
  _impl_.stop_code_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::transit_realtime::TranslatedString* Stop::unsafe_arena_release_stop_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.Stop.stop_code)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::transit_realtime::TranslatedString* temp = _impl_.stop_code_;
  _impl_.stop_code_ = nullptr;
  return temp;
}
inline ::transit_realtime::TranslatedString* Stop::_internal_mutable_stop_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.stop_code_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::transit_realtime::TranslatedString>(GetArena());
    _impl_.stop_code_ = reinterpret_cast<::transit_realtime::TranslatedString*>(p);
  }
  return _impl_.stop_code_;
}
inline ::transit_realtime::TranslatedString* Stop::mutable_stop_code() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::transit_realtime::TranslatedString* _msg = _internal_mutable_stop_code();
  // @@protoc_insertion_point(field_mutable:transit_realtime.Stop.stop_code)
  return _msg;
}
inline void Stop::set_allocated_stop_code(::transit_realtime::TranslatedString* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.stop_code_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.stop_code_ = reinterpret_cast<::transit_realtime::TranslatedString*>(value);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.Stop.stop_code)
}

// optional .transit_realtime.TranslatedString stop_name = 3;
inline bool Stop::has_stop_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stop_name_ != nullptr);
  return value;
}
inline void Stop::clear_stop_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.stop_name_ != nullptr) _impl_.stop_name_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::transit_realtime::TranslatedString& Stop::_internal_stop_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::transit_realtime::TranslatedString* p = _impl_.stop_name_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TranslatedString&>(::transit_realtime::_TranslatedString_default_instance_);
}
inline const ::transit_realtime::TranslatedString& Stop::stop_name() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.Stop.stop_name)
  return _internal_stop_name();
}
inline void Stop::unsafe_arena_set_allocated_stop_name(::transit_realtime::TranslatedString* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stop_name_);
  }
  _impl_.stop_name_ = reinterpret_cast<::transit_realtime::TranslatedString*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.Stop.stop_name)
}
inline ::transit_realtime::TranslatedString* Stop::release_stop_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::transit_realtime::TranslatedString* released = _impl_.stop_name_;
  _impl_.stop_name_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::transit_realtime::TranslatedString* Stop::unsafe_arena_release_stop_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.Stop.stop_name)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::transit_realtime::TranslatedString* temp = _impl_.stop_name_;
  _impl_.stop_name_ = nullptr;
  return temp;
}
inline ::transit_realtime::TranslatedString* Stop::_internal_mutable_stop_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.stop_name_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::transit_realtime::TranslatedString>(GetArena());
    _impl_.stop_name_ = reinterpret_cast<::transit_realtime::TranslatedString*>(p);
  }
  return _impl_.stop_name_;
}
inline ::transit_realtime::TranslatedString* Stop::mutable_stop_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000040u;
  ::transit_realtime::TranslatedString* _msg = _internal_mutable_stop_name();
  // @@protoc_insertion_point(field_mutable:transit_realtime.Stop.stop_name)
  return _msg;
}
inline void Stop::set_allocated_stop_name(::transit_realtime::TranslatedString* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.stop_name_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.stop_name_ = reinterpret_cast<::transit_realtime::TranslatedString*>(value);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.Stop.stop_name)
}

// optional .transit_realtime.TranslatedString tts_stop_name = 4;
inline bool Stop::has_tts_stop_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tts_stop_name_ != nullptr);
  return value;
}
inline void Stop::clear_tts_stop_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tts_stop_name_ != nullptr) _impl_.tts_stop_name_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::transit_realtime::TranslatedString& Stop::_internal_tts_stop_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::transit_realtime::TranslatedString* p = _impl_.tts_stop_name_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TranslatedString&>(::transit_realtime::_TranslatedString_default_instance_);
}
inline const ::transit_realtime::TranslatedString& Stop::tts_stop_name() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.Stop.tts_stop_name)
  return _internal_tts_stop_name();
}
inline void Stop::unsafe_arena_set_allocated_tts_stop_name(::transit_realtime::TranslatedString* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tts_stop_name_);
  }
  _impl_.tts_stop_name_ = reinterpret_cast<::transit_realtime::TranslatedString*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.Stop.tts_stop_name)
}
inline ::transit_realtime::TranslatedString* Stop::release_tts_stop_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::transit_realtime::TranslatedString* released = _impl_.tts_stop_name_;
  _impl_.tts_stop_name_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::transit_realtime::TranslatedString* Stop::unsafe_arena_release_tts_stop_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.Stop.tts_stop_name)

  _impl_._has_bits_[0] &= ~0x00000080u;
  ::transit_realtime::TranslatedString* temp = _impl_.tts_stop_name_;
  _impl_.tts_stop_name_ = nullptr;
  return temp;
}
inline ::transit_realtime::TranslatedString* Stop::_internal_mutable_tts_stop_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tts_stop_name_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::transit_realtime::TranslatedString>(GetArena());
    _impl_.tts_stop_name_ = reinterpret_cast<::transit_realtime::TranslatedString*>(p);
  }
  return _impl_.tts_stop_name_;
}
inline ::transit_realtime::TranslatedString* Stop::mutable_tts_stop_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000080u;
  ::transit_realtime::TranslatedString* _msg = _internal_mutable_tts_stop_name();
  // @@protoc_insertion_point(field_mutable:transit_realtime.Stop.tts_stop_name)
  return _msg;
}
inline void Stop::set_allocated_tts_stop_name(::transit_realtime::TranslatedString* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.tts_stop_name_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }

  _impl_.tts_stop_name_ = reinterpret_cast<::transit_realtime::TranslatedString*>(value);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.Stop.tts_stop_name)
}

// optional .transit_realtime.TranslatedString stop_desc = 5;
inline bool Stop::has_stop_desc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stop_desc_ != nullptr);
  return value;
}
inline void Stop::clear_stop_desc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.stop_desc_ != nullptr) _impl_.stop_desc_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::transit_realtime::TranslatedString& Stop::_internal_stop_desc() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::transit_realtime::TranslatedString* p = _impl_.stop_desc_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TranslatedString&>(::transit_realtime::_TranslatedString_default_instance_);
}
inline const ::transit_realtime::TranslatedString& Stop::stop_desc() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.Stop.stop_desc)
  return _internal_stop_desc();
}
inline void Stop::unsafe_arena_set_allocated_stop_desc(::transit_realtime::TranslatedString* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stop_desc_);
  }
  _impl_.stop_desc_ = reinterpret_cast<::transit_realtime::TranslatedString*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.Stop.stop_desc)
}
inline ::transit_realtime::TranslatedString* Stop::release_stop_desc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::transit_realtime::TranslatedString* released = _impl_.stop_desc_;
  _impl_.stop_desc_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::transit_realtime::TranslatedString* Stop::unsafe_arena_release_stop_desc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.Stop.stop_desc)

  _impl_._has_bits_[0] &= ~0x00000100u;
  ::transit_realtime::TranslatedString* temp = _impl_.stop_desc_;
  _impl_.stop_desc_ = nullptr;
  return temp;
}
inline ::transit_realtime::TranslatedString* Stop::_internal_mutable_stop_desc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.stop_desc_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::transit_realtime::TranslatedString>(GetArena());
    _impl_.stop_desc_ = reinterpret_cast<::transit_realtime::TranslatedString*>(p);
  }
  return _impl_.stop_desc_;
}
inline ::transit_realtime::TranslatedString* Stop::mutable_stop_desc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000100u;
  ::transit_realtime::TranslatedString* _msg = _internal_mutable_stop_desc();
  // @@protoc_insertion_point(field_mutable:transit_realtime.Stop.stop_desc)
  return _msg;
}
inline void Stop::set_allocated_stop_desc(::transit_realtime::TranslatedString* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.stop_desc_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }

  _impl_.stop_desc_ = reinterpret_cast<::transit_realtime::TranslatedString*>(value);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.Stop.stop_desc)
}

// optional float stop_lat = 6;
inline bool Stop::has_stop_lat() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void Stop::clear_stop_lat() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stop_lat_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline float Stop::stop_lat() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Stop.stop_lat)
  return _internal_stop_lat();
}
inline void Stop::set_stop_lat(float value) {
  _internal_set_stop_lat(value);
  _impl_._has_bits_[0] |= 0x00000800u;
  // @@protoc_insertion_point(field_set:transit_realtime.Stop.stop_lat)
}
inline float Stop::_internal_stop_lat() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stop_lat_;
}
inline void Stop::_internal_set_stop_lat(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stop_lat_ = value;
}

// optional float stop_lon = 7;
inline bool Stop::has_stop_lon() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void Stop::clear_stop_lon() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stop_lon_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline float Stop::stop_lon() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Stop.stop_lon)
  return _internal_stop_lon();
}
inline void Stop::set_stop_lon(float value) {
  _internal_set_stop_lon(value);
  _impl_._has_bits_[0] |= 0x00001000u;
  // @@protoc_insertion_point(field_set:transit_realtime.Stop.stop_lon)
}
inline float Stop::_internal_stop_lon() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stop_lon_;
}
inline void Stop::_internal_set_stop_lon(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stop_lon_ = value;
}

// optional string zone_id = 8;
inline bool Stop::has_zone_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Stop::clear_zone_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.zone_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Stop::zone_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.Stop.zone_id)
  return _internal_zone_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Stop::set_zone_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.zone_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:transit_realtime.Stop.zone_id)
}
inline std::string* Stop::mutable_zone_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_zone_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.Stop.zone_id)
  return _s;
}
inline const std::string& Stop::_internal_zone_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.zone_id_.Get();
}
inline void Stop::_internal_set_zone_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.zone_id_.Set(value, GetArena());
}
inline std::string* Stop::_internal_mutable_zone_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.zone_id_.Mutable( GetArena());
}
inline std::string* Stop::release_zone_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.Stop.zone_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.zone_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.zone_id_.Set("", GetArena());
  }
  return released;
}
inline void Stop::set_allocated_zone_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.zone_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.zone_id_.IsDefault()) {
    _impl_.zone_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.Stop.zone_id)
}

// optional .transit_realtime.TranslatedString stop_url = 9;
inline bool Stop::has_stop_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stop_url_ != nullptr);
  return value;
}
inline void Stop::clear_stop_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.stop_url_ != nullptr) _impl_.stop_url_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::transit_realtime::TranslatedString& Stop::_internal_stop_url() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::transit_realtime::TranslatedString* p = _impl_.stop_url_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TranslatedString&>(::transit_realtime::_TranslatedString_default_instance_);
}
inline const ::transit_realtime::TranslatedString& Stop::stop_url() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.Stop.stop_url)
  return _internal_stop_url();
}
inline void Stop::unsafe_arena_set_allocated_stop_url(::transit_realtime::TranslatedString* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stop_url_);
  }
  _impl_.stop_url_ = reinterpret_cast<::transit_realtime::TranslatedString*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.Stop.stop_url)
}
inline ::transit_realtime::TranslatedString* Stop::release_stop_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::transit_realtime::TranslatedString* released = _impl_.stop_url_;
  _impl_.stop_url_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::transit_realtime::TranslatedString* Stop::unsafe_arena_release_stop_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.Stop.stop_url)

  _impl_._has_bits_[0] &= ~0x00000200u;
  ::transit_realtime::TranslatedString* temp = _impl_.stop_url_;
  _impl_.stop_url_ = nullptr;
  return temp;
}
inline ::transit_realtime::TranslatedString* Stop::_internal_mutable_stop_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.stop_url_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::transit_realtime::TranslatedString>(GetArena());
    _impl_.stop_url_ = reinterpret_cast<::transit_realtime::TranslatedString*>(p);
  }
  return _impl_.stop_url_;
}
inline ::transit_realtime::TranslatedString* Stop::mutable_stop_url() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000200u;
  ::transit_realtime::TranslatedString* _msg = _internal_mutable_stop_url();
  // @@protoc_insertion_point(field_mutable:transit_realtime.Stop.stop_url)
  return _msg;
}
inline void Stop::set_allocated_stop_url(::transit_realtime::TranslatedString* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.stop_url_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }

  _impl_.stop_url_ = reinterpret_cast<::transit_realtime::TranslatedString*>(value);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.Stop.stop_url)
}

// optional string parent_station = 11;
inline bool Stop::has_parent_station() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Stop::clear_parent_station() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_station_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Stop::parent_station() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.Stop.parent_station)
  return _internal_parent_station();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Stop::set_parent_station(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.parent_station_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:transit_realtime.Stop.parent_station)
}
inline std::string* Stop::mutable_parent_station() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_parent_station();
  // @@protoc_insertion_point(field_mutable:transit_realtime.Stop.parent_station)
  return _s;
}
inline const std::string& Stop::_internal_parent_station() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.parent_station_.Get();
}
inline void Stop::_internal_set_parent_station(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.parent_station_.Set(value, GetArena());
}
inline std::string* Stop::_internal_mutable_parent_station() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.parent_station_.Mutable( GetArena());
}
inline std::string* Stop::release_parent_station() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.Stop.parent_station)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.parent_station_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.parent_station_.Set("", GetArena());
  }
  return released;
}
inline void Stop::set_allocated_parent_station(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.parent_station_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.parent_station_.IsDefault()) {
    _impl_.parent_station_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.Stop.parent_station)
}

// optional string stop_timezone = 12;
inline bool Stop::has_stop_timezone() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void Stop::clear_stop_timezone() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stop_timezone_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Stop::stop_timezone() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.Stop.stop_timezone)
  return _internal_stop_timezone();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Stop::set_stop_timezone(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.stop_timezone_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:transit_realtime.Stop.stop_timezone)
}
inline std::string* Stop::mutable_stop_timezone() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_stop_timezone();
  // @@protoc_insertion_point(field_mutable:transit_realtime.Stop.stop_timezone)
  return _s;
}
inline const std::string& Stop::_internal_stop_timezone() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stop_timezone_.Get();
}
inline void Stop::_internal_set_stop_timezone(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.stop_timezone_.Set(value, GetArena());
}
inline std::string* Stop::_internal_mutable_stop_timezone() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.stop_timezone_.Mutable( GetArena());
}
inline std::string* Stop::release_stop_timezone() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.Stop.stop_timezone)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.stop_timezone_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.stop_timezone_.Set("", GetArena());
  }
  return released;
}
inline void Stop::set_allocated_stop_timezone(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.stop_timezone_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.stop_timezone_.IsDefault()) {
    _impl_.stop_timezone_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.Stop.stop_timezone)
}

// optional .transit_realtime.Stop.WheelchairBoarding wheelchair_boarding = 13 [default = UNKNOWN];
inline bool Stop::has_wheelchair_boarding() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void Stop::clear_wheelchair_boarding() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wheelchair_boarding_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline ::transit_realtime::Stop_WheelchairBoarding Stop::wheelchair_boarding() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Stop.wheelchair_boarding)
  return _internal_wheelchair_boarding();
}
inline void Stop::set_wheelchair_boarding(::transit_realtime::Stop_WheelchairBoarding value) {
  _internal_set_wheelchair_boarding(value);
  _impl_._has_bits_[0] |= 0x00002000u;
  // @@protoc_insertion_point(field_set:transit_realtime.Stop.wheelchair_boarding)
}
inline ::transit_realtime::Stop_WheelchairBoarding Stop::_internal_wheelchair_boarding() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::transit_realtime::Stop_WheelchairBoarding>(_impl_.wheelchair_boarding_);
}
inline void Stop::_internal_set_wheelchair_boarding(::transit_realtime::Stop_WheelchairBoarding value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  assert(::transit_realtime::Stop_WheelchairBoarding_IsValid(value));
  _impl_.wheelchair_boarding_ = value;
}

// optional string level_id = 14;
inline bool Stop::has_level_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void Stop::clear_level_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.level_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& Stop::level_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.Stop.level_id)
  return _internal_level_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Stop::set_level_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.level_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:transit_realtime.Stop.level_id)
}
inline std::string* Stop::mutable_level_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_level_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.Stop.level_id)
  return _s;
}
inline const std::string& Stop::_internal_level_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.level_id_.Get();
}
inline void Stop::_internal_set_level_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.level_id_.Set(value, GetArena());
}
inline std::string* Stop::_internal_mutable_level_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.level_id_.Mutable( GetArena());
}
inline std::string* Stop::release_level_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.Stop.level_id)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.level_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.level_id_.Set("", GetArena());
  }
  return released;
}
inline void Stop::set_allocated_level_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.level_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.level_id_.IsDefault()) {
    _impl_.level_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.Stop.level_id)
}

// optional .transit_realtime.TranslatedString platform_code = 15;
inline bool Stop::has_platform_code() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.platform_code_ != nullptr);
  return value;
}
inline void Stop::clear_platform_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.platform_code_ != nullptr) _impl_.platform_code_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const ::transit_realtime::TranslatedString& Stop::_internal_platform_code() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::transit_realtime::TranslatedString* p = _impl_.platform_code_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::TranslatedString&>(::transit_realtime::_TranslatedString_default_instance_);
}
inline const ::transit_realtime::TranslatedString& Stop::platform_code() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.Stop.platform_code)
  return _internal_platform_code();
}
inline void Stop::unsafe_arena_set_allocated_platform_code(::transit_realtime::TranslatedString* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.platform_code_);
  }
  _impl_.platform_code_ = reinterpret_cast<::transit_realtime::TranslatedString*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.Stop.platform_code)
}
inline ::transit_realtime::TranslatedString* Stop::release_platform_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000400u;
  ::transit_realtime::TranslatedString* released = _impl_.platform_code_;
  _impl_.platform_code_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::transit_realtime::TranslatedString* Stop::unsafe_arena_release_platform_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.Stop.platform_code)

  _impl_._has_bits_[0] &= ~0x00000400u;
  ::transit_realtime::TranslatedString* temp = _impl_.platform_code_;
  _impl_.platform_code_ = nullptr;
  return temp;
}
inline ::transit_realtime::TranslatedString* Stop::_internal_mutable_platform_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.platform_code_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::transit_realtime::TranslatedString>(GetArena());
    _impl_.platform_code_ = reinterpret_cast<::transit_realtime::TranslatedString*>(p);
  }
  return _impl_.platform_code_;
}
inline ::transit_realtime::TranslatedString* Stop::mutable_platform_code() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000400u;
  ::transit_realtime::TranslatedString* _msg = _internal_mutable_platform_code();
  // @@protoc_insertion_point(field_mutable:transit_realtime.Stop.platform_code)
  return _msg;
}
inline void Stop::set_allocated_platform_code(::transit_realtime::TranslatedString* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.platform_code_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }

  _impl_.platform_code_ = reinterpret_cast<::transit_realtime::TranslatedString*>(value);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.Stop.platform_code)
}

// -------------------------------------------------------------------

// TripModifications_Modification

// optional .transit_realtime.StopSelector start_stop_selector = 1;
inline bool TripModifications_Modification::has_start_stop_selector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.start_stop_selector_ != nullptr);
  return value;
}
inline void TripModifications_Modification::clear_start_stop_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.start_stop_selector_ != nullptr) _impl_.start_stop_selector_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::transit_realtime::StopSelector& TripModifications_Modification::_internal_start_stop_selector() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::transit_realtime::StopSelector* p = _impl_.start_stop_selector_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::StopSelector&>(::transit_realtime::_StopSelector_default_instance_);
}
inline const ::transit_realtime::StopSelector& TripModifications_Modification::start_stop_selector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.TripModifications.Modification.start_stop_selector)
  return _internal_start_stop_selector();
}
inline void TripModifications_Modification::unsafe_arena_set_allocated_start_stop_selector(::transit_realtime::StopSelector* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.start_stop_selector_);
  }
  _impl_.start_stop_selector_ = reinterpret_cast<::transit_realtime::StopSelector*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.TripModifications.Modification.start_stop_selector)
}
inline ::transit_realtime::StopSelector* TripModifications_Modification::release_start_stop_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::transit_realtime::StopSelector* released = _impl_.start_stop_selector_;
  _impl_.start_stop_selector_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::transit_realtime::StopSelector* TripModifications_Modification::unsafe_arena_release_start_stop_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.TripModifications.Modification.start_stop_selector)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::transit_realtime::StopSelector* temp = _impl_.start_stop_selector_;
  _impl_.start_stop_selector_ = nullptr;
  return temp;
}
inline ::transit_realtime::StopSelector* TripModifications_Modification::_internal_mutable_start_stop_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.start_stop_selector_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::transit_realtime::StopSelector>(GetArena());
    _impl_.start_stop_selector_ = reinterpret_cast<::transit_realtime::StopSelector*>(p);
  }
  return _impl_.start_stop_selector_;
}
inline ::transit_realtime::StopSelector* TripModifications_Modification::mutable_start_stop_selector() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::transit_realtime::StopSelector* _msg = _internal_mutable_start_stop_selector();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripModifications.Modification.start_stop_selector)
  return _msg;
}
inline void TripModifications_Modification::set_allocated_start_stop_selector(::transit_realtime::StopSelector* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.start_stop_selector_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.start_stop_selector_ = reinterpret_cast<::transit_realtime::StopSelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripModifications.Modification.start_stop_selector)
}

// optional .transit_realtime.StopSelector end_stop_selector = 2;
inline bool TripModifications_Modification::has_end_stop_selector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.end_stop_selector_ != nullptr);
  return value;
}
inline void TripModifications_Modification::clear_end_stop_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.end_stop_selector_ != nullptr) _impl_.end_stop_selector_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::transit_realtime::StopSelector& TripModifications_Modification::_internal_end_stop_selector() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::transit_realtime::StopSelector* p = _impl_.end_stop_selector_;
  return p != nullptr ? *p : reinterpret_cast<const ::transit_realtime::StopSelector&>(::transit_realtime::_StopSelector_default_instance_);
}
inline const ::transit_realtime::StopSelector& TripModifications_Modification::end_stop_selector() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.TripModifications.Modification.end_stop_selector)
  return _internal_end_stop_selector();
}
inline void TripModifications_Modification::unsafe_arena_set_allocated_end_stop_selector(::transit_realtime::StopSelector* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.end_stop_selector_);
  }
  _impl_.end_stop_selector_ = reinterpret_cast<::transit_realtime::StopSelector*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:transit_realtime.TripModifications.Modification.end_stop_selector)
}
inline ::transit_realtime::StopSelector* TripModifications_Modification::release_end_stop_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::transit_realtime::StopSelector* released = _impl_.end_stop_selector_;
  _impl_.end_stop_selector_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::transit_realtime::StopSelector* TripModifications_Modification::unsafe_arena_release_end_stop_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.TripModifications.Modification.end_stop_selector)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::transit_realtime::StopSelector* temp = _impl_.end_stop_selector_;
  _impl_.end_stop_selector_ = nullptr;
  return temp;
}
inline ::transit_realtime::StopSelector* TripModifications_Modification::_internal_mutable_end_stop_selector() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.end_stop_selector_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::transit_realtime::StopSelector>(GetArena());
    _impl_.end_stop_selector_ = reinterpret_cast<::transit_realtime::StopSelector*>(p);
  }
  return _impl_.end_stop_selector_;
}
inline ::transit_realtime::StopSelector* TripModifications_Modification::mutable_end_stop_selector() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::transit_realtime::StopSelector* _msg = _internal_mutable_end_stop_selector();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripModifications.Modification.end_stop_selector)
  return _msg;
}
inline void TripModifications_Modification::set_allocated_end_stop_selector(::transit_realtime::StopSelector* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.end_stop_selector_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.end_stop_selector_ = reinterpret_cast<::transit_realtime::StopSelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripModifications.Modification.end_stop_selector)
}

// optional int32 propagated_modification_delay = 3 [default = 0];
inline bool TripModifications_Modification::has_propagated_modification_delay() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void TripModifications_Modification::clear_propagated_modification_delay() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.propagated_modification_delay_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t TripModifications_Modification::propagated_modification_delay() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripModifications.Modification.propagated_modification_delay)
  return _internal_propagated_modification_delay();
}
inline void TripModifications_Modification::set_propagated_modification_delay(::int32_t value) {
  _internal_set_propagated_modification_delay(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:transit_realtime.TripModifications.Modification.propagated_modification_delay)
}
inline ::int32_t TripModifications_Modification::_internal_propagated_modification_delay() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.propagated_modification_delay_;
}
inline void TripModifications_Modification::_internal_set_propagated_modification_delay(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.propagated_modification_delay_ = value;
}

// repeated .transit_realtime.ReplacementStop replacement_stops = 4;
inline int TripModifications_Modification::_internal_replacement_stops_size() const {
  return _internal_replacement_stops().size();
}
inline int TripModifications_Modification::replacement_stops_size() const {
  return _internal_replacement_stops_size();
}
inline void TripModifications_Modification::clear_replacement_stops() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.replacement_stops_.Clear();
}
inline ::transit_realtime::ReplacementStop* TripModifications_Modification::mutable_replacement_stops(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripModifications.Modification.replacement_stops)
  return _internal_mutable_replacement_stops()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::transit_realtime::ReplacementStop>* TripModifications_Modification::mutable_replacement_stops()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:transit_realtime.TripModifications.Modification.replacement_stops)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_replacement_stops();
}
inline const ::transit_realtime::ReplacementStop& TripModifications_Modification::replacement_stops(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.TripModifications.Modification.replacement_stops)
  return _internal_replacement_stops().Get(index);
}
inline ::transit_realtime::ReplacementStop* TripModifications_Modification::add_replacement_stops() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::transit_realtime::ReplacementStop* _add = _internal_mutable_replacement_stops()->Add();
  // @@protoc_insertion_point(field_add:transit_realtime.TripModifications.Modification.replacement_stops)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::transit_realtime::ReplacementStop>& TripModifications_Modification::replacement_stops() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:transit_realtime.TripModifications.Modification.replacement_stops)
  return _internal_replacement_stops();
}
inline const ::google::protobuf::RepeatedPtrField<::transit_realtime::ReplacementStop>&
TripModifications_Modification::_internal_replacement_stops() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.replacement_stops_;
}
inline ::google::protobuf::RepeatedPtrField<::transit_realtime::ReplacementStop>*
TripModifications_Modification::_internal_mutable_replacement_stops() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.replacement_stops_;
}

// optional string service_alert_id = 5;
inline bool TripModifications_Modification::has_service_alert_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TripModifications_Modification::clear_service_alert_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.service_alert_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TripModifications_Modification::service_alert_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.TripModifications.Modification.service_alert_id)
  return _internal_service_alert_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TripModifications_Modification::set_service_alert_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.service_alert_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:transit_realtime.TripModifications.Modification.service_alert_id)
}
inline std::string* TripModifications_Modification::mutable_service_alert_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_service_alert_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripModifications.Modification.service_alert_id)
  return _s;
}
inline const std::string& TripModifications_Modification::_internal_service_alert_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.service_alert_id_.Get();
}
inline void TripModifications_Modification::_internal_set_service_alert_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.service_alert_id_.Set(value, GetArena());
}
inline std::string* TripModifications_Modification::_internal_mutable_service_alert_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.service_alert_id_.Mutable( GetArena());
}
inline std::string* TripModifications_Modification::release_service_alert_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.TripModifications.Modification.service_alert_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.service_alert_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.service_alert_id_.Set("", GetArena());
  }
  return released;
}
inline void TripModifications_Modification::set_allocated_service_alert_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.service_alert_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.service_alert_id_.IsDefault()) {
    _impl_.service_alert_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripModifications.Modification.service_alert_id)
}

// optional uint64 last_modified_time = 6;
inline bool TripModifications_Modification::has_last_modified_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void TripModifications_Modification::clear_last_modified_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_modified_time_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t TripModifications_Modification::last_modified_time() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripModifications.Modification.last_modified_time)
  return _internal_last_modified_time();
}
inline void TripModifications_Modification::set_last_modified_time(::uint64_t value) {
  _internal_set_last_modified_time(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:transit_realtime.TripModifications.Modification.last_modified_time)
}
inline ::uint64_t TripModifications_Modification::_internal_last_modified_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.last_modified_time_;
}
inline void TripModifications_Modification::_internal_set_last_modified_time(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_modified_time_ = value;
}

// -------------------------------------------------------------------

// TripModifications_SelectedTrips

// repeated string trip_ids = 1;
inline int TripModifications_SelectedTrips::_internal_trip_ids_size() const {
  return _internal_trip_ids().size();
}
inline int TripModifications_SelectedTrips::trip_ids_size() const {
  return _internal_trip_ids_size();
}
inline void TripModifications_SelectedTrips::clear_trip_ids() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.trip_ids_.Clear();
}
inline std::string* TripModifications_SelectedTrips::add_trip_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_trip_ids()->Add();
  // @@protoc_insertion_point(field_add_mutable:transit_realtime.TripModifications.SelectedTrips.trip_ids)
  return _s;
}
inline const std::string& TripModifications_SelectedTrips::trip_ids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.TripModifications.SelectedTrips.trip_ids)
  return _internal_trip_ids().Get(index);
}
inline std::string* TripModifications_SelectedTrips::mutable_trip_ids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripModifications.SelectedTrips.trip_ids)
  return _internal_mutable_trip_ids()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void TripModifications_SelectedTrips::set_trip_ids(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_trip_ids()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:transit_realtime.TripModifications.SelectedTrips.trip_ids)
}
template <typename Arg_, typename... Args_>
inline void TripModifications_SelectedTrips::add_trip_ids(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_trip_ids(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:transit_realtime.TripModifications.SelectedTrips.trip_ids)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
TripModifications_SelectedTrips::trip_ids() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:transit_realtime.TripModifications.SelectedTrips.trip_ids)
  return _internal_trip_ids();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
TripModifications_SelectedTrips::mutable_trip_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:transit_realtime.TripModifications.SelectedTrips.trip_ids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_trip_ids();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
TripModifications_SelectedTrips::_internal_trip_ids() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.trip_ids_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
TripModifications_SelectedTrips::_internal_mutable_trip_ids() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.trip_ids_;
}

// optional string shape_id = 2;
inline bool TripModifications_SelectedTrips::has_shape_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TripModifications_SelectedTrips::clear_shape_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shape_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TripModifications_SelectedTrips::shape_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.TripModifications.SelectedTrips.shape_id)
  return _internal_shape_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TripModifications_SelectedTrips::set_shape_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.shape_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:transit_realtime.TripModifications.SelectedTrips.shape_id)
}
inline std::string* TripModifications_SelectedTrips::mutable_shape_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_shape_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripModifications.SelectedTrips.shape_id)
  return _s;
}
inline const std::string& TripModifications_SelectedTrips::_internal_shape_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shape_id_.Get();
}
inline void TripModifications_SelectedTrips::_internal_set_shape_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.shape_id_.Set(value, GetArena());
}
inline std::string* TripModifications_SelectedTrips::_internal_mutable_shape_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.shape_id_.Mutable( GetArena());
}
inline std::string* TripModifications_SelectedTrips::release_shape_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.TripModifications.SelectedTrips.shape_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.shape_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.shape_id_.Set("", GetArena());
  }
  return released;
}
inline void TripModifications_SelectedTrips::set_allocated_shape_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.shape_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.shape_id_.IsDefault()) {
    _impl_.shape_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripModifications.SelectedTrips.shape_id)
}

// -------------------------------------------------------------------

// TripModifications

// repeated .transit_realtime.TripModifications.SelectedTrips selected_trips = 1;
inline int TripModifications::_internal_selected_trips_size() const {
  return _internal_selected_trips().size();
}
inline int TripModifications::selected_trips_size() const {
  return _internal_selected_trips_size();
}
inline void TripModifications::clear_selected_trips() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.selected_trips_.Clear();
}
inline ::transit_realtime::TripModifications_SelectedTrips* TripModifications::mutable_selected_trips(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripModifications.selected_trips)
  return _internal_mutable_selected_trips()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::transit_realtime::TripModifications_SelectedTrips>* TripModifications::mutable_selected_trips()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:transit_realtime.TripModifications.selected_trips)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_selected_trips();
}
inline const ::transit_realtime::TripModifications_SelectedTrips& TripModifications::selected_trips(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.TripModifications.selected_trips)
  return _internal_selected_trips().Get(index);
}
inline ::transit_realtime::TripModifications_SelectedTrips* TripModifications::add_selected_trips() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::transit_realtime::TripModifications_SelectedTrips* _add = _internal_mutable_selected_trips()->Add();
  // @@protoc_insertion_point(field_add:transit_realtime.TripModifications.selected_trips)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::transit_realtime::TripModifications_SelectedTrips>& TripModifications::selected_trips() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:transit_realtime.TripModifications.selected_trips)
  return _internal_selected_trips();
}
inline const ::google::protobuf::RepeatedPtrField<::transit_realtime::TripModifications_SelectedTrips>&
TripModifications::_internal_selected_trips() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.selected_trips_;
}
inline ::google::protobuf::RepeatedPtrField<::transit_realtime::TripModifications_SelectedTrips>*
TripModifications::_internal_mutable_selected_trips() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.selected_trips_;
}

// repeated string start_times = 2;
inline int TripModifications::_internal_start_times_size() const {
  return _internal_start_times().size();
}
inline int TripModifications::start_times_size() const {
  return _internal_start_times_size();
}
inline void TripModifications::clear_start_times() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.start_times_.Clear();
}
inline std::string* TripModifications::add_start_times() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_start_times()->Add();
  // @@protoc_insertion_point(field_add_mutable:transit_realtime.TripModifications.start_times)
  return _s;
}
inline const std::string& TripModifications::start_times(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.TripModifications.start_times)
  return _internal_start_times().Get(index);
}
inline std::string* TripModifications::mutable_start_times(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripModifications.start_times)
  return _internal_mutable_start_times()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void TripModifications::set_start_times(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_start_times()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:transit_realtime.TripModifications.start_times)
}
template <typename Arg_, typename... Args_>
inline void TripModifications::add_start_times(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_start_times(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:transit_realtime.TripModifications.start_times)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
TripModifications::start_times() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:transit_realtime.TripModifications.start_times)
  return _internal_start_times();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
TripModifications::mutable_start_times() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:transit_realtime.TripModifications.start_times)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_start_times();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
TripModifications::_internal_start_times() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.start_times_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
TripModifications::_internal_mutable_start_times() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.start_times_;
}

// repeated string service_dates = 3;
inline int TripModifications::_internal_service_dates_size() const {
  return _internal_service_dates().size();
}
inline int TripModifications::service_dates_size() const {
  return _internal_service_dates_size();
}
inline void TripModifications::clear_service_dates() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.service_dates_.Clear();
}
inline std::string* TripModifications::add_service_dates() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_service_dates()->Add();
  // @@protoc_insertion_point(field_add_mutable:transit_realtime.TripModifications.service_dates)
  return _s;
}
inline const std::string& TripModifications::service_dates(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.TripModifications.service_dates)
  return _internal_service_dates().Get(index);
}
inline std::string* TripModifications::mutable_service_dates(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripModifications.service_dates)
  return _internal_mutable_service_dates()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void TripModifications::set_service_dates(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_service_dates()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:transit_realtime.TripModifications.service_dates)
}
template <typename Arg_, typename... Args_>
inline void TripModifications::add_service_dates(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_service_dates(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:transit_realtime.TripModifications.service_dates)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
TripModifications::service_dates() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:transit_realtime.TripModifications.service_dates)
  return _internal_service_dates();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
TripModifications::mutable_service_dates() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:transit_realtime.TripModifications.service_dates)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_service_dates();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
TripModifications::_internal_service_dates() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.service_dates_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
TripModifications::_internal_mutable_service_dates() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.service_dates_;
}

// repeated .transit_realtime.TripModifications.Modification modifications = 4;
inline int TripModifications::_internal_modifications_size() const {
  return _internal_modifications().size();
}
inline int TripModifications::modifications_size() const {
  return _internal_modifications_size();
}
inline void TripModifications::clear_modifications() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.modifications_.Clear();
}
inline ::transit_realtime::TripModifications_Modification* TripModifications::mutable_modifications(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripModifications.modifications)
  return _internal_mutable_modifications()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::transit_realtime::TripModifications_Modification>* TripModifications::mutable_modifications()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:transit_realtime.TripModifications.modifications)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_modifications();
}
inline const ::transit_realtime::TripModifications_Modification& TripModifications::modifications(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.TripModifications.modifications)
  return _internal_modifications().Get(index);
}
inline ::transit_realtime::TripModifications_Modification* TripModifications::add_modifications() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::transit_realtime::TripModifications_Modification* _add = _internal_mutable_modifications()->Add();
  // @@protoc_insertion_point(field_add:transit_realtime.TripModifications.modifications)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::transit_realtime::TripModifications_Modification>& TripModifications::modifications() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:transit_realtime.TripModifications.modifications)
  return _internal_modifications();
}
inline const ::google::protobuf::RepeatedPtrField<::transit_realtime::TripModifications_Modification>&
TripModifications::_internal_modifications() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.modifications_;
}
inline ::google::protobuf::RepeatedPtrField<::transit_realtime::TripModifications_Modification>*
TripModifications::_internal_mutable_modifications() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.modifications_;
}

// -------------------------------------------------------------------

// StopSelector

// optional uint32 stop_sequence = 1;
inline bool StopSelector::has_stop_sequence() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void StopSelector::clear_stop_sequence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stop_sequence_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t StopSelector::stop_sequence() const {
  // @@protoc_insertion_point(field_get:transit_realtime.StopSelector.stop_sequence)
  return _internal_stop_sequence();
}
inline void StopSelector::set_stop_sequence(::uint32_t value) {
  _internal_set_stop_sequence(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:transit_realtime.StopSelector.stop_sequence)
}
inline ::uint32_t StopSelector::_internal_stop_sequence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stop_sequence_;
}
inline void StopSelector::_internal_set_stop_sequence(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stop_sequence_ = value;
}

// optional string stop_id = 2;
inline bool StopSelector::has_stop_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void StopSelector::clear_stop_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stop_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StopSelector::stop_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.StopSelector.stop_id)
  return _internal_stop_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StopSelector::set_stop_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.stop_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:transit_realtime.StopSelector.stop_id)
}
inline std::string* StopSelector::mutable_stop_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_stop_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.StopSelector.stop_id)
  return _s;
}
inline const std::string& StopSelector::_internal_stop_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stop_id_.Get();
}
inline void StopSelector::_internal_set_stop_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.stop_id_.Set(value, GetArena());
}
inline std::string* StopSelector::_internal_mutable_stop_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.stop_id_.Mutable( GetArena());
}
inline std::string* StopSelector::release_stop_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.StopSelector.stop_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.stop_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.stop_id_.Set("", GetArena());
  }
  return released;
}
inline void StopSelector::set_allocated_stop_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.stop_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.stop_id_.IsDefault()) {
    _impl_.stop_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.StopSelector.stop_id)
}

// -------------------------------------------------------------------

// ReplacementStop

// optional int32 travel_time_to_stop = 1;
inline bool ReplacementStop::has_travel_time_to_stop() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ReplacementStop::clear_travel_time_to_stop() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.travel_time_to_stop_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t ReplacementStop::travel_time_to_stop() const {
  // @@protoc_insertion_point(field_get:transit_realtime.ReplacementStop.travel_time_to_stop)
  return _internal_travel_time_to_stop();
}
inline void ReplacementStop::set_travel_time_to_stop(::int32_t value) {
  _internal_set_travel_time_to_stop(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:transit_realtime.ReplacementStop.travel_time_to_stop)
}
inline ::int32_t ReplacementStop::_internal_travel_time_to_stop() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.travel_time_to_stop_;
}
inline void ReplacementStop::_internal_set_travel_time_to_stop(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.travel_time_to_stop_ = value;
}

// optional string stop_id = 2;
inline bool ReplacementStop::has_stop_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ReplacementStop::clear_stop_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stop_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ReplacementStop::stop_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:transit_realtime.ReplacementStop.stop_id)
  return _internal_stop_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReplacementStop::set_stop_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.stop_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:transit_realtime.ReplacementStop.stop_id)
}
inline std::string* ReplacementStop::mutable_stop_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_stop_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.ReplacementStop.stop_id)
  return _s;
}
inline const std::string& ReplacementStop::_internal_stop_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stop_id_.Get();
}
inline void ReplacementStop::_internal_set_stop_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.stop_id_.Set(value, GetArena());
}
inline std::string* ReplacementStop::_internal_mutable_stop_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.stop_id_.Mutable( GetArena());
}
inline std::string* ReplacementStop::release_stop_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:transit_realtime.ReplacementStop.stop_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.stop_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.stop_id_.Set("", GetArena());
  }
  return released;
}
inline void ReplacementStop::set_allocated_stop_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.stop_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.stop_id_.IsDefault()) {
    _impl_.stop_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.ReplacementStop.stop_id)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace transit_realtime


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::transit_realtime::FeedHeader_Incrementality> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::transit_realtime::FeedHeader_Incrementality>() {
  return ::transit_realtime::FeedHeader_Incrementality_descriptor();
}
template <>
struct is_proto_enum<::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship>() {
  return ::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship_descriptor();
}
template <>
struct is_proto_enum<::transit_realtime::VehiclePosition_VehicleStopStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::transit_realtime::VehiclePosition_VehicleStopStatus>() {
  return ::transit_realtime::VehiclePosition_VehicleStopStatus_descriptor();
}
template <>
struct is_proto_enum<::transit_realtime::VehiclePosition_CongestionLevel> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::transit_realtime::VehiclePosition_CongestionLevel>() {
  return ::transit_realtime::VehiclePosition_CongestionLevel_descriptor();
}
template <>
struct is_proto_enum<::transit_realtime::VehiclePosition_OccupancyStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::transit_realtime::VehiclePosition_OccupancyStatus>() {
  return ::transit_realtime::VehiclePosition_OccupancyStatus_descriptor();
}
template <>
struct is_proto_enum<::transit_realtime::Alert_Cause> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::transit_realtime::Alert_Cause>() {
  return ::transit_realtime::Alert_Cause_descriptor();
}
template <>
struct is_proto_enum<::transit_realtime::Alert_Effect> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::transit_realtime::Alert_Effect>() {
  return ::transit_realtime::Alert_Effect_descriptor();
}
template <>
struct is_proto_enum<::transit_realtime::Alert_SeverityLevel> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::transit_realtime::Alert_SeverityLevel>() {
  return ::transit_realtime::Alert_SeverityLevel_descriptor();
}
template <>
struct is_proto_enum<::transit_realtime::TripDescriptor_ScheduleRelationship> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::transit_realtime::TripDescriptor_ScheduleRelationship>() {
  return ::transit_realtime::TripDescriptor_ScheduleRelationship_descriptor();
}
template <>
struct is_proto_enum<::transit_realtime::VehicleDescriptor_WheelchairAccessible> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::transit_realtime::VehicleDescriptor_WheelchairAccessible>() {
  return ::transit_realtime::VehicleDescriptor_WheelchairAccessible_descriptor();
}
template <>
struct is_proto_enum<::transit_realtime::Stop_WheelchairBoarding> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::transit_realtime::Stop_WheelchairBoarding>() {
  return ::transit_realtime::Stop_WheelchairBoarding_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // gtfs_2drealtime_2eproto_2epb_2eh
